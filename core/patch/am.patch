diff --git a/src/core/hle/service/am/am.cpp b/src/core/hle/service/am/am.cpp
index ffbd11c4a..2f0d2f11b 100644
--- a/src/core/hle/service/am/am.cpp
+++ b/src/core/hle/service/am/am.cpp
@@ -2,13 +2,7 @@
 // Licensed under GPLv2 or any later version
 // Refer to the license.txt file included.

-#include <algorithm>
-#include <cstddef>
-#include <cstring>
-#include <cryptopp/aes.h>
-#include <cryptopp/modes.h>
-#include <fmt/format.h>
-#include <openssl/rand.h>
+#include "core/hle/service/am/am.h"
 #include "common/alignment.h"
 #include "common/archives.h"
 #include "common/common_paths.h"
@@ -29,7 +23,6 @@
 #include "core/hle/kernel/process.h"
 #include "core/hle/kernel/server_session.h"
 #include "core/hle/kernel/session.h"
-#include "core/hle/service/am/am.h"
 #include "core/hle/service/am/am_app.h"
 #include "core/hle/service/am/am_net.h"
 #include "core/hle/service/am/am_sys.h"
@@ -40,8 +33,16 @@
 #include "core/hw/rsa/rsa.h"
 #include "core/hw/unique_data.h"
 #include "core/loader/loader.h"
+#include "core/loader/ncch.h"
 #include "core/loader/smdh.h"
 #include "core/nus_download.h"
+#include <algorithm>
+#include <cryptopp/aes.h>
+#include <cryptopp/modes.h>
+#include <cstddef>
+#include <cstring>
+#include <fmt/format.h>
+#include <openssl/rand.h>

 SERIALIZE_EXPORT_IMPL(Service::AM::Module)
 SERVICE_CONSTRUCT_IMPL(Service::AM::Module)
@@ -55,7 +56,8 @@ constexpr u8 VARIATION_SYSTEM = 0x02;
 constexpr u32 TID_HIGH_UPDATE = 0x0004000E;
 constexpr u32 TID_HIGH_DLC = 0x0004008C;

-struct TitleInfo {
+struct TitleInfo
+{
     u64_le tid;
     u64_le size;
     u16_le version;
@@ -68,7 +70,8 @@ static_assert(sizeof(TitleInfo) == 0x18, "Title info structure size is wrong");
 constexpr u8 OWNERSHIP_DOWNLOADED = 0x01;
 constexpr u8 OWNERSHIP_OWNED = 0x02;

-struct ContentInfo {
+struct ContentInfo
+{
     u16_le index;
     u16_le type;
     u32_le content_id;
@@ -79,7 +82,8 @@ struct ContentInfo {

 static_assert(sizeof(ContentInfo) == 0x18, "Content info structure size is wrong");

-struct TicketInfo {
+struct TicketInfo
+{
     u64_le title_id;
     u64_le ticket_id;
     u16_le version;
@@ -89,17 +93,52 @@ struct TicketInfo {

 static_assert(sizeof(TicketInfo) == 0x18, "Ticket info structure size is wrong");

-class CIAFile::DecryptionState {
+bool CTCert::IsValid() const
+{
+    constexpr std::string_view expected_issuer_prod = "Nintendo CA - G3_NintendoCTR2prod";
+    constexpr std::string_view expected_issuer_dev = "Nintendo CA - G3_NintendoCTR2dev";
+    constexpr u32 expected_signature_type = 0x010005;
+
+    return signature_type == expected_signature_type
+           && (std::string(issuer.data()) == expected_issuer_prod
+               || std::string(issuer.data()) == expected_issuer_dev);
+
+    return false;
+}
+
+u32 CTCert::GetDeviceID() const
+{
+    constexpr std::string_view key_id_prefix = "CT";
+
+    const std::string key_id_str(key_id.data());
+    if (key_id_str.starts_with(key_id_prefix)) {
+        const std::string device_id = key_id_str.substr(key_id_prefix.size(),
+                                                        key_id_str.find('-') - key_id_prefix.size());
+        char* end_ptr;
+        const u32 device_id_value = std::strtoul(device_id.c_str(), &end_ptr, 16);
+        if (*end_ptr == '\0') {
+            return device_id_value;
+        }
+    }
+    // Error
+    return 0;
+}
+
+class CIAFile::DecryptionState
+{
 public:
     std::vector<CryptoPP::CBC_Mode<CryptoPP::AES>::Decryption> content;
 };

-NCCHCryptoFile::NCCHCryptoFile(const std::string& out_file, bool encrypted_content) {
+NCCHCryptoFile::NCCHCryptoFile(const std::string& out_file, bool encrypted_content)
+{
+#ifdef todotodo
     if (encrypted_content) {
         // A console unique crypto file is used to store the decrypted NCCH file. This is done
         // to prevent Azahar being used as a tool to download easy shareable decrypted contents
         // from the eshop.
-        file = HW::UniqueData::OpenUniqueCryptoFile(out_file, "wb",
+        file = HW::UniqueData::OpenUniqueCryptoFile(out_file,
+                                                    "wb",
                                                     HW::UniqueData::UniqueCryptoFileID::NCCH);
     } else {
         file = std::make_unique<FileUtil::IOFile>(out_file, "wb");
@@ -108,9 +147,13 @@ NCCHCryptoFile::NCCHCryptoFile(const std::string& out_file, bool encrypted_conte
     if (!file->IsOpen()) {
         is_error = true;
     }
+#else
+    file = std::make_unique<FileUtil::IOFile>(out_file, "wb");
+#endif
 }

-void NCCHCryptoFile::Write(const u8* buffer, std::size_t length) {
+void NCCHCryptoFile::Write(const u8* buffer, std::size_t length)
+{
     if (is_error)
         return;

@@ -155,7 +198,8 @@ void NCCHCryptoFile::Write(const u8* buffer, std::size_t length) {
                 InitKeys();
                 std::array<u8, 16> key_y_primary, key_y_secondary;

-                std::copy(ncch_header.signature, ncch_header.signature + key_y_primary.size(),
+                std::copy(ncch_header.signature,
+                          ncch_header.signature + key_y_primary.size(),
                           key_y_primary.begin());

                 if (!ncch_header.seed_crypto) {
@@ -163,7 +207,8 @@ void NCCHCryptoFile::Write(const u8* buffer, std::size_t length) {
                 } else {
                     auto opt{FileSys::GetSeed(ncch_header.program_id)};
                     if (!opt.has_value()) {
-                        LOG_ERROR(Service_AM, "Seed for program {:016X} not found",
+                        LOG_ERROR(Service_AM,
+                                  "Seed for program {:016X} not found",
                                   ncch_header.program_id);
                         is_error = true;
                     } else {
@@ -232,7 +277,8 @@ void NCCHCryptoFile::Write(const u8* buffer, std::size_t length) {
                 LOG_DEBUG(Service_AM, "NCCH version 0/2");
                 // In this version, CTR for each section is a magic number prefixed by partition ID
                 // (reverse order)
-                std::reverse_copy(ncch_header.partition_id, ncch_header.partition_id + 8,
+                std::reverse_copy(ncch_header.partition_id,
+                                  ncch_header.partition_id + 8,
                                   exheader_ctr.begin());
                 exefs_ctr = romfs_ctr = exheader_ctr;
                 exheader_ctr[8] = 1;
@@ -242,7 +288,8 @@ void NCCHCryptoFile::Write(const u8* buffer, std::size_t length) {
                 LOG_DEBUG(Service_AM, "NCCH version 1");
                 // In this version, CTR for each section is the section offset prefixed by partition
                 // ID, as if the entire NCCH image is encrypted using a single CTR stream.
-                std::copy(ncch_header.partition_id, ncch_header.partition_id + 8,
+                std::copy(ncch_header.partition_id,
+                          ncch_header.partition_id + 8,
                           exheader_ctr.begin());
                 exefs_ctr = romfs_ctr = exheader_ctr;
                 auto u32ToBEArray = [](u32 value) -> std::array<u8, 4> {
@@ -256,8 +303,7 @@ void NCCHCryptoFile::Write(const u8* buffer, std::size_t length) {
                 auto offset_exheader = u32ToBEArray(0x200); // exheader offset
                 auto offset_exefs = u32ToBEArray(ncch_header.exefs_offset * kBlockSize);
                 auto offset_romfs = u32ToBEArray(ncch_header.romfs_offset * kBlockSize);
-                std::copy(offset_exheader.begin(), offset_exheader.end(),
-                          exheader_ctr.begin() + 12);
+                std::copy(offset_exheader.begin(), offset_exheader.end(), exheader_ctr.begin() + 12);
                 std::copy(offset_exefs.begin(), offset_exefs.end(), exefs_ctr.begin() + 12);
                 std::copy(offset_romfs.begin(), offset_romfs.end(), romfs_ctr.begin() + 12);
             } else {
@@ -351,8 +397,8 @@ void NCCHCryptoFile::Write(const u8* buffer, std::size_t length) {
                     if (reg->type == CryptoRegion::EXHEADER) {
                         key = &primary_key;
                         ctr = &exheader_ctr;
-                    } else if (reg->type == CryptoRegion::EXEFS_HDR ||
-                               reg->type == CryptoRegion::EXEFS_PRI) {
+                    } else if (reg->type == CryptoRegion::EXEFS_HDR
+                               || reg->type == CryptoRegion::EXEFS_PRI) {
                         key = &primary_key;
                         ctr = &exefs_ctr;
                     } else if (reg->type == CryptoRegion::EXEFS_SEC) {
@@ -363,7 +409,8 @@ void NCCHCryptoFile::Write(const u8* buffer, std::size_t length) {
                         ctr = &romfs_ctr;
                     }

-                    CryptoPP::CTR_Mode<CryptoPP::AES>::Decryption d(key->data(), key->size(),
+                    CryptoPP::CTR_Mode<CryptoPP::AES>::Decryption d(key->data(),
+                                                                    key->size(),
                                                                     ctr->data());
                     size_t offset = written - reg->seek_from;
                     if (offset != 0) {
@@ -375,24 +422,26 @@ void NCCHCryptoFile::Write(const u8* buffer, std::size_t length) {
                     if (reg->type == CryptoRegion::EXEFS_HDR) {
                         if (exefs_header_written != sizeof(ExeFs_Header)) {
                             memcpy(reinterpret_cast<u8*>(&exefs_header) + exefs_header_written,
-                                   temp.data(), to_write);
+                                   temp.data(),
+                                   to_write);
                             exefs_header_written += to_write;
                         }
-                        if (!exefs_header_processed &&
-                            exefs_header_written == sizeof(ExeFs_Header)) {
+                        if (!exefs_header_processed
+                            && exefs_header_written == sizeof(ExeFs_Header)) {
                             for (int i = 0; i < 8; i++) {
                                 if (exefs_header.section[i].size != 0) {
-                                    bool is_primary =
-                                        memcmp(exefs_header.section[i].name, "icon", 4) == 0 ||
-                                        memcmp(exefs_header.section[i].name, "banner", 6) == 0;
-                                    regions.push_back(CryptoRegion{
-                                        .type = is_primary ? CryptoRegion::EXEFS_PRI
-                                                           : CryptoRegion::EXEFS_SEC,
-                                        .offset = reg->offset + sizeof(ExeFs_Header) +
-                                                  exefs_header.section[i].offset,
-                                        .size =
-                                            Common::AlignUp(exefs_header.section[i].size, 0x200),
-                                        .seek_from = reg->offset});
+                                    bool is_primary
+                                        = memcmp(exefs_header.section[i].name, "icon", 4) == 0
+                                          || memcmp(exefs_header.section[i].name, "banner", 6) == 0;
+                                    regions.push_back(
+                                        CryptoRegion{.type = is_primary ? CryptoRegion::EXEFS_PRI
+                                                                        : CryptoRegion::EXEFS_SEC,
+                                                     .offset = reg->offset + sizeof(ExeFs_Header)
+                                                               + exefs_header.section[i].offset,
+                                                     .size
+                                                     = Common::AlignUp(exefs_header.section[i].size,
+                                                                       0x200),
+                                                     .seek_from = reg->offset});
                                 }
                             }
                             exefs_header_processed = true;
@@ -409,19 +458,31 @@ void NCCHCryptoFile::Write(const u8* buffer, std::size_t length) {
     }
 }

-void AuthorizeCIAFileDecryption(CIAFile* cia_file, Kernel::HLERequestContext& ctx) {
+void AuthorizeCIAFileDecryption(CIAFile* cia_file, Kernel::HLERequestContext& ctx)
+{
     u64 caller_tid = ctx.ClientThread()->owner_process.lock()->codeset->program_id;
-    if (Common::Hacks::hack_manager.GetHackAllowMode(
-            Common::Hacks::HackType::DECRYPTION_AUTHORIZED, caller_tid,
-            Common::Hacks::HackAllowMode::DISALLOW) == Common::Hacks::HackAllowMode::ALLOW) {
+    if (Common::Hacks::hack_manager.GetHackAllowMode(Common::Hacks::HackType::DECRYPTION_AUTHORIZED,
+                                                     caller_tid,
+                                                     Common::Hacks::HackAllowMode::DISALLOW)
+        == Common::Hacks::HackAllowMode::ALLOW) {
         LOG_INFO(Service_AM, "Authorized encrypted CIA installation.");
         cia_file->decryption_authorized = true;
     }
 }

 CIAFile::CIAFile(Core::System& system_, Service::FS::MediaType media_type, bool from_cdn_)
-    : system(system_), from_cdn(from_cdn_), decryption_authorized(false), media_type(media_type),
-      decryption_state(std::make_unique<DecryptionState>()) {
+    : system(system_)
+    , from_cdn(from_cdn_)
+    , decryption_authorized(true)
+    , media_type(media_type)
+    , decryption_state(std::make_unique<DecryptionState>())
+{
+    if(Loader::getProgramId() == "0004000003070C00")
+    {
+        LOG_ERROR(Service_AM, "Avoiding Decryption");
+        decryption_authorized = false;
+    }
+
     // If data is being installing from CDN, provide a fake header to the container so that
     // it's not uninitialized.
     if (from_cdn) {
@@ -512,11 +583,13 @@ Result CIAFile::WriteTitleMetadata(std::span<const u8> tmd_data, std::size_t off
     return PrepareToImportContent(tmd);
 }

-ResultVal<std::size_t> CIAFile::WriteContentData(u64 offset, std::size_t length, const u8* buffer) {
+ResultVal<std::size_t> CIAFile::WriteContentData(u64 offset, std::size_t length, const u8* buffer)
+{
     // Data is not being buffered, so we have to keep track of how much of each <ID>.app
     // has been written since we might get a written buffer which contains multiple .app
     // contents or only part of a larger .app's contents.
     const u64 offset_max = offset + length;
+    bool success = true;
     for (std::size_t i = 0; i < content_written.size(); i++) {
         if (content_written[i] < container.GetContentSize(i)) {
             // The size, minimum unwritten offset, and maximum unwritten offset of this content
@@ -533,49 +606,55 @@ ResultVal<std::size_t> CIAFile::WriteContentData(u64 offset, std::size_t length,
             // Figure out how much of this content ID we have just recieved/can write out
             const u64 available_to_write = std::min(offset_max, range_max) - range_min;

-            // Since the incoming TMD has already been written, we can use GetTitleContentPath
-            // to get the content paths to write to.
+// Since the incoming TMD has already been written, we can use GetTitleContentPath
+// to get the content paths to write to.
+#ifdef todotodo
             const FileSys::TitleMetadata& tmd = container.GetTitleMetadata();
             if (i != current_content_index) {
                 current_content_index = static_cast<u16>(i);
-                current_content_file =
-                    std::make_unique<NCCHCryptoFile>(content_file_paths[i], decryption_authorized);
+                current_content_file = std::make_unique<NCCHCryptoFile>(content_file_paths[i],
+                                                                        decryption_authorized);
                 current_content_file->decryption_authorized = decryption_authorized;
             }
             auto& file = *current_content_file;

+#else
+            FileSys::TitleMetadata tmd = container.GetTitleMetadata();
+            auto& file = content_files[i];
+#endif
             std::vector<u8> temp(buffer + (range_min - offset),
                                  buffer + (range_min - offset) + available_to_write);

             if ((tmd.GetContentTypeByIndex(i) & FileSys::TMDContentTypeFlag::Encrypted) != 0) {
                 if (!decryption_authorized) {
                     LOG_ERROR(Service_AM, "Blocked unauthorized encrypted CIA installation.");
-                    return Result(ErrorDescription::NotAuthorized, ErrorModule::AM,
-                                  ErrorSummary::InvalidState, ErrorLevel::Permanent);
+                    return Result(ErrorDescription::NotAuthorized,
+                                  ErrorModule::AM,
+                                  ErrorSummary::InvalidState,
+                                  ErrorLevel::Permanent);
                 }
                 decryption_state->content[i].ProcessData(temp.data(), temp.data(), temp.size());
             }

-            file.Write(temp.data(), temp.size());
-            if (file.IsError()) {
-                // This can never happen in real HW
-                return Result(ErrCodes::InvalidImportState, ErrorModule::AM,
-                              ErrorSummary::InvalidState, ErrorLevel::Permanent);
-            }
+            file.WriteBytes(temp.data(), temp.size());

             // Keep tabs on how much of this content ID has been written so new range_min
             // values can be calculated.
             content_written[i] += available_to_write;
-            LOG_DEBUG(Service_AM, "Wrote {} to content {}, total {}", available_to_write, i,
+            LOG_DEBUG(Service_AM,
+                      "Wrote {} to content {}, total {}",
+                      available_to_write,
+                      i,
                       content_written[i]);
         }
     }

-    return length;
+    return success ? length : 0;
 }

-ResultVal<std::size_t> CIAFile::Write(u64 offset, std::size_t length, bool flush,
-                                      bool update_timestamp, const u8* buffer) {
+ResultVal<std::size_t> CIAFile::Write(
+    u64 offset, std::size_t length, bool flush, bool update_timestamp, const u8* buffer)
+{
     written += length;

     // TODO(shinyquagsire23): Can we assume that things will only be written in sequence?
@@ -588,8 +667,8 @@ ResultVal<std::size_t> CIAFile::Write(u64 offset, std::size_t length, bool flush
     // written and what we have been able to pick up.
     if (install_state == CIAInstallState::InstallStarted) {
         std::size_t buf_copy_size = std::min(length, FileSys::CIA_HEADER_SIZE);
-        std::size_t buf_max_size =
-            std::min(static_cast<std::size_t>(offset + length), FileSys::CIA_HEADER_SIZE);
+        std::size_t buf_max_size = std::min(static_cast<std::size_t>(offset + length),
+                                            FileSys::CIA_HEADER_SIZE);
         data.resize(buf_max_size);
         std::memcpy(data.data() + offset, buffer, buf_copy_size);

@@ -612,9 +691,10 @@ ResultVal<std::size_t> CIAFile::Write(u64 offset, std::size_t length, bool flush
         std::size_t buf_loaded = data.size();
         std::size_t copy_offset = std::max(static_cast<std::size_t>(offset), buf_loaded);
         std::size_t buf_offset = buf_loaded - offset;
-        std::size_t buf_copy_size =
-            std::min(length, static_cast<std::size_t>(container.GetContentOffset() - offset)) -
-            buf_offset;
+        std::size_t buf_copy_size = std::min(length,
+                                             static_cast<std::size_t>(container.GetContentOffset()
+                                                                      - offset))
+                                    - buf_offset;
         std::size_t buf_max_size = std::min(offset + length, container.GetContentOffset());
         data.resize(buf_max_size);
         std::memcpy(data.data() + copy_offset, buffer + buf_offset, buf_copy_size);
@@ -648,38 +728,56 @@ ResultVal<std::size_t> CIAFile::Write(u64 offset, std::size_t length, bool flush
     return length;
 }

-Result CIAFile::PrepareToImportContent(const FileSys::TitleMetadata& tmd) {
-
+Result CIAFile::PrepareToImportContent(const FileSys::TitleMetadata& tmd)
+{
     // Create any other .app folders which may not exist yet
     std::string app_folder;
-    auto main_content_path = GetTitleContentPath(media_type, tmd.GetTitleID(),
-                                                 FileSys::TMDContentIndex::Main, is_update);
+    auto main_content_path = GetTitleContentPath(media_type,
+                                                 tmd.GetTitleID(),
+                                                 FileSys::TMDContentIndex::Main,
+                                                 is_update);
     Common::SplitPath(main_content_path, &app_folder, nullptr, nullptr);
     FileUtil::CreateFullPath(app_folder);

     auto content_count = container.GetTitleMetadata().GetContentCount();
     content_written.resize(content_count);

+#ifdef todotodo
     current_content_file.reset();
     current_content_index = -1;
     content_file_paths.clear();
+#else
+    content_files.clear();
+#endif
     for (std::size_t i = 0; i < content_count; i++) {
         auto path = GetTitleContentPath(media_type, tmd.GetTitleID(), i, is_update);
+#ifdef todotodo
         content_file_paths.emplace_back(path);
+#else
+        auto& file = content_files.emplace_back(path, "wb");
+        if (!file.IsOpen()) {
+            LOG_ERROR(Service_AM, "Could not open output file '{}' for content {}.", path, i);
+            // TODO: Correct error code.
+            return FileSys::ResultFileNotFound;
+        }
+#endif
     }

     if (container.GetTitleMetadata().HasEncryptedContent(from_cdn ? nullptr
                                                                   : container.GetHeader())) {
         if (!decryption_authorized) {
             LOG_ERROR(Service_AM, "Blocked unauthorized encrypted CIA installation.");
-            return {ErrorDescription::NotAuthorized, ErrorModule::AM, ErrorSummary::InvalidState,
+            return {ErrorDescription::NotAuthorized,
+                    ErrorModule::AM,
+                    ErrorSummary::InvalidState,
                     ErrorLevel::Permanent};
         } else {
             if (auto title_key = container.GetTicket().GetTitleKey()) {
                 decryption_state->content.resize(content_count);
                 for (std::size_t i = 0; i < content_count; ++i) {
                     auto ctr = tmd.GetContentCTRByIndex(i);
-                    decryption_state->content[i].SetKeyWithIV(title_key->data(), title_key->size(),
+                    decryption_state->content[i].SetKeyWithIV(title_key->data(),
+                                                              title_key->size(),
                                                               ctr.data());
                 }
             } else {
@@ -698,7 +796,8 @@ Result CIAFile::PrepareToImportContent(const FileSys::TitleMetadata& tmd) {
     return ResultSuccess;
 }

-Result CIAFile::ProvideTicket(const FileSys::Ticket& ticket) {
+Result CIAFile::ProvideTicket(const FileSys::Ticket& ticket)
+{
     // There is no need to write the ticket to nand, as that will
     ASSERT_MSG(from_cdn, "This method should only be used when installing from CDN");

@@ -706,7 +805,9 @@ Result CIAFile::ProvideTicket(const FileSys::Ticket& ticket) {
     if (load_result != Loader::ResultStatus::Success) {
         LOG_ERROR(Service_AM, "Could not read ticket from CIA.");
         // TODO: Correct result code.
-        return {ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        return {ErrCodes::InvalidCIAHeader,
+                ErrorModule::AM,
+                ErrorSummary::InvalidArgument,
                 ErrorLevel::Permanent};
     }

@@ -714,13 +815,16 @@ Result CIAFile::ProvideTicket(const FileSys::Ticket& ticket) {
     return ResultSuccess;
 }

-Result CIAFile::ProvideTMDForAdditionalContent(const FileSys::TitleMetadata& tmd) {
+Result CIAFile::ProvideTMDForAdditionalContent(const FileSys::TitleMetadata& tmd)
+{
     ASSERT_MSG(from_cdn, "This method should only be used when installing from CDN");

     if (install_state != CIAInstallState::TicketLoaded) {
         LOG_ERROR(Service_AM, "Ticket not provided yet");
         // TODO: Correct result code.
-        return {ErrCodes::InvalidImportState, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        return {ErrCodes::InvalidImportState,
+                ErrorModule::AM,
+                ErrorSummary::InvalidArgument,
                 ErrorLevel::Permanent};
     }

@@ -728,7 +832,9 @@ Result CIAFile::ProvideTMDForAdditionalContent(const FileSys::TitleMetadata& tmd
     if (load_result != Loader::ResultStatus::Success) {
         LOG_ERROR(Service_AM, "Could not read ticket from CIA.");
         // TODO: Correct result code.
-        return {ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        return {ErrCodes::InvalidCIAHeader,
+                ErrorModule::AM,
+                ErrorSummary::InvalidArgument,
                 ErrorLevel::Permanent};
     }

@@ -737,23 +843,27 @@ Result CIAFile::ProvideTMDForAdditionalContent(const FileSys::TitleMetadata& tmd
     return PrepareToImportContent(container.GetTitleMetadata());
 }

-const FileSys::TitleMetadata& CIAFile::GetTMD() {
+const FileSys::TitleMetadata& CIAFile::GetTMD()
+{
     return container.GetTitleMetadata();
 }

-FileSys::Ticket& CIAFile::GetTicket() {
+FileSys::Ticket& CIAFile::GetTicket()
+{
     return container.GetTicket();
 }

-ResultVal<std::size_t> CIAFile::WriteContentDataIndexed(u16 content_index, u64 offset,
-                                                        std::size_t length, const u8* buffer) {
-
+ResultVal<std::size_t> CIAFile::WriteContentDataIndexed(u16 content_index,
+                                                        u64 offset,
+                                                        std::size_t length,
+                                                        const u8* buffer)
+{
     ASSERT_MSG(from_cdn, "This method should only be used when installing from CDN");

     const FileSys::TitleMetadata& tmd = container.GetTitleMetadata();

-    u64 remaining_to_write =
-        tmd.GetContentSizeByIndex(content_index) - content_written[content_index];
+    u64 remaining_to_write = tmd.GetContentSizeByIndex(content_index)
+                             - content_written[content_index];

     if (content_index != current_content_index) {
         current_content_index = content_index;
@@ -768,48 +878,53 @@ ResultVal<std::size_t> CIAFile::WriteContentDataIndexed(u16 content_index, u64 o
     if ((tmd.GetContentTypeByIndex(content_index) & FileSys::TMDContentTypeFlag::Encrypted) != 0) {
         if (!decryption_authorized) {
             LOG_ERROR(Service_AM, "Blocked unauthorized encrypted CIA installation.");
-            return Result(ErrorDescription::NotAuthorized, ErrorModule::AM,
-                          ErrorSummary::InvalidState, ErrorLevel::Permanent);
+            return Result(ErrorDescription::NotAuthorized,
+                          ErrorModule::AM,
+                          ErrorSummary::InvalidState,
+                          ErrorLevel::Permanent);
         }
         decryption_state->content[content_index].ProcessData(temp.data(), temp.data(), temp.size());
     }

     file.Write(temp.data(), temp.size());
-    if (file.IsError()) {
-        // This can never happen in real HW
-        return Result(ErrCodes::InvalidImportState, ErrorModule::AM, ErrorSummary::InvalidState,
-                      ErrorLevel::Permanent);
-    }
+    bool success = !file.IsError();

     content_written[content_index] += temp.size();
-    LOG_DEBUG(Service_AM, "Wrote {} to content {}, total {}", temp.size(), content_index,
+    LOG_DEBUG(Service_AM,
+              "Wrote {} to content {}, total {}",
+              temp.size(),
+              content_index,
               content_written[content_index]);

-    return temp.size();
+    return success ? temp.size() : 0;
 }

-u64 CIAFile::GetSize() const {
+u64 CIAFile::GetSize() const
+{
     return written;
 }

-bool CIAFile::SetSize(u64 size) const {
+bool CIAFile::SetSize(u64 size) const
+{
     return false;
 }

-bool CIAFile::Close() {
+bool CIAFile::Close()
+{
     if (is_closed)
         return true;
     is_closed = true;

-    bool complete =
-        from_cdn ? is_done
-                 : (install_state >= CIAInstallState::TMDLoaded &&
-                    content_written.size() == container.GetTitleMetadata().GetContentCount() &&
-                    std::all_of(content_written.begin(), content_written.end(),
-                                [this, i = 0](auto& bytes_written) mutable {
-                                    return bytes_written >=
-                                           container.GetContentSize(static_cast<u16>(i++));
-                                }));
+    bool complete = from_cdn ? is_done
+                             : (install_state >= CIAInstallState::TMDLoaded
+                                && content_written.size()
+                                       == container.GetTitleMetadata().GetContentCount()
+                                && std::all_of(content_written.begin(),
+                                               content_written.end(),
+                                               [this, i = 0](auto& bytes_written) mutable {
+                                                   return bytes_written >= container.GetContentSize(
+                                                              static_cast<u16>(i++));
+                                               }));

     // Install aborted
     if (!complete) {
@@ -822,10 +937,12 @@ bool CIAFile::Close() {
     }

     // Clean up older content data if we installed newer content on top
-    std::string old_tmd_path =
-        GetTitleMetadataPath(media_type, container.GetTitleMetadata().GetTitleID(), false);
-    std::string new_tmd_path =
-        GetTitleMetadataPath(media_type, container.GetTitleMetadata().GetTitleID(), true);
+    std::string old_tmd_path = GetTitleMetadataPath(media_type,
+                                                    container.GetTitleMetadata().GetTitleID(),
+                                                    false);
+    std::string new_tmd_path = GetTitleMetadataPath(media_type,
+                                                    container.GetTitleMetadata().GetTitleID(),
+                                                    true);
     if (FileUtil::Exists(new_tmd_path) && old_tmd_path != new_tmd_path) {
         FileSys::TitleMetadata old_tmd;
         FileSys::TitleMetadata new_tmd;
@@ -839,8 +956,8 @@ bool CIAFile::Close() {
         for (std::size_t old_index = 0; old_index < old_tmd.GetContentCount(); old_index++) {
             bool abort = false;
             for (std::size_t new_index = 0; new_index < new_tmd.GetContentCount(); new_index++) {
-                if (old_tmd.GetContentIDByIndex(old_index) ==
-                    new_tmd.GetContentIDByIndex(new_index)) {
+                if (old_tmd.GetContentIDByIndex(old_index)
+                    == new_tmd.GetContentIDByIndex(new_index)) {
                     abort = true;
                 }
             }
@@ -851,8 +968,7 @@ bool CIAFile::Close() {
             // If the file to delete is the current launched rom, signal the system to delete
             // the current rom instead of deleting it now, once all the handles to the file
             // are closed.
-            std::string to_delete =
-                GetTitleContentPath(media_type, old_tmd.GetTitleID(), old_index);
+            std::string to_delete = GetTitleContentPath(media_type, old_tmd.GetTitleID(), old_index);
             if (!system.IsPoweredOn() || !system.SetSelfDelete(to_delete)) {
                 FileUtil::Delete(to_delete);
             }
@@ -867,38 +983,51 @@ void CIAFile::Flush() const {}

 TicketFile::TicketFile() {}

-TicketFile::~TicketFile() {
+TicketFile::~TicketFile()
+{
     Close();
 }

-ResultVal<std::size_t> TicketFile::Read(u64 offset, std::size_t length, u8* buffer) const {
+ResultVal<std::size_t> TicketFile::Read(u64 offset, std::size_t length, u8* buffer) const
+{
     UNIMPLEMENTED();
     return length;
 }

-ResultVal<std::size_t> TicketFile::Write(u64 offset, std::size_t length, bool flush,
-                                         bool update_timestamp, const u8* buffer) {
+ResultVal<std::size_t> TicketFile::Write(
+    u64 offset, std::size_t length, bool flush, bool update_timestamp, const u8* buffer)
+{
     written += length;
     data.resize(written);
     std::memcpy(data.data() + offset, buffer, length);
     return length;
 }

-u64 TicketFile::GetSize() const {
+u64 TicketFile::GetSize() const
+{
     return written;
 }

-bool TicketFile::SetSize(u64 size) const {
+bool TicketFile::SetSize(u64 size) const
+{
     return false;
 }

-bool TicketFile::Close() {
+bool TicketFile::Close()
+{
+    FileSys::Ticket ticket;
+    if (ticket.Load(data, 0) == Loader::ResultStatus::Success) {
+        LOG_WARNING(Service_AM, "Discarding ticket for {:#016X}.", ticket.GetTitleID());
+    } else {
+        LOG_ERROR(Service_AM, "Invalid ticket provided to TicketFile.");
+    }
     return true;
 }

 void TicketFile::Flush() const {}

-Result TicketFile::Commit() {
+Result TicketFile::Commit()
+{
     FileSys::Ticket ticket;
     if (ticket.Load(data, 0) == Loader::ResultStatus::Success) {
         if (ticket.DoTitlekeyFixup() != Loader::ResultStatus::Success) {
@@ -910,6 +1039,11 @@ Result TicketFile::Commit() {
         ticket_id = ticket.GetTicketID();
         const auto ticket_path = GetTicketPath(ticket.GetTitleID(), ticket.GetTicketID());

+        // Create ticket folder if it does not exist
+        std::string ticket_folder;
+        Common::SplitPath(ticket_path, &ticket_folder, nullptr, nullptr);
+        FileUtil::CreateFullPath(ticket_folder);
+
         // Save ticket
         if (ticket.Save(ticket_path) != Loader::ResultStatus::Success) {
             LOG_ERROR(Service_AM, "Failed to install ticket provided to TicketFile.");
@@ -922,52 +1056,62 @@ Result TicketFile::Commit() {
     }
 }

-TMDFile::~TMDFile() {
+TMDFile::~TMDFile()
+{
     Close();
 }

-ResultVal<std::size_t> TMDFile::Read(u64 offset, std::size_t length, u8* buffer) const {
+ResultVal<std::size_t> TMDFile::Read(u64 offset, std::size_t length, u8* buffer) const
+{
     UNIMPLEMENTED();
     return length;
 }

-ResultVal<std::size_t> TMDFile::Write(u64 offset, std::size_t length, bool flush,
-                                      bool update_timestamp, const u8* buffer) {
+ResultVal<std::size_t> TMDFile::Write(
+    u64 offset, std::size_t length, bool flush, bool update_timestamp, const u8* buffer)
+{
     written += length;
     data.resize(written);
     std::memcpy(data.data() + offset, buffer, length);
     return length;
 }

-u64 TMDFile::GetSize() const {
+u64 TMDFile::GetSize() const
+{
     return written;
 }

-bool TMDFile::SetSize(u64 size) const {
+bool TMDFile::SetSize(u64 size) const
+{
     return false;
 }

-bool TMDFile::Close() {
+bool TMDFile::Close()
+{
     return true;
 }

 void TMDFile::Flush() const {}

-Result TMDFile::Commit() {
+Result TMDFile::Commit()
+{
     return importing_title->cia_file.WriteTitleMetadata(data, 0);
 }

-ContentFile::~ContentFile() {
+ContentFile::~ContentFile()
+{
     Close();
 }

-ResultVal<std::size_t> ContentFile::Read(u64 offset, std::size_t length, u8* buffer) const {
+ResultVal<std::size_t> ContentFile::Read(u64 offset, std::size_t length, u8* buffer) const
+{
     UNIMPLEMENTED();
     return length;
 }

-ResultVal<std::size_t> ContentFile::Write(u64 offset, std::size_t length, bool flush,
-                                          bool update_timestamp, const u8* buffer) {
+ResultVal<std::size_t> ContentFile::Write(
+    u64 offset, std::size_t length, bool flush, bool update_timestamp, const u8* buffer)
+{
     auto res = importing_title->cia_file.WriteContentDataIndexed(index, offset, length, buffer);
     if (res.Succeeded()) {
         import_context.current_size += static_cast<u64>(res.Unwrap());
@@ -975,27 +1119,31 @@ ResultVal<std::size_t> ContentFile::Write(u64 offset, std::size_t length, bool f
     return res;
 }

-u64 ContentFile::GetSize() const {
+u64 ContentFile::GetSize() const
+{
     return written;
 }

-bool ContentFile::SetSize(u64 size) const {
+bool ContentFile::SetSize(u64 size) const
+{
     return false;
 }

-bool ContentFile::Close() {
+bool ContentFile::Close()
+{
     return false;
 }

 void ContentFile::Flush() const {}

-void ContentFile::Cancel(FS::MediaType media_type, u64 title_id) {
+void ContentFile::Cancel(FS::MediaType media_type, u64 title_id)
+{
     auto path = GetTitleContentPath(media_type, title_id, index, true);
     FileUtil::Delete(path);
 }

-InstallStatus InstallCIA(const std::string& path,
-                         std::function<ProgressCallback>&& update_callback) {
+InstallStatus InstallCIA(const std::string& path, std::function<ProgressCallback>&& update_callback)
+{
     LOG_INFO(Service_AM, "Installing {}...", path);

     if (!FileUtil::Exists(path)) {
@@ -1005,12 +1153,15 @@ InstallStatus InstallCIA(const std::string& path,

     FileSys::CIAContainer container;
     if (container.Load(path) == Loader::ResultStatus::Success) {
-        Service::AM::CIAFile installFile(
-            Core::System::GetInstance(),
-            Service::AM::GetTitleMediaType(container.GetTitleMetadata().GetTitleID()));
-
-        if (container.GetTitleMetadata().HasEncryptedContent(container.GetHeader())) {
-            LOG_ERROR(Service_AM, "File {} is encrypted! Aborting...", path);
+        Service::AM::CIAFile installFile(Core::System::GetInstance(),
+                                         Service::AM::GetTitleMediaType(
+                                             container.GetTitleMetadata().GetTitleID()));
+
+        bool title_key_available = container.GetTicket().GetTitleKey().has_value();
+        if (!title_key_available && container.GetTitleMetadata().HasEncryptedContent()) {
+            LOG_ERROR(Service_AM,
+                      "File {} is encrypted and no title key is available! Aborting...",
+                      path);
             return InstallStatus::ErrorEncrypted;
         }

@@ -1020,20 +1171,28 @@ InstallStatus InstallCIA(const std::string& path,
             return InstallStatus::ErrorFailedToOpenFile;
         }

+#ifdef todotodo
         std::vector<u8> buffer;
         buffer.resize(0x10000);
+#else
+        std::array<u8, 0x10000> buffer;
+#endif
         auto file_size = file.GetSize();
         std::size_t total_bytes_read = 0;
         while (total_bytes_read != file_size) {
             std::size_t bytes_read = file.ReadBytes(buffer.data(), buffer.size());
-            auto result = installFile.Write(static_cast<u64>(total_bytes_read), bytes_read, true,
-                                            false, static_cast<u8*>(buffer.data()));
+            auto result = installFile.Write(static_cast<u64>(total_bytes_read),
+                                            bytes_read,
+                                            true,
+                                            false,
+                                            static_cast<u8*>(buffer.data()));

             if (update_callback) {
                 update_callback(total_bytes_read, file_size);
             }
             if (result.Failed()) {
-                LOG_ERROR(Service_AM, "CIA file installation aborted with error code {:08x}",
+                LOG_ERROR(Service_AM,
+                          "CIA file installation aborted with error code {:08x}",
                           result.Code().raw);
                 return InstallStatus::ErrorAborted;
             }
@@ -1044,7 +1203,8 @@ InstallStatus InstallCIA(const std::string& path,
         LOG_INFO(Service_AM, "Installed {} successfully.", path);

         const FileUtil::DirectoryEntryCallable callback =
-            [&callback](u64* num_entries_out, const std::string& directory,
+            [&callback](u64* num_entries_out,
+                        const std::string& directory,
                         const std::string& virtual_name) -> bool {
             const std::string physical_name = directory + DIR_SEP + virtual_name;
             const bool is_dir = FileUtil::IsDirectory(physical_name);
@@ -1064,12 +1224,12 @@ InstallStatus InstallCIA(const std::string& path,
                 return FileUtil::ForeachDirectoryEntry(nullptr, physical_name, callback);
             }
         };
-        if (!FileUtil::ForeachDirectoryEntry(
-                nullptr,
-                GetTitlePath(
-                    Service::AM::GetTitleMediaType(container.GetTitleMetadata().GetTitleID()),
-                    container.GetTitleMetadata().GetTitleID()),
-                callback)) {
+        if (!FileUtil::ForeachDirectoryEntry(nullptr,
+                                             GetTitlePath(Service::AM::GetTitleMediaType(
+                                                              container.GetTitleMetadata()
+                                                                  .GetTitleID()),
+                                                          container.GetTitleMetadata().GetTitleID()),
+                                             callback)) {
             LOG_ERROR(Service_AM, "CIA {} contained encrypted files.", path);
             return InstallStatus::ErrorEncrypted;
         }
@@ -1080,12 +1240,105 @@ InstallStatus InstallCIA(const std::string& path,
     return InstallStatus::ErrorInvalid;
 }

-u64 GetTitleUpdateId(u64 title_id) {
+InstallStatus InstallFromNus(u64 title_id, int version)
+{
+    LOG_DEBUG(Service_AM, "Downloading {:X}", title_id);
+
+    CIAFile install_file{Core::System::GetInstance(), GetTitleMediaType(title_id)};
+
+    std::string path = fmt::format("/ccs/download/{:016X}/tmd", title_id);
+    if (version != -1) {
+        path += fmt::format(".{}", version);
+    }
+    auto tmd_response = Core::NUS::Download(path);
+    if (!tmd_response) {
+        LOG_ERROR(Service_AM, "Failed to download tmd for {:016X}", title_id);
+        return InstallStatus::ErrorFileNotFound;
+    }
+    FileSys::TitleMetadata tmd;
+    tmd.Load(*tmd_response);
+
+    path = fmt::format("/ccs/download/{:016X}/cetk", title_id);
+    auto cetk_response = Core::NUS::Download(path);
+    if (!cetk_response) {
+        LOG_ERROR(Service_AM, "Failed to download cetk for {:016X}", title_id);
+        return InstallStatus::ErrorFileNotFound;
+    }
+
+    std::vector<u8> content;
+    const auto content_count = tmd.GetContentCount();
+    for (std::size_t i = 0; i < content_count; ++i) {
+        const std::string filename = fmt::format("{:08x}", tmd.GetContentIDByIndex(i));
+        path = fmt::format("/ccs/download/{:016X}/{}", title_id, filename);
+        const auto temp_response = Core::NUS::Download(path);
+        if (!temp_response) {
+            LOG_ERROR(Service_AM, "Failed to download content for {:016X}", title_id);
+            return InstallStatus::ErrorFileNotFound;
+        }
+        content.insert(content.end(), temp_response->begin(), temp_response->end());
+    }
+
+    FileSys::CIAHeader fake_header{
+        .header_size = sizeof(FileSys::CIAHeader),
+        .type = 0,
+        .version = 0,
+        .cert_size = 0,
+        .tik_size = static_cast<u32_le>(cetk_response->size()),
+        .tmd_size = static_cast<u32_le>(tmd_response->size()),
+        .meta_size = 0,
+    };
+    for (u16 i = 0; i < content_count; ++i) {
+        fake_header.SetContentPresent(i);
+    }
+    std::vector<u8> header_data(sizeof(fake_header));
+    std::memcpy(header_data.data(), &fake_header, sizeof(fake_header));
+
+    std::size_t current_offset = 0;
+    const auto write_to_cia_file_aligned = [&install_file, &current_offset](std::vector<u8>& data) {
+        const u64 offset = Common::AlignUp(current_offset + data.size(),
+                                           FileSys::CIA_SECTION_ALIGNMENT);
+        data.resize(offset - current_offset, 0);
+        const auto result = install_file.Write(current_offset, data.size(), true, false, data.data());
+        if (result.Failed()) {
+            LOG_ERROR(Service_AM,
+                      "CIA file installation aborted with error code {:08x}",
+                      result.Code().raw);
+            return InstallStatus::ErrorAborted;
+        }
+        current_offset += data.size();
+        return InstallStatus::Success;
+    };
+
+    auto result = write_to_cia_file_aligned(header_data);
+    if (result != InstallStatus::Success) {
+        return result;
+    }
+
+    result = write_to_cia_file_aligned(*cetk_response);
+    if (result != InstallStatus::Success) {
+        return result;
+    }
+
+    result = write_to_cia_file_aligned(*tmd_response);
+    if (result != InstallStatus::Success) {
+        return result;
+    }
+
+    result = write_to_cia_file_aligned(content);
+    if (result != InstallStatus::Success) {
+        return result;
+    }
+    return InstallStatus::Success;
+}
+
+u64 GetTitleUpdateId(u64 title_id)
+{
     // Real services seem to just discard and replace the whole high word.
     return (title_id & 0xFFFFFFFF) | (static_cast<u64>(TID_HIGH_UPDATE) << 32);
 }

-Service::FS::MediaType GetTitleMediaType(u64 titleId) {
+Service::FS::MediaType GetTitleMediaType(u64 titleId)
+{
     u16 platform = static_cast<u16>(titleId >> 48);
     u16 category = static_cast<u16>((titleId >> 32) & 0xFFFF);
     u8 variation = static_cast<u8>(titleId & 0xFF);
@@ -1099,15 +1352,18 @@ Service::FS::MediaType GetTitleMediaType(u64 titleId) {
     return Service::FS::MediaType::SDMC;
 }

-std::string GetTicketDirectory() {
+std::string GetTicketDirectory()
+{
     return fmt::format("{}/dbs/ticket.db/", FileUtil::GetUserPath(FileUtil::UserPath::NANDDir));
 }

-std::string GetTicketPath(u64 title_id, u64 ticket_id) {
+std::string GetTicketPath(u64 title_id, u64 ticket_id)
+{
     return GetTicketDirectory() + fmt::format("{:016X}.{:016X}.tik", title_id, ticket_id);
 }

-std::string GetTitleMetadataPath(Service::FS::MediaType media_type, u64 tid, bool update) {
+std::string GetTitleMetadataPath(Service::FS::MediaType media_type, u64 tid, bool update)
+{
     std::string content_path = GetTitlePath(media_type, tid) + "content/";

     if (media_type == Service::FS::MediaType::GameCard) {
@@ -1145,14 +1401,15 @@ std::string GetTitleMetadataPath(Service::FS::MediaType media_type, u64 tid, boo
     return content_path + fmt::format("{:08x}.tmd", (update ? update_id : base_id));
 }

-std::string GetTitleContentPath(Service::FS::MediaType media_type, u64 tid, std::size_t index,
-                                bool update) {
-
+std::string GetTitleContentPath(Service::FS::MediaType media_type,
+                                u64 tid,
+                                std::size_t index,
+                                bool update)
+{
     if (media_type == Service::FS::MediaType::GameCard) {
         // TODO(B3N30): check if TID matches
-        auto fs_user =
-            Core::System::GetInstance().ServiceManager().GetService<Service::FS::FS_USER>(
-                "fs:USER");
+        auto fs_user = Core::System::GetInstance().ServiceManager().GetService<Service::FS::FS_USER>(
+            "fs:USER");
         return fs_user->GetCurrentGamecardPath();
     }

@@ -1166,7 +1423,8 @@ std::string GetTitleContentPath(Service::FS::MediaType media_type, u64 tid, std:
         if (index < tmd.GetContentCount()) {
             content_id = tmd.GetContentIDByIndex(index);
         } else {
-            LOG_ERROR(Service_AM, "Attempted to get path for non-existent content index {:04x}.",
+            LOG_ERROR(Service_AM,
+                      "Attempted to get path for non-existent content index {:04x}.",
                       index);
             return "";
         }
@@ -1175,8 +1433,8 @@ std::string GetTitleContentPath(Service::FS::MediaType media_type, u64 tid, std:
         // For now, check if the second (index 1) content has the optional flag set, for most
         // apps this is usually the manual and not set optional, DLC has it set optional.
         // All .apps (including index 0) will be in the 00000000/ folder for DLC.
-        if (tmd.GetContentCount() > 1 &&
-            tmd.GetContentTypeByIndex(1) & FileSys::TMDContentTypeFlag::Optional) {
+        if (tmd.GetContentCount() > 1
+            && tmd.GetContentTypeByIndex(1) & FileSys::TMDContentTypeFlag::Optional) {
             content_path += "00000000/";
         }
     }
@@ -1184,7 +1442,8 @@ std::string GetTitleContentPath(Service::FS::MediaType media_type, u64 tid, std:
     return fmt::format("{}{:08x}.app", content_path, content_id);
 }

-std::string GetTitlePath(Service::FS::MediaType media_type, u64 tid) {
+std::string GetTitlePath(Service::FS::MediaType media_type, u64 tid)
+{
     // TODO(PabloMK7) TWL titles should be in TWL Nand. Assuming CTR Nand for now.

     u32 high = static_cast<u32>(tid >> 32);
@@ -1195,37 +1454,39 @@ std::string GetTitlePath(Service::FS::MediaType media_type, u64 tid) {

     if (media_type == Service::FS::MediaType::GameCard) {
         // TODO(B3N30): check if TID matches
-        auto fs_user =
-            Core::System::GetInstance().ServiceManager().GetService<Service::FS::FS_USER>(
-                "fs:USER");
+        auto fs_user = Core::System::GetInstance().ServiceManager().GetService<Service::FS::FS_USER>(
+            "fs:USER");
         return fs_user->GetCurrentGamecardPath();
     }

     return "";
 }

-std::string GetMediaTitlePath(Service::FS::MediaType media_type) {
+std::string GetMediaTitlePath(Service::FS::MediaType media_type)
+{
     if (media_type == Service::FS::MediaType::NAND)
-        return fmt::format("{}{}/title/", FileUtil::GetUserPath(FileUtil::UserPath::NANDDir),
+        return fmt::format("{}{}/title/",
+                           FileUtil::GetUserPath(FileUtil::UserPath::NANDDir),
                            SYSTEM_ID);

     if (media_type == Service::FS::MediaType::SDMC)
         return fmt::format("{}Nintendo 3DS/{}/{}/title/",
-                           FileUtil::GetUserPath(FileUtil::UserPath::SDMCDir), SYSTEM_ID,
+                           FileUtil::GetUserPath(FileUtil::UserPath::SDMCDir),
+                           SYSTEM_ID,
                            SDCARD_ID);

     if (media_type == Service::FS::MediaType::GameCard) {
         // TODO(B3N30): check if TID matchess
-        auto fs_user =
-            Core::System::GetInstance().ServiceManager().GetService<Service::FS::FS_USER>(
-                "fs:USER");
+        auto fs_user = Core::System::GetInstance().ServiceManager().GetService<Service::FS::FS_USER>(
+            "fs:USER");
         return fs_user->GetCurrentGamecardPath();
     }

     return "";
 }

-void Module::ScanForTickets() {
+void Module::ScanForTickets()
+{
     if (Settings::values.deterministic_async_operations) {
         ScanForTicketsImpl();
     } else {
@@ -1236,7 +1497,8 @@ void Module::ScanForTickets() {
     }
 }

-void Module::ScanForTicketsImpl() {
+void Module::ScanForTicketsImpl()
+{
     am_ticket_list.clear();

     LOG_DEBUG(Service_AM, "Starting ticket scan");
@@ -1266,7 +1528,8 @@ void Module::ScanForTicketsImpl() {
     LOG_DEBUG(Service_AM, "Finished ticket scan");
 }

-void Module::ScanForTitles(Service::FS::MediaType media_type) {
+void Module::ScanForTitles(Service::FS::MediaType media_type)
+{
     if (Settings::values.deterministic_async_operations) {
         ScanForTitlesImpl(media_type);
     } else {
@@ -1277,7 +1540,8 @@ void Module::ScanForTitles(Service::FS::MediaType media_type) {
     }
 }

-void Module::ScanForTitlesImpl(Service::FS::MediaType media_type) {
+void Module::ScanForTitlesImpl(Service::FS::MediaType media_type)
+{
     am_title_list[static_cast<u32>(media_type)].clear();

     LOG_DEBUG(Service_AM, "Starting title scan for media_type={}", static_cast<int>(media_type));
@@ -1318,7 +1582,8 @@ void Module::ScanForTitlesImpl(Service::FS::MediaType media_type) {
     LOG_DEBUG(Service_AM, "Finished title scan for media_type={}", static_cast<int>(media_type));
 }

-void Module::ScanForAllTitles() {
+void Module::ScanForAllTitles()
+{
     if (Settings::values.deterministic_async_operations) {
         ScanForTicketsImpl();
         ScanForTitlesImpl(Service::FS::MediaType::NAND);
@@ -1338,18 +1603,22 @@ void Module::ScanForAllTitles() {
 }

 Module::Interface::Interface(std::shared_ptr<Module> am, const char* name, u32 max_session)
-    : ServiceFramework(name, max_session), am(std::move(am)) {}
+    : ServiceFramework(name, max_session)
+    , am(std::move(am))
+{}

 Module::Interface::~Interface() = default;

-void Module::Interface::GetNumPrograms(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetNumPrograms(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     u8 media_type = rp.Pop<u8>();

     LOG_DEBUG(Service_AM, "media_type={}", media_type);

     if (artic_client.get()) {
-        struct AsyncData {
+        struct AsyncData
+        {
             u8 media_type;

             ResultVal<s32> res;
@@ -1401,8 +1670,8 @@ void Module::Interface::GetNumPrograms(Kernel::HLERequestContext& ctx) {
     }
 }

-void Module::Interface::FindDLCContentInfos(Kernel::HLERequestContext& ctx) {
-
+void Module::Interface::FindDLCContentInfos(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     auto media_type = static_cast<Service::FS::MediaType>(rp.Pop<u8>());
     u64 title_id = rp.Pop<u64>();
@@ -1412,7 +1681,8 @@ void Module::Interface::FindDLCContentInfos(Kernel::HLERequestContext& ctx) {
     LOG_DEBUG(Service_AM, "title_id={:016X}", title_id);

     if (artic_client.get()) {
-        struct AsyncData {
+        struct AsyncData
+        {
             u8 media_type;
             u64 title_id;
             std::vector<u16> content_requested;
@@ -1425,7 +1695,8 @@ void Module::Interface::FindDLCContentInfos(Kernel::HLERequestContext& ctx) {
         async_data->media_type = static_cast<u8>(media_type);
         async_data->title_id = title_id;
         async_data->content_requested.resize(content_count);
-        content_requested_in.Read(async_data->content_requested.data(), 0,
+        content_requested_in.Read(async_data->content_requested.data(),
+                                  0,
                                   content_count * sizeof(u16));
         async_data->content_info_out = &rp.PopMappedBuffer();

@@ -1463,7 +1734,8 @@ void Module::Interface::FindDLCContentInfos(Kernel::HLERequestContext& ctx) {
             },
             [async_data](Kernel::HLERequestContext& ctx) {
                 if (async_data->res.IsSuccess()) {
-                    async_data->content_info_out->Write(async_data->out.data(), 0,
+                    async_data->content_info_out->Write(async_data->out.data(),
+                                                        0,
                                                         async_data->out.size());
                 }
                 IPC::RequestBuilder rb(ctx, 1, 0);
@@ -1471,8 +1743,8 @@ void Module::Interface::FindDLCContentInfos(Kernel::HLERequestContext& ctx) {
             },
             true);
     } else {
-
-        struct AsyncData {
+        struct AsyncData
+        {
             Service::FS::MediaType media_type;
             u64 title_id;
             std::vector<u16> content_requested;
@@ -1485,7 +1757,8 @@ void Module::Interface::FindDLCContentInfos(Kernel::HLERequestContext& ctx) {
         async_data->media_type = media_type;
         async_data->title_id = title_id;
         async_data->content_requested.resize(content_count);
-        content_requested_in.Read(async_data->content_requested.data(), 0,
+        content_requested_in.Read(async_data->content_requested.data(),
+                                  0,
                                   content_count * sizeof(u16));
         async_data->content_info_out = &rp.PopMappedBuffer();

@@ -1494,13 +1767,15 @@ void Module::Interface::FindDLCContentInfos(Kernel::HLERequestContext& ctx) {
                 // Validate that only DLC TIDs are passed in
                 u32 tid_high = static_cast<u32>(async_data->title_id >> 32);
                 if (tid_high != TID_HIGH_DLC) {
-                    async_data->res = Result(ErrCodes::InvalidTIDInList, ErrorModule::AM,
-                                             ErrorSummary::InvalidArgument, ErrorLevel::Usage);
+                    async_data->res = Result(ErrCodes::InvalidTIDInList,
+                                             ErrorModule::AM,
+                                             ErrorSummary::InvalidArgument,
+                                             ErrorLevel::Usage);
                     return 0;
                 }

-                std::string tmd_path =
-                    GetTitleMetadataPath(async_data->media_type, async_data->title_id);
+                std::string tmd_path = GetTitleMetadataPath(async_data->media_type,
+                                                            async_data->title_id);

                 // In normal circumstances, if there is no ticket we shouldn't be able to have
                 // any contents either. However to keep compatibility with older emulator builds,
@@ -1509,9 +1784,9 @@ void Module::Interface::FindDLCContentInfos(Kernel::HLERequestContext& ctx) {
                 FileSys::Ticket ticket;
                 std::scoped_lock lock(am->am_lists_mutex);
                 auto entries = am->am_ticket_list.find(async_data->title_id);
-                if (entries != am->am_ticket_list.end() &&
-                    ticket.Load(async_data->title_id, (*entries).second) ==
-                        Loader::ResultStatus::Success) {
+                if (entries != am->am_ticket_list.end()
+                    && ticket.Load(async_data->title_id, (*entries).second)
+                           == Loader::ResultStatus::Success) {
                     has_ticket = true;
                 }

@@ -1535,23 +1810,24 @@ void Module::Interface::FindDLCContentInfos(Kernel::HLERequestContext& ctx) {
                         content_info.type = tmd.GetContentTypeByIndex(index);
                         content_info.content_id = tmd.GetContentIDByIndex(index);
                         content_info.size = tmd.GetContentSizeByIndex(index);
-                        content_info.ownership =
-                            (!has_ticket || ticket.HasRights(index)) ? OWNERSHIP_OWNED : 0;
+                        content_info.ownership = (!has_ticket || ticket.HasRights(index))
+                                                     ? OWNERSHIP_OWNED
+                                                     : 0;

                         if (FileUtil::Exists(GetTitleContentPath(async_data->media_type,
-                                                                 async_data->title_id, index))) {
+                                                                 async_data->title_id,
+                                                                 index))) {
                             bool pending = false;
                             for (auto& import_ctx : am->import_content_contexts) {
-                                if (import_ctx.first == async_data->title_id &&
-                                    import_ctx.second.index == index &&
-                                    (import_ctx.second.state ==
-                                         ImportTitleContextState::WAITING_FOR_IMPORT ||
-                                     import_ctx.second.state ==
-                                         ImportTitleContextState::WAITING_FOR_COMMIT ||
-                                     import_ctx.second.state ==
-                                         ImportTitleContextState::RESUMABLE)) {
-                                    LOG_DEBUG(Service_AM, "content pending commit index={:016X}",
-                                              i);
+                                if (import_ctx.first == async_data->title_id
+                                    && import_ctx.second.index == index
+                                    && (import_ctx.second.state
+                                            == ImportTitleContextState::WAITING_FOR_IMPORT
+                                        || import_ctx.second.state
+                                               == ImportTitleContextState::WAITING_FOR_COMMIT
+                                        || import_ctx.second.state
+                                               == ImportTitleContextState::RESUMABLE)) {
+                                    LOG_DEBUG(Service_AM, "content pending commit index={:016X}", i);
                                     pending = true;
                                     break;
                                 }
@@ -1571,16 +1847,18 @@ void Module::Interface::FindDLCContentInfos(Kernel::HLERequestContext& ctx) {
                 IPC::RequestBuilder rb(ctx, 2, 0);
                 rb.Push(async_data->res);
                 if (async_data->res.IsSuccess()) {
-                    async_data->content_info_out->Write(async_data->out_vec.data(), 0,
-                                                        async_data->out_vec.size() *
-                                                            sizeof(ContentInfo));
+                    async_data->content_info_out->Write(async_data->out_vec.data(),
+                                                        0,
+                                                        async_data->out_vec.size()
+                                                            * sizeof(ContentInfo));
                 }
             },
             true);
     }
 }

-void Module::Interface::ListDLCContentInfos(Kernel::HLERequestContext& ctx) {
+void Module::Interface::ListDLCContentInfos(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     u32 content_count = rp.Pop<u32>();
@@ -1591,7 +1869,8 @@ void Module::Interface::ListDLCContentInfos(Kernel::HLERequestContext& ctx) {
     LOG_DEBUG(Service_AM, "title_id={:016X}", title_id);

     if (artic_client.get()) {
-        struct AsyncData {
+        struct AsyncData
+        {
             u8 media_type;
             u64 title_id;
             u32 content_count;
@@ -1642,7 +1921,8 @@ void Module::Interface::ListDLCContentInfos(Kernel::HLERequestContext& ctx) {
             },
             [async_data](Kernel::HLERequestContext& ctx) {
                 if (async_data->res.IsSuccess()) {
-                    async_data->content_info_out->Write(async_data->out.data(), 0,
+                    async_data->content_info_out->Write(async_data->out.data(),
+                                                        0,
                                                         async_data->out.size());
                 }
                 IPC::RequestBuilder rb(ctx, 2, 0);
@@ -1651,8 +1931,8 @@ void Module::Interface::ListDLCContentInfos(Kernel::HLERequestContext& ctx) {
             },
             true);
     } else {
-
-        struct AsyncData {
+        struct AsyncData
+        {
             Service::FS::MediaType media_type;
             u64 title_id;
             u32 content_count;
@@ -1674,13 +1954,15 @@ void Module::Interface::ListDLCContentInfos(Kernel::HLERequestContext& ctx) {
                 // Validate that only DLC TIDs are passed in
                 u32 tid_high = static_cast<u32>(async_data->title_id >> 32);
                 if (tid_high != TID_HIGH_DLC) {
-                    async_data->res = Result(ErrCodes::InvalidTIDInList, ErrorModule::AM,
-                                             ErrorSummary::InvalidArgument, ErrorLevel::Usage);
+                    async_data->res = Result(ErrCodes::InvalidTIDInList,
+                                             ErrorModule::AM,
+                                             ErrorSummary::InvalidArgument,
+                                             ErrorLevel::Usage);
                     return 0;
                 }

-                std::string tmd_path =
-                    GetTitleMetadataPath(async_data->media_type, async_data->title_id);
+                std::string tmd_path = GetTitleMetadataPath(async_data->media_type,
+                                                            async_data->title_id);

                 // In normal circumstances, if there is no ticket we shouldn't be able to have
                 // any contents either. However to keep compatibility with older emulator builds,
@@ -1689,9 +1971,9 @@ void Module::Interface::ListDLCContentInfos(Kernel::HLERequestContext& ctx) {
                 FileSys::Ticket ticket;
                 std::scoped_lock lock(am->am_lists_mutex);
                 auto entries = am->am_ticket_list.find(async_data->title_id);
-                if (entries != am->am_ticket_list.end() &&
-                    ticket.Load(async_data->title_id, (*entries).second) ==
-                        Loader::ResultStatus::Success) {
+                if (entries != am->am_ticket_list.end()
+                    && ticket.Load(async_data->title_id, (*entries).second)
+                           == Loader::ResultStatus::Success) {
                     has_ticket = true;
                 }

@@ -1705,24 +1987,25 @@ void Module::Interface::ListDLCContentInfos(Kernel::HLERequestContext& ctx) {
                         content_info.type = tmd.GetContentTypeByIndex(i);
                         content_info.content_id = tmd.GetContentIDByIndex(i);
                         content_info.size = tmd.GetContentSizeByIndex(i);
-                        content_info.ownership =
-                            (!has_ticket || ticket.HasRights(static_cast<u16>(i))) ? OWNERSHIP_OWNED
-                                                                                   : 0;
+                        content_info.ownership = (!has_ticket
+                                                  || ticket.HasRights(static_cast<u16>(i)))
+                                                     ? OWNERSHIP_OWNED
+                                                     : 0;

                         if (FileUtil::Exists(GetTitleContentPath(async_data->media_type,
-                                                                 async_data->title_id, i))) {
+                                                                 async_data->title_id,
+                                                                 i))) {
                             bool pending = false;
                             for (auto& import_ctx : am->import_content_contexts) {
-                                if (import_ctx.first == async_data->title_id &&
-                                    import_ctx.second.index == i &&
-                                    (import_ctx.second.state ==
-                                         ImportTitleContextState::WAITING_FOR_IMPORT ||
-                                     import_ctx.second.state ==
-                                         ImportTitleContextState::WAITING_FOR_COMMIT ||
-                                     import_ctx.second.state ==
-                                         ImportTitleContextState::RESUMABLE)) {
-                                    LOG_DEBUG(Service_AM, "content pending commit index={:016X}",
-                                              i);
+                                if (import_ctx.first == async_data->title_id
+                                    && import_ctx.second.index == i
+                                    && (import_ctx.second.state
+                                            == ImportTitleContextState::WAITING_FOR_IMPORT
+                                        || import_ctx.second.state
+                                               == ImportTitleContextState::WAITING_FOR_COMMIT
+                                        || import_ctx.second.state
+                                               == ImportTitleContextState::RESUMABLE)) {
+                                    LOG_DEBUG(Service_AM, "content pending commit index={:016X}", i);
                                     pending = true;
                                     break;
                                 }
@@ -1742,16 +2025,18 @@ void Module::Interface::ListDLCContentInfos(Kernel::HLERequestContext& ctx) {
                 rb.Push(async_data->res);
                 rb.Push(static_cast<u32>(async_data->out_vec.size()));
                 if (async_data->res.IsSuccess()) {
-                    async_data->content_info_out->Write(async_data->out_vec.data(), 0,
-                                                        async_data->out_vec.size() *
-                                                            sizeof(ContentInfo));
+                    async_data->content_info_out->Write(async_data->out_vec.data(),
+                                                        0,
+                                                        async_data->out_vec.size()
+                                                            * sizeof(ContentInfo));
                 }
             },
             true);
     }
 }

-void Module::Interface::DeleteContents(Kernel::HLERequestContext& ctx) {
+void Module::Interface::DeleteContents(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     u8 media_type = rp.Pop<u8>();
     u64 title_id = rp.Pop<u64>();
@@ -1761,11 +2046,15 @@ void Module::Interface::DeleteContents(Kernel::HLERequestContext& ctx) {
     IPC::RequestBuilder rb = rp.MakeBuilder(1, 2);
     rb.Push(ResultSuccess);
     rb.PushMappedBuffer(content_ids_in);
-    LOG_WARNING(Service_AM, "(STUBBED) media_type={}, title_id=0x{:016x}, content_count={}",
-                media_type, title_id, content_count);
+    LOG_WARNING(Service_AM,
+                "(STUBBED) media_type={}, title_id=0x{:016x}, content_count={}",
+                media_type,
+                title_id,
+                content_count);
 }

-void Module::Interface::GetProgramList(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetProgramList(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     u32 count = rp.Pop<u32>();
     u8 media_type = rp.Pop<u8>();
@@ -1773,7 +2062,8 @@ void Module::Interface::GetProgramList(Kernel::HLERequestContext& ctx) {
     LOG_DEBUG(Service_AM, "media_type={}", media_type);

     if (artic_client.get()) {
-        struct AsyncData {
+        struct AsyncData
+        {
             u32 count;
             u8 media_type;

@@ -1823,7 +2113,8 @@ void Module::Interface::GetProgramList(Kernel::HLERequestContext& ctx) {
                     rb.Push(async_data->res);
                     rb.Push<u32>(0);
                 } else {
-                    async_data->title_ids_output->Write(async_data->out.data(), 0,
+                    async_data->title_ids_output->Write(async_data->out.data(),
+                                                        0,
                                                         async_data->out.size());

                     IPC::RequestBuilder rb(ctx, 2, 0);
@@ -1855,8 +2146,10 @@ void Module::Interface::GetProgramList(Kernel::HLERequestContext& ctx) {
     }
 }

-Result GetTitleInfoFromList(std::span<const u64> title_id_list, Service::FS::MediaType media_type,
-                            std::vector<TitleInfo>& title_info_out) {
+Result GetTitleInfoFromList(std::span<const u64> title_id_list,
+                            Service::FS::MediaType media_type,
+                            std::vector<TitleInfo>& title_info_out)
+{
     title_info_out.reserve(title_id_list.size());
     for (u32 i = 0; i < title_id_list.size(); i++) {
         std::string tmd_path = GetTitleMetadataPath(media_type, title_id_list[i]);
@@ -1873,10 +2166,14 @@ Result GetTitleInfoFromList(std::span<const u64> title_id_list, Service::FS::Med
             title_info.type = tmd.GetTitleType();
         } else {
             LOG_DEBUG(Service_AM, "not found title_id={:016X}", title_id_list[i]);
-            return Result(ErrorDescription::NotFound, ErrorModule::AM, ErrorSummary::InvalidState,
+            return Result(ErrorDescription::NotFound,
+                          ErrorModule::AM,
+                          ErrorSummary::InvalidState,
                           ErrorLevel::Permanent);
         }
-        LOG_DEBUG(Service_AM, "found title_id={:016X} version={:04X}", title_id_list[i],
+        LOG_DEBUG(Service_AM,
+                  "found title_id={:016X} version={:04X}",
+                  title_id_list[i],
                   title_info.version);
         title_info_out.push_back(title_info);
     }
@@ -1884,7 +2181,8 @@ Result GetTitleInfoFromList(std::span<const u64> title_id_list, Service::FS::Med
     return ResultSuccess;
 }

-void Module::Interface::GetProgramInfosImpl(Kernel::HLERequestContext& ctx, bool ignore_platform) {
+void Module::Interface::GetProgramInfosImpl(Kernel::HLERequestContext& ctx, bool ignore_platform)
+{
     IPC::RequestParser rp(ctx);

     auto media_type = static_cast<Service::FS::MediaType>(rp.Pop<u8>());
@@ -1893,7 +2191,8 @@ void Module::Interface::GetProgramInfosImpl(Kernel::HLERequestContext& ctx, bool
     LOG_DEBUG(Service_AM, "media_type={}, ignore_platform={}", media_type, ignore_platform);

     if (artic_client.get()) {
-        struct AsyncData {
+        struct AsyncData
+        {
             u8 media_type;
             bool ignore_platform;
             std::vector<u64> title_id_list;
@@ -1908,7 +2207,8 @@ void Module::Interface::GetProgramInfosImpl(Kernel::HLERequestContext& ctx, bool
         async_data->ignore_platform = ignore_platform;
         async_data->title_id_list.resize(title_count);
         async_data->title_id_list_buffer = &rp.PopMappedBuffer();
-        async_data->title_id_list_buffer->Read(async_data->title_id_list.data(), 0,
+        async_data->title_id_list_buffer->Read(async_data->title_id_list.data(),
+                                               0,
                                                title_count * sizeof(u64));
         async_data->title_info_out = &rp.PopMappedBuffer();

@@ -1954,7 +2254,8 @@ void Module::Interface::GetProgramInfosImpl(Kernel::HLERequestContext& ctx, bool
                         rb.PushMappedBuffer(*async_data->title_info_out);
                     }
                 } else {
-                    async_data->title_info_out->Write(async_data->out.data(), 0,
+                    async_data->title_info_out->Write(async_data->out.data(),
+                                                      0,
                                                       async_data->out.size() / sizeof(TitleInfo));

                     IPC::RequestBuilder rb(ctx, 1, async_data->ignore_platform ? 0 : 4);
@@ -1968,7 +2269,8 @@ void Module::Interface::GetProgramInfosImpl(Kernel::HLERequestContext& ctx, bool
             true);

     } else {
-        struct AsyncData {
+        struct AsyncData
+        {
             Service::FS::MediaType media_type;
             std::vector<u64> title_id_list;

@@ -1981,43 +2283,47 @@ void Module::Interface::GetProgramInfosImpl(Kernel::HLERequestContext& ctx, bool
         async_data->media_type = media_type;
         async_data->title_id_list.resize(title_count);
         async_data->title_id_list_buffer = &rp.PopMappedBuffer();
-        async_data->title_id_list_buffer->Read(async_data->title_id_list.data(), 0,
+        async_data->title_id_list_buffer->Read(async_data->title_id_list.data(),
+                                               0,
                                                title_count * sizeof(u64));
         async_data->title_info_out = &rp.PopMappedBuffer();
-
-        ctx.RunAsync(
-            [this, async_data](Kernel::HLERequestContext& ctx) {
-                // nim checks if the current importing title already exists during installation.
-                // Normally, since the program wouldn't be commited, getting the title info returns
-                // not found. However, since GetTitleInfoFromList does not care if the program was
-                // commited and only checks for the tmd, it will detect the title and return
-                // information while it shouldn't. To prevent this, we check if the importing
-                // context is present and not committed. If that's the case, return not found
-                for (auto tid : async_data->title_id_list) {
-                    for (auto& import_ctx : am->import_title_contexts) {
-                        if (import_ctx.first == tid &&
-                            (import_ctx.second.state ==
-                                 ImportTitleContextState::WAITING_FOR_IMPORT ||
-                             import_ctx.second.state ==
-                                 ImportTitleContextState::WAITING_FOR_COMMIT ||
-                             import_ctx.second.state == ImportTitleContextState::RESUMABLE)) {
-                            LOG_DEBUG(Service_AM, "title pending commit title_id={:016X}", tid);
-                            async_data->res =
-                                Result(ErrorDescription::NotFound, ErrorModule::AM,
-                                       ErrorSummary::InvalidState, ErrorLevel::Permanent);
-                        }
-                    }
+#ifdef todotodo
+        // nim checks if the current importing title already exists during installation.
+        // Normally, since the program wouldn't be commited, getting the title info returns not
+        // found. However, since GetTitleInfoFromList does not care if the program was commited and
+        // only checks for the tmd, it will detect the title and return information while it
+        // shouldn't. To prevent this, we check if the importing context is present and not
+        // committed. If that's the case, return not found
+        Result result = ResultSuccess;
+        for (auto tid : title_id_list) {
+            for (auto& import_ctx : am->import_title_contexts) {
+                if (import_ctx.first == tid
+                    && (import_ctx.second.state == ImportTitleContextState::WAITING_FOR_IMPORT
+                        || import_ctx.second.state == ImportTitleContextState::WAITING_FOR_COMMIT
+                        || import_ctx.second.state == ImportTitleContextState::RESUMABLE)) {
+                    LOG_DEBUG(Service_AM, "title pending commit title_id={:016X}", tid);
+                    result = Result(ErrorDescription::NotFound,
+                                    ErrorModule::AM,
+                                    ErrorSummary::InvalidState,
+                                    ErrorLevel::Permanent);
                 }
+            }
+        }

-                if (async_data->res.IsSuccess()) {
-                    async_data->res = GetTitleInfoFromList(async_data->title_id_list,
-                                                           async_data->media_type, async_data->out);
-                }
+        if (result.IsSuccess())
+            result = GetTitleInfoFromList(title_id_list, media_type, title_info_out);
+#else
+        ctx.RunAsync(
+            [async_data](Kernel::HLERequestContext& ctx) {
+                async_data->res = GetTitleInfoFromList(async_data->title_id_list,
+                                                       async_data->media_type,
+                                                       async_data->out);
                 return 0;
             },
             [async_data](Kernel::HLERequestContext& ctx) {
                 if (async_data->res.IsSuccess()) {
-                    async_data->title_info_out->Write(async_data->out.data(), 0,
+                    async_data->title_info_out->Write(async_data->out.data(),
+                                                      0,
                                                       async_data->out.size() * sizeof(TitleInfo));
                 }
                 IPC::RequestBuilder rb(ctx, 1, 4);
@@ -2026,18 +2332,22 @@ void Module::Interface::GetProgramInfosImpl(Kernel::HLERequestContext& ctx, bool
                 rb.PushMappedBuffer(*async_data->title_info_out);
             },
             true);
+#endif
     }
 }

-void Module::Interface::GetProgramInfos(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetProgramInfos(Kernel::HLERequestContext& ctx)
+{
     GetProgramInfosImpl(ctx, false);
 }

-void Module::Interface::GetProgramInfosIgnorePlatform(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetProgramInfosIgnorePlatform(Kernel::HLERequestContext& ctx)
+{
     GetProgramInfosImpl(ctx, true);
 }

-void Module::Interface::DeleteUserProgram(Kernel::HLERequestContext& ctx) {
+void Module::Interface::DeleteUserProgram(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     auto media_type = rp.PopEnum<FS::MediaType>();
     u64 title_id = rp.Pop<u64>();
@@ -2049,14 +2359,18 @@ void Module::Interface::DeleteUserProgram(Kernel::HLERequestContext& ctx) {
     u8 variation = static_cast<u8>(title_id & 0xFF);
     if (category & CATEGORY_SYSTEM || category & CATEGORY_DLP || variation & VARIATION_SYSTEM) {
         LOG_ERROR(Service_AM, "Trying to uninstall system app");
-        rb.Push(Result(ErrCodes::TryingToUninstallSystemApp, ErrorModule::AM,
-                       ErrorSummary::InvalidArgument, ErrorLevel::Usage));
+        rb.Push(Result(ErrCodes::TryingToUninstallSystemApp,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidArgument,
+                       ErrorLevel::Usage));
         return;
     }
     LOG_INFO(Service_AM, "Deleting title 0x{:016x}", title_id);
     std::string path = GetTitlePath(media_type, title_id);
     if (!FileUtil::Exists(path)) {
-        rb.Push(Result(ErrorDescription::NotFound, ErrorModule::AM, ErrorSummary::InvalidState,
+        rb.Push(Result(ErrorDescription::NotFound,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
                        ErrorLevel::Permanent));
         LOG_ERROR(Service_AM, "Title not found");
         return;
@@ -2068,7 +2382,8 @@ void Module::Interface::DeleteUserProgram(Kernel::HLERequestContext& ctx) {
         LOG_ERROR(Service_AM, "FileUtil::DeleteDirRecursively unexpectedly failed");
 }

-void Module::Interface::GetProductCode(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetProductCode(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     FS::MediaType media_type = rp.PopEnum<FS::MediaType>();
     u64 title_id = rp.Pop<u64>();
@@ -2078,10 +2393,13 @@ void Module::Interface::GetProductCode(Kernel::HLERequestContext& ctx) {

     if (!FileUtil::Exists(path)) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrorDescription::NotFound, ErrorModule::AM, ErrorSummary::InvalidState,
+        rb.Push(Result(ErrorDescription::NotFound,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
                        ErrorLevel::Permanent));
     } else {
-        struct ProductCode {
+        struct ProductCode
+        {
             u8 code[0x10];
         };

@@ -2096,7 +2414,8 @@ void Module::Interface::GetProductCode(Kernel::HLERequestContext& ctx) {
     }
 }

-void Module::Interface::GetDLCTitleInfos(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetDLCTitleInfos(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     auto media_type = static_cast<Service::FS::MediaType>(rp.Pop<u8>());
@@ -2105,7 +2424,8 @@ void Module::Interface::GetDLCTitleInfos(Kernel::HLERequestContext& ctx) {
     LOG_DEBUG(Service_AM, "media_type={}", media_type);

     if (artic_client.get()) {
-        struct AsyncData {
+        struct AsyncData
+        {
             u8 media_type;
             std::vector<u64> title_id_list;

@@ -2118,7 +2438,8 @@ void Module::Interface::GetDLCTitleInfos(Kernel::HLERequestContext& ctx) {
         async_data->media_type = static_cast<u8>(media_type);
         async_data->title_id_list.resize(title_count);
         async_data->title_id_list_buffer = &rp.PopMappedBuffer();
-        async_data->title_id_list_buffer->Read(async_data->title_id_list.data(), 0,
+        async_data->title_id_list_buffer->Read(async_data->title_id_list.data(),
+                                               0,
                                                title_count * sizeof(u64));
         async_data->title_info_out = &rp.PopMappedBuffer();

@@ -2161,7 +2482,8 @@ void Module::Interface::GetDLCTitleInfos(Kernel::HLERequestContext& ctx) {
                     rb.PushMappedBuffer(*async_data->title_id_list_buffer);
                     rb.PushMappedBuffer(*async_data->title_info_out);
                 } else {
-                    async_data->title_info_out->Write(async_data->out.data(), 0,
+                    async_data->title_info_out->Write(async_data->out.data(),
+                                                      0,
                                                       async_data->out.size());

                     IPC::RequestBuilder rb(ctx, 1, 4);
@@ -2172,7 +2494,8 @@ void Module::Interface::GetDLCTitleInfos(Kernel::HLERequestContext& ctx) {
             },
             true);
     } else {
-        struct AsyncData {
+        struct AsyncData
+        {
             Service::FS::MediaType media_type;
             std::vector<u64> title_id_list;

@@ -2185,7 +2508,8 @@ void Module::Interface::GetDLCTitleInfos(Kernel::HLERequestContext& ctx) {
         async_data->media_type = media_type;
         async_data->title_id_list.resize(title_count);
         async_data->title_id_list_buffer = &rp.PopMappedBuffer();
-        async_data->title_id_list_buffer->Read(async_data->title_id_list.data(), 0,
+        async_data->title_id_list_buffer->Read(async_data->title_id_list.data(),
+                                               0,
                                                title_count * sizeof(u64));
         async_data->title_info_out = &rp.PopMappedBuffer();

@@ -2195,8 +2519,10 @@ void Module::Interface::GetDLCTitleInfos(Kernel::HLERequestContext& ctx) {
                 for (u32 i = 0; i < async_data->title_id_list.size(); i++) {
                     u32 tid_high = static_cast<u32>(async_data->title_id_list[i] >> 32);
                     if (tid_high != TID_HIGH_DLC) {
-                        async_data->res = Result(ErrCodes::InvalidTIDInList, ErrorModule::AM,
-                                                 ErrorSummary::InvalidArgument, ErrorLevel::Usage);
+                        async_data->res = Result(ErrCodes::InvalidTIDInList,
+                                                 ErrorModule::AM,
+                                                 ErrorSummary::InvalidArgument,
+                                                 ErrorLevel::Usage);
                         break;
                     }
                 }
@@ -2209,29 +2535,32 @@ void Module::Interface::GetDLCTitleInfos(Kernel::HLERequestContext& ctx) {
                 // context is present and not committed. If that's the case, return not found
                 for (auto tid : async_data->title_id_list) {
                     for (auto& import_ctx : am->import_title_contexts) {
-                        if (import_ctx.first == tid &&
-                            (import_ctx.second.state ==
-                                 ImportTitleContextState::WAITING_FOR_IMPORT ||
-                             import_ctx.second.state ==
-                                 ImportTitleContextState::WAITING_FOR_COMMIT ||
-                             import_ctx.second.state == ImportTitleContextState::RESUMABLE)) {
+                        if (import_ctx.first == tid
+                            && (import_ctx.second.state
+                                    == ImportTitleContextState::WAITING_FOR_IMPORT
+                                || import_ctx.second.state
+                                       == ImportTitleContextState::WAITING_FOR_COMMIT
+                                || import_ctx.second.state == ImportTitleContextState::RESUMABLE)) {
                             LOG_DEBUG(Service_AM, "title pending commit title_id={:016X}", tid);
-                            async_data->res =
-                                Result(ErrorDescription::NotFound, ErrorModule::AM,
-                                       ErrorSummary::InvalidState, ErrorLevel::Permanent);
+                            async_data->res = Result(ErrorDescription::NotFound,
+                                                     ErrorModule::AM,
+                                                     ErrorSummary::InvalidState,
+                                                     ErrorLevel::Permanent);
                         }
                     }
                 }

                 if (async_data->res.IsSuccess()) {
                     async_data->res = GetTitleInfoFromList(async_data->title_id_list,
-                                                           async_data->media_type, async_data->out);
+                                                           async_data->media_type,
+                                                           async_data->out);
                 }
                 return 0;
             },
             [async_data](Kernel::HLERequestContext& ctx) {
                 if (async_data->res.IsSuccess()) {
-                    async_data->title_info_out->Write(async_data->out.data(), 0,
+                    async_data->title_info_out->Write(async_data->out.data(),
+                                                      0,
                                                       async_data->out.size() * sizeof(TitleInfo));
                 }
                 IPC::RequestBuilder rb(ctx, 1, 4);
@@ -2243,7 +2572,8 @@ void Module::Interface::GetDLCTitleInfos(Kernel::HLERequestContext& ctx) {
     }
 }

-void Module::Interface::GetPatchTitleInfos(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetPatchTitleInfos(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     auto media_type = static_cast<Service::FS::MediaType>(rp.Pop<u8>());
@@ -2252,7 +2582,8 @@ void Module::Interface::GetPatchTitleInfos(Kernel::HLERequestContext& ctx) {
     LOG_DEBUG(Service_AM, "media_type={}", media_type);

     if (artic_client.get()) {
-        struct AsyncData {
+        struct AsyncData
+        {
             u8 media_type;
             std::vector<u64> title_id_list;

@@ -2265,7 +2596,8 @@ void Module::Interface::GetPatchTitleInfos(Kernel::HLERequestContext& ctx) {
         async_data->media_type = static_cast<u8>(media_type);
         async_data->title_id_list.resize(title_count);
         async_data->title_id_list_buffer = &rp.PopMappedBuffer();
-        async_data->title_id_list_buffer->Read(async_data->title_id_list.data(), 0,
+        async_data->title_id_list_buffer->Read(async_data->title_id_list.data(),
+                                               0,
                                                title_count * sizeof(u64));
         async_data->title_info_out = &rp.PopMappedBuffer();

@@ -2308,7 +2640,8 @@ void Module::Interface::GetPatchTitleInfos(Kernel::HLERequestContext& ctx) {
                     rb.PushMappedBuffer(*async_data->title_id_list_buffer);
                     rb.PushMappedBuffer(*async_data->title_info_out);
                 } else {
-                    async_data->title_info_out->Write(async_data->out.data(), 0,
+                    async_data->title_info_out->Write(async_data->out.data(),
+                                                      0,
                                                       async_data->out.size() * sizeof(TitleInfo));

                     IPC::RequestBuilder rb(ctx, 1, 4);
@@ -2319,7 +2652,8 @@ void Module::Interface::GetPatchTitleInfos(Kernel::HLERequestContext& ctx) {
             },
             true);
     } else {
-        struct AsyncData {
+        struct AsyncData
+        {
             Service::FS::MediaType media_type;
             std::vector<u64> title_id_list;

@@ -2332,7 +2666,8 @@ void Module::Interface::GetPatchTitleInfos(Kernel::HLERequestContext& ctx) {
         async_data->media_type = media_type;
         async_data->title_id_list.resize(title_count);
         async_data->title_id_list_buffer = &rp.PopMappedBuffer();
-        async_data->title_id_list_buffer->Read(async_data->title_id_list.data(), 0,
+        async_data->title_id_list_buffer->Read(async_data->title_id_list.data(),
+                                               0,
                                                title_count * sizeof(u64));
         async_data->title_info_out = &rp.PopMappedBuffer();

@@ -2342,8 +2677,10 @@ void Module::Interface::GetPatchTitleInfos(Kernel::HLERequestContext& ctx) {
                 for (u32 i = 0; i < async_data->title_id_list.size(); i++) {
                     u32 tid_high = static_cast<u32>(async_data->title_id_list[i] >> 32);
                     if (tid_high != TID_HIGH_UPDATE) {
-                        async_data->res = Result(ErrCodes::InvalidTIDInList, ErrorModule::AM,
-                                                 ErrorSummary::InvalidArgument, ErrorLevel::Usage);
+                        async_data->res = Result(ErrCodes::InvalidTIDInList,
+                                                 ErrorModule::AM,
+                                                 ErrorSummary::InvalidArgument,
+                                                 ErrorLevel::Usage);
                         break;
                     }
                 }
@@ -2356,29 +2693,32 @@ void Module::Interface::GetPatchTitleInfos(Kernel::HLERequestContext& ctx) {
                 // context is present and not committed. If that's the case, return not found
                 for (auto tid : async_data->title_id_list) {
                     for (auto& import_ctx : am->import_title_contexts) {
-                        if (import_ctx.first == tid &&
-                            (import_ctx.second.state ==
-                                 ImportTitleContextState::WAITING_FOR_IMPORT ||
-                             import_ctx.second.state ==
-                                 ImportTitleContextState::WAITING_FOR_COMMIT ||
-                             import_ctx.second.state == ImportTitleContextState::RESUMABLE)) {
+                        if (import_ctx.first == tid
+                            && (import_ctx.second.state
+                                    == ImportTitleContextState::WAITING_FOR_IMPORT
+                                || import_ctx.second.state
+                                       == ImportTitleContextState::WAITING_FOR_COMMIT
+                                || import_ctx.second.state == ImportTitleContextState::RESUMABLE)) {
                             LOG_DEBUG(Service_AM, "title pending commit title_id={:016X}", tid);
-                            async_data->res =
-                                Result(ErrorDescription::NotFound, ErrorModule::AM,
-                                       ErrorSummary::InvalidState, ErrorLevel::Permanent);
+                            async_data->res = Result(ErrorDescription::NotFound,
+                                                     ErrorModule::AM,
+                                                     ErrorSummary::InvalidState,
+                                                     ErrorLevel::Permanent);
                         }
                     }
                 }

                 if (async_data->res.IsSuccess()) {
                     async_data->res = GetTitleInfoFromList(async_data->title_id_list,
-                                                           async_data->media_type, async_data->out);
+                                                           async_data->media_type,
+                                                           async_data->out);
                 }
                 return 0;
             },
             [async_data](Kernel::HLERequestContext& ctx) {
                 if (async_data->res.IsSuccess()) {
-                    async_data->title_info_out->Write(async_data->out.data(), 0,
+                    async_data->title_info_out->Write(async_data->out.data(),
+                                                      0,
                                                       async_data->out.size() * sizeof(TitleInfo));
                 }
                 IPC::RequestBuilder rb(ctx, 1, 4);
@@ -2390,14 +2730,16 @@ void Module::Interface::GetPatchTitleInfos(Kernel::HLERequestContext& ctx) {
     }
 }

-void Module::Interface::ListDataTitleTicketInfos(Kernel::HLERequestContext& ctx) {
+void Module::Interface::ListDataTitleTicketInfos(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     u32 ticket_count = rp.Pop<u32>();
     u64 title_id = rp.Pop<u64>();
     u32 start_index = rp.Pop<u32>();

     if (artic_client.get()) {
-        struct AsyncData {
+        struct AsyncData
+        {
             u64 title_id;
             u32 ticket_count;
             u32 start_index;
@@ -2445,7 +2787,8 @@ void Module::Interface::ListDataTitleTicketInfos(Kernel::HLERequestContext& ctx)
             },
             [async_data](Kernel::HLERequestContext& ctx) {
                 if (async_data->res.IsSuccess()) {
-                    async_data->ticket_info_out->Write(async_data->out.data(), 0,
+                    async_data->ticket_info_out->Write(async_data->out.data(),
+                                                       0,
                                                        async_data->out.size());
                 }
                 IPC::RequestBuilder rb(ctx, 2, 0);
@@ -2458,7 +2801,8 @@ void Module::Interface::ListDataTitleTicketInfos(Kernel::HLERequestContext& ctx)

         u32 tid_high = static_cast<u32>(title_id >> 32);
         if (tid_high != 0x0004008C && tid_high != 0x0004000D) {
-            LOG_ERROR(Service_AM, "Tried to get infos for non-data title title_id={:016X}",
+            LOG_ERROR(Service_AM,
+                      "Tried to get infos for non-data title title_id={:016X}",
                       title_id);
             IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
             rb.Push(Result(60, ErrorModule::AM, ErrorSummary::InvalidArgument, ErrorLevel::Usage));
@@ -2469,8 +2813,9 @@ void Module::Interface::ListDataTitleTicketInfos(Kernel::HLERequestContext& ctx)
         std::scoped_lock lock(am->am_lists_mutex);
         auto range = am->am_ticket_list.equal_range(title_id);
         auto it = range.first;
-        std::advance(it, std::min(static_cast<size_t>(start_index),
-                                  static_cast<size_t>(std::distance(range.first, range.second))));
+        std::advance(it,
+                     std::min(static_cast<size_t>(start_index),
+                              static_cast<size_t>(std::distance(range.first, range.second))));

         u32 written = 0;
         for (; it != range.second && written < ticket_count; it++) {
@@ -2494,7 +2839,8 @@ void Module::Interface::ListDataTitleTicketInfos(Kernel::HLERequestContext& ctx)
     }
 }

-void Module::Interface::GetDLCContentInfoCount(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetDLCContentInfoCount(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     auto media_type = static_cast<Service::FS::MediaType>(rp.Pop<u8>());
     u64 title_id = rp.Pop<u64>();
@@ -2502,7 +2848,8 @@ void Module::Interface::GetDLCContentInfoCount(Kernel::HLERequestContext& ctx) {
     LOG_DEBUG(Service_AM, "title_id={:016X}", title_id);

     if (artic_client.get()) {
-        struct AsyncData {
+        struct AsyncData
+        {
             u8 media_type;
             u64 title_id;

@@ -2550,12 +2897,13 @@ void Module::Interface::GetDLCContentInfoCount(Kernel::HLERequestContext& ctx) {
             },
             true);
     } else {
-
         // Validate that only DLC TIDs are passed in
         u32 tid_high = static_cast<u32>(title_id >> 32);
         if (tid_high != TID_HIGH_DLC) {
             IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-            rb.Push(Result(ErrCodes::InvalidTID, ErrorModule::AM, ErrorSummary::InvalidArgument,
+            rb.Push(Result(ErrCodes::InvalidTID,
+                           ErrorModule::AM,
+                           ErrorSummary::InvalidArgument,
                            ErrorLevel::Usage));
             rb.Push<u32>(0);
             return;
@@ -2571,13 +2919,16 @@ void Module::Interface::GetDLCContentInfoCount(Kernel::HLERequestContext& ctx) {
             rb.Push<u32>(static_cast<u32>(tmd.GetContentCount()));
         } else {
             rb.Push<u32>(1); // Number of content infos plus one
-            LOG_WARNING(Service_AM, "missing TMD media_type={}, title_id=0x{:016x}", media_type,
+            LOG_WARNING(Service_AM,
+                        "missing TMD media_type={}, title_id=0x{:016x}",
+                        media_type,
                         title_id);
         }
     }
 }

-void Module::Interface::DeleteTicket(Kernel::HLERequestContext& ctx) {
+void Module::Interface::DeleteTicket(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     u64 title_id = rp.Pop<u64>();

@@ -2585,9 +2936,12 @@ void Module::Interface::DeleteTicket(Kernel::HLERequestContext& ctx) {

     IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
     std::scoped_lock lock(am->am_lists_mutex);
+#ifdef todotodo
     auto range = am->am_ticket_list.equal_range(title_id);
     if (range.first == range.second) {
-        rb.Push(Result(ErrorDescription::AlreadyDone, ErrorModule::AM, ErrorSummary::Success,
+        rb.Push(Result(ErrorDescription::AlreadyDone,
+                       ErrorModule::AM,
+                       ErrorSummary::Success,
                        ErrorLevel::Success));
         return;
     }
@@ -2598,24 +2952,36 @@ void Module::Interface::DeleteTicket(Kernel::HLERequestContext& ctx) {
     }

     am->am_ticket_list.erase(range.first, range.second);
+#endif

     rb.Push(ResultSuccess);
+    LOG_WARNING(Service_AM, "(STUBBED) called title_id=0x{:016x}", title_id);
 }

-void Module::Interface::GetNumTickets(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetNumTickets(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     LOG_DEBUG(Service_AM, "");

     std::scoped_lock lock(am->am_lists_mutex);
+#ifdef todotodo
     u32 ticket_count = static_cast<u32>(am->am_ticket_list.size());
+#else
+    u32 ticket_count = 0;
+    for (const auto& title_list : am->am_title_list) {
+        ticket_count += static_cast<u32>(title_list.size());
+    }
+#endif

     IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
     rb.Push(ResultSuccess);
     rb.Push(ticket_count);
+    LOG_WARNING(Service_AM, "(STUBBED) called ticket_count=0x{:08x}", ticket_count);
 }

-void Module::Interface::GetTicketList(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetTicketList(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     u32 ticket_list_count = rp.Pop<u32>();
     u32 ticket_index = rp.Pop<u32>();
@@ -2625,6 +2991,7 @@ void Module::Interface::GetTicketList(Kernel::HLERequestContext& ctx) {

     u32 tickets_written = 0;
     std::scoped_lock lock(am->am_lists_mutex);
+#ifdef todotodo
     auto it = am->am_ticket_list.begin();
     std::advance(it, std::min(static_cast<size_t>(ticket_index), am->am_ticket_list.size()));

@@ -2632,32 +2999,55 @@ void Module::Interface::GetTicketList(Kernel::HLERequestContext& ctx) {
          it++, tickets_written++) {
         ticket_tids_out.Write(&it->first, tickets_written * sizeof(u64), sizeof(u64));
     }
+#else
+    for (const auto& title_list : am->am_title_list) {
+        const auto tickets_to_write = std::min(static_cast<u32>(title_list.size()),
+                                               ticket_list_count - tickets_written);
+        ticket_tids_out.Write(title_list.data(),
+                              tickets_written * sizeof(u64),
+                              tickets_to_write * sizeof(u64));
+        tickets_written += tickets_to_write;
+    }
+#endif

     IPC::RequestBuilder rb = rp.MakeBuilder(2, 2);
     rb.Push(ResultSuccess);
     rb.Push(tickets_written);
     rb.PushMappedBuffer(ticket_tids_out);
+    LOG_WARNING(Service_AM,
+                "(STUBBED) ticket_list_count=0x{:08x}, ticket_index=0x{:08x}",
+                ticket_list_count,
+                ticket_index);
 }

-void Module::Interface::GetDeviceID(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetDeviceID(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     LOG_DEBUG(Service_AM, "");

-    const auto& otp = HW::UniqueData::GetOTP();
-    if (!otp.Valid()) {
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrorDescription::NotFound, ErrorModule::AM, ErrorSummary::NotFound,
-                       ErrorLevel::Permanent));
-        return;
-    }
+    u32 deviceID = am->ct_cert.IsValid() ? am->ct_cert.GetDeviceID() : 0;

-    u32 deviceID = otp.GetDeviceID();
-    if (am->force_new_device_id) {
-        deviceID |= 0x80000000;
-    }
-    if (am->force_old_device_id) {
-        deviceID &= ~0x80000000;
+    if (deviceID == 0) {
+        LOG_ERROR(Service_AM, "Invalid or missing CTCert");
+
+        const auto& otp = HW::UniqueData::GetOTP();
+        if (!otp.Valid()) {
+            IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
+            rb.Push(Result(ErrorDescription::NotFound,
+                           ErrorModule::AM,
+                           ErrorSummary::NotFound,
+                           ErrorLevel::Permanent));
+            return;
+        }
+
+        deviceID = otp.GetDeviceID();
+        if (am->force_new_device_id) {
+            deviceID |= 0x80000000;
+        }
+        if (am->force_old_device_id) {
+            deviceID &= ~0x80000000;
+        }
     }

     IPC::RequestBuilder rb = rp.MakeBuilder(3, 0);
@@ -2669,40 +3059,44 @@ void Module::Interface::GetDeviceID(Kernel::HLERequestContext& ctx) {
 void Module::Interface::GetNumImportTitleContextsImpl(IPC::RequestParser& rp,
                                                       FS::MediaType media_type,
                                                       bool include_installing,
-                                                      bool include_finalizing) {
-
+                                                      bool include_finalizing)
+{
     IPC::RequestBuilder rb = rp.MakeBuilder(3, 0);
     rb.Push(ResultSuccess);

+#ifdef todotodo
     u32 count = 0;
     for (auto it = am->import_title_contexts.begin(); it != am->import_title_contexts.end(); it++) {
-        if ((include_installing &&
-             (it->second.state == ImportTitleContextState::WAITING_FOR_IMPORT ||
-              it->second.state == ImportTitleContextState::RESUMABLE)) ||
-            (include_finalizing &&
-             it->second.state == ImportTitleContextState::WAITING_FOR_COMMIT)) {
+        if ((include_installing
+             && (it->second.state == ImportTitleContextState::WAITING_FOR_IMPORT
+                 || it->second.state == ImportTitleContextState::RESUMABLE))
+            || (include_finalizing
+                && it->second.state == ImportTitleContextState::WAITING_FOR_COMMIT)) {
             count++;
         }
     }

     rb.Push<u32>(count);
+#else
+    rb.Push<u32>(static_cast<u32>(am->import_title_contexts.size()));
+#endif
 }

 void Module::Interface::GetImportTitleContextListImpl(IPC::RequestParser& rp,
-                                                      FS::MediaType media_type, u32 list_count,
+                                                      FS::MediaType media_type,
+                                                      u32 list_count,
                                                       bool include_installing,
-                                                      bool include_finalizing) {
-
+                                                      bool include_finalizing)
+{
     auto out_buf = rp.PopMappedBuffer();
     u32 written = 0;

     for (auto& key_value : am->import_content_contexts) {
-        if ((include_installing &&
-             (key_value.second.state == ImportTitleContextState::WAITING_FOR_IMPORT ||
-              key_value.second.state == ImportTitleContextState::RESUMABLE)) ||
-            (include_finalizing &&
-             key_value.second.state == ImportTitleContextState::WAITING_FOR_COMMIT)) {
-
+        if ((include_installing
+             && (key_value.second.state == ImportTitleContextState::WAITING_FOR_IMPORT
+                 || key_value.second.state == ImportTitleContextState::RESUMABLE))
+            || (include_finalizing
+                && key_value.second.state == ImportTitleContextState::WAITING_FOR_COMMIT)) {
             out_buf.Write(&key_value.first, written * sizeof(u64), sizeof(u64));
             written++;
             if (written >= list_count)
@@ -2715,7 +3109,8 @@ void Module::Interface::GetImportTitleContextListImpl(IPC::RequestParser& rp,
     rb.Push(written);
 }

-void Module::Interface::GetNumImportTitleContexts(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetNumImportTitleContexts(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     const FS::MediaType media_type = static_cast<Service::FS::MediaType>(rp.Pop<u8>());
@@ -2725,24 +3120,26 @@ void Module::Interface::GetNumImportTitleContexts(Kernel::HLERequestContext& ctx
     LOG_WARNING(Service_AM, "(STUBBED) media_type={}", media_type);
 }

-void Module::Interface::GetImportTitleContextList(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetImportTitleContextList(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     const u32 list_count = rp.Pop<u32>();
-    [[maybe_unused]] const FS::MediaType media_type =
-        static_cast<Service::FS::MediaType>(rp.Pop<u8>());
+    [[maybe_unused]] const FS::MediaType media_type = static_cast<Service::FS::MediaType>(
+        rp.Pop<u8>());

     GetImportTitleContextListImpl(rp, media_type, list_count, true, true);

     LOG_WARNING(Service_AM, "(STUBBED) media_type={}", media_type);
 }

-void Module::Interface::GetImportTitleContexts(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetImportTitleContexts(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     const u32 list_count = rp.Pop<u32>();
-    [[maybe_unused]] const FS::MediaType media_type =
-        static_cast<Service::FS::MediaType>(rp.Pop<u8>());
+    [[maybe_unused]] const FS::MediaType media_type = static_cast<Service::FS::MediaType>(
+        rp.Pop<u8>());

     auto in_buf = rp.PopMappedBuffer();
     auto out_buf = rp.PopMappedBuffer();
@@ -2759,11 +3156,14 @@ void Module::Interface::GetImportTitleContexts(Kernel::HLERequestContext& ctx) {

         auto it = am->import_title_contexts.find(title_id);
         if (it == am->import_title_contexts.end()) {
-            rb.Push(Result(ErrorDescription::NotFound, ErrorModule::AM, ErrorSummary::InvalidState,
+            rb.Push(Result(ErrorDescription::NotFound,
+                           ErrorModule::AM,
+                           ErrorSummary::InvalidState,
                            ErrorLevel::Permanent));
             return;
         } else {
-            out_buf.Write(&it->second, written * sizeof(ImportTitleContext),
+            out_buf.Write(&it->second,
+                          written * sizeof(ImportTitleContext),
                           sizeof(ImportTitleContext));
             written++;
         }
@@ -2772,7 +3172,8 @@ void Module::Interface::GetImportTitleContexts(Kernel::HLERequestContext& ctx) {
     rb.Push(ResultSuccess);
 }

-void Module::Interface::DeleteImportTitleContext(Kernel::HLERequestContext& ctx) {
+void Module::Interface::DeleteImportTitleContext(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const FS::MediaType media_type = static_cast<Service::FS::MediaType>(rp.Pop<u8>());
     const u64 title_id = rp.Pop<u64>();
@@ -2782,7 +3183,9 @@ void Module::Interface::DeleteImportTitleContext(Kernel::HLERequestContext& ctx)
     IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
     auto range = am->import_title_contexts.equal_range(title_id);
     if (range.first == range.second) {
-        rb.Push(Result(ErrorDescription::NotFound, ErrorModule::AM, ErrorSummary::InvalidState,
+        rb.Push(Result(ErrorDescription::NotFound,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
                        ErrorLevel::Permanent));
         return;
     }
@@ -2791,17 +3194,21 @@ void Module::Interface::DeleteImportTitleContext(Kernel::HLERequestContext& ctx)
     rb.Push(ResultSuccess);
 }

-void Module::Interface::GetNumImportContentContextsImpl(IPC::RequestParser& rp, u64 title_id,
-                                                        FS::MediaType media_type) {
-
+void Module::Interface::GetNumImportContentContextsImpl(IPC::RequestParser& rp,
+                                                        u64 title_id,
+                                                        FS::MediaType media_type)
+{
     IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
     rb.Push(ResultSuccess);
     auto range = am->import_content_contexts.equal_range(title_id);
     rb.Push(static_cast<u32>(std::distance(range.first, range.second)));
 }

-void Module::Interface::GetImportContentContextListImpl(IPC::RequestParser& rp, u32 list_count,
-                                                        u64 title_id, FS::MediaType media_type) {
+void Module::Interface::GetImportContentContextListImpl(IPC::RequestParser& rp,
+                                                        u32 list_count,
+                                                        u64 title_id,
+                                                        FS::MediaType media_type)
+{
     auto out_buf = rp.PopMappedBuffer();

     auto range = am->import_content_contexts.equal_range(title_id);
@@ -2817,8 +3224,11 @@ void Module::Interface::GetImportContentContextListImpl(IPC::RequestParser& rp,
     rb.Push(written);
 }

-void Module::Interface::GetImportContentContextsImpl(IPC::RequestParser& rp, u32 list_count,
-                                                     u64 title_id, FS::MediaType media_type) {
+void Module::Interface::GetImportContentContextsImpl(IPC::RequestParser& rp,
+                                                     u32 list_count,
+                                                     u64 title_id,
+                                                     FS::MediaType media_type)
+{
     auto in_buf = rp.PopMappedBuffer();
     auto out_buf = rp.PopMappedBuffer();

@@ -2837,7 +3247,9 @@ void Module::Interface::GetImportContentContextsImpl(IPC::RequestParser& rp, u32
                 break;

         if (it == range.second) {
-            rb.Push(Result(ErrorDescription::NotFound, ErrorModule::AM, ErrorSummary::InvalidState,
+            rb.Push(Result(ErrorDescription::NotFound,
+                           ErrorModule::AM,
+                           ErrorSummary::InvalidState,
                            ErrorLevel::Permanent));
             return;
         }
@@ -2848,7 +3260,8 @@ void Module::Interface::GetImportContentContextsImpl(IPC::RequestParser& rp, u32
     rb.Push(ResultSuccess);
 }

-void Module::Interface::GetNumImportContentContexts(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetNumImportContentContexts(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const FS::MediaType media_type = static_cast<Service::FS::MediaType>(rp.Pop<u8>());
     const u64 title_id = rp.Pop<u64>();
@@ -2858,7 +3271,8 @@ void Module::Interface::GetNumImportContentContexts(Kernel::HLERequestContext& c
     LOG_WARNING(Service_AM, "(STUBBED) media_type={} title_id={:016X}", media_type, title_id);
 }

-void Module::Interface::GetImportContentContextList(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetImportContentContextList(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const u32 list_count = rp.Pop<u32>();
     const FS::MediaType media_type = static_cast<Service::FS::MediaType>(rp.Pop<u8>());
@@ -2869,7 +3283,8 @@ void Module::Interface::GetImportContentContextList(Kernel::HLERequestContext& c
     LOG_WARNING(Service_AM, "(STUBBED) media_type={} title_id={:016X}", media_type, title_id);
 }

-void Module::Interface::GetImportContentContexts(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetImportContentContexts(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const u32 list_count = rp.Pop<u32>();
     const FS::MediaType media_type = static_cast<Service::FS::MediaType>(rp.Pop<u8>());
@@ -2880,16 +3295,18 @@ void Module::Interface::GetImportContentContexts(Kernel::HLERequestContext& ctx)
     GetImportContentContextsImpl(rp, list_count, title_id, media_type);
 }

-void Module::Interface::NeedsCleanup(Kernel::HLERequestContext& ctx) {
+void Module::Interface::NeedsCleanup(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const auto media_type = rp.Pop<u8>();

     LOG_DEBUG(Service_AM, "(STUBBED) media_type=0x{:02x}", media_type);

+#ifdef todotodo
     bool needs_cleanup = false;
     for (auto& import_ctx : am->import_title_contexts) {
-        if (import_ctx.second.state == ImportTitleContextState::RESUMABLE ||
-            import_ctx.second.state == ImportTitleContextState::WAITING_FOR_IMPORT) {
+        if (import_ctx.second.state == ImportTitleContextState::RESUMABLE
+            || import_ctx.second.state == ImportTitleContextState::WAITING_FOR_IMPORT) {
             needs_cleanup = true;
             break;
         }
@@ -2897,28 +3314,35 @@ void Module::Interface::NeedsCleanup(Kernel::HLERequestContext& ctx) {

     if (!needs_cleanup) {
         for (auto& import_ctx : am->import_content_contexts) {
-            if (import_ctx.second.state == ImportTitleContextState::RESUMABLE ||
-                import_ctx.second.state == ImportTitleContextState::WAITING_FOR_IMPORT) {
+            if (import_ctx.second.state == ImportTitleContextState::RESUMABLE
+                || import_ctx.second.state == ImportTitleContextState::WAITING_FOR_IMPORT) {
                 needs_cleanup = true;
             }
         }
     }
+#endif

     IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
     rb.Push(ResultSuccess);
+#ifdef todotodo
     rb.Push<bool>(needs_cleanup);
+#else
+    rb.Push<bool>(false);
+#endif
 }

-void Module::Interface::DoCleanup(Kernel::HLERequestContext& ctx) {
+void Module::Interface::DoCleanup(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const auto media_type = rp.Pop<u8>();

     LOG_DEBUG(Service_AM, "(STUBBED) called, media_type={:#02x}", media_type);

+#ifdef todotodo
     for (auto it = am->import_content_contexts.begin(); it != am->import_content_contexts.end();) {
-        if (it->second.state == ImportTitleContextState::RESUMABLE ||
-            it->second.state == ImportTitleContextState::WAITING_FOR_IMPORT ||
-            it->second.state == ImportTitleContextState::NEEDS_CLEANUP) {
+        if (it->second.state == ImportTitleContextState::RESUMABLE
+            || it->second.state == ImportTitleContextState::WAITING_FOR_IMPORT
+            || it->second.state == ImportTitleContextState::NEEDS_CLEANUP) {
             it = am->import_content_contexts.erase(it);
         } else {
             it++;
@@ -2926,13 +3350,13 @@ void Module::Interface::DoCleanup(Kernel::HLERequestContext& ctx) {
     }

     for (auto it = am->import_title_contexts.begin(); it != am->import_title_contexts.end();) {
-        if (it->second.state == ImportTitleContextState::RESUMABLE ||
-            it->second.state == ImportTitleContextState::WAITING_FOR_IMPORT ||
-            it->second.state == ImportTitleContextState::NEEDS_CLEANUP) {
+        if (it->second.state == ImportTitleContextState::RESUMABLE
+            || it->second.state == ImportTitleContextState::WAITING_FOR_IMPORT
+            || it->second.state == ImportTitleContextState::NEEDS_CLEANUP) {
             if (am->importing_title) {
-                if (am->importing_title->title_id == it->second.title_id &&
-                    am->importing_title->media_type ==
-                        static_cast<Service::FS::MediaType>(media_type)) {
+                if (am->importing_title->title_id == it->second.title_id
+                    && am->importing_title->media_type
+                           == static_cast<Service::FS::MediaType>(media_type)) {
                     am->importing_title.reset();
                 }
             }
@@ -2941,12 +3365,14 @@ void Module::Interface::DoCleanup(Kernel::HLERequestContext& ctx) {
             it++;
         }
     }
+#endif

     IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
     rb.Push(ResultSuccess);
 }

-void Module::Interface::QueryAvailableTitleDatabase(Kernel::HLERequestContext& ctx) {
+void Module::Interface::QueryAvailableTitleDatabase(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     u8 media_type = rp.Pop<u8>();

@@ -2957,10 +3383,13 @@ void Module::Interface::QueryAvailableTitleDatabase(Kernel::HLERequestContext& c
     LOG_WARNING(Service_AM, "(STUBBED) media_type={}", media_type);
 }

-void Module::Interface::GetPersonalizedTicketInfoList(Kernel::HLERequestContext& ctx) {
+#ifdef todotodo
+void Module::Interface::GetPersonalizedTicketInfoList(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

-    struct AsyncData {
+    struct AsyncData
+    {
         u32 ticket_count;

         std::vector<TicketInfo> out;
@@ -2979,15 +3408,16 @@ void Module::Interface::GetPersonalizedTicketInfoList(Kernel::HLERequestContext&
             u32 written = 0;
             std::scoped_lock lock(am->am_lists_mutex);
             for (auto it = am->am_ticket_list.begin();
-                 it != am->am_ticket_list.end() && written < async_data->ticket_count; it++) {
+                 it != am->am_ticket_list.end() && written < async_data->ticket_count;
+                 it++) {
                 u64 title_id = it->first;
                 u32 tid_high = static_cast<u32>(title_id << 32);
                 if ((tid_high & 0x00048010) == 0x00040010 || (tid_high & 0x00048001) == 0x00048001)
                     continue;

                 FileSys::Ticket ticket;
-                if (ticket.Load(title_id, it->second) != Loader::ResultStatus::Success ||
-                    !ticket.IsPersonal())
+                if (ticket.Load(title_id, it->second) != Loader::ResultStatus::Success
+                    || !ticket.IsPersonal())
                     continue;

                 TicketInfo info = {};
@@ -3004,7 +3434,8 @@ void Module::Interface::GetPersonalizedTicketInfoList(Kernel::HLERequestContext&
         [async_data](Kernel::HLERequestContext& ctx) {
             u32 written = 0;
             for (auto& info : async_data->out) {
-                async_data->out_buffer->Write(&info, written * sizeof(TicketInfo),
+                async_data->out_buffer->Write(&info,
+                                              written * sizeof(TicketInfo),
                                               sizeof(TicketInfo));
                 written++;
             }
@@ -3016,33 +3447,86 @@ void Module::Interface::GetPersonalizedTicketInfoList(Kernel::HLERequestContext&
         true);
 }

-void Module::Interface::GetNumImportTitleContextsFiltered(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetNumImportTitleContextsFiltered(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     const FS::MediaType media_type = static_cast<Service::FS::MediaType>(rp.Pop<u8>());
     const u8 filter = rp.Pop<u8>();

-    GetNumImportTitleContextsImpl(rp, media_type, (filter & (1 << 0)) != 0,
+    GetNumImportTitleContextsImpl(rp,
+                                  media_type,
+                                  (filter & (1 << 0)) != 0,
                                   (filter & (1 << 1)) != 0);

     LOG_WARNING(Service_AM, "(STUBBED) called, media_type={}, filter={}", media_type, filter);
 }

-void Module::Interface::GetImportTitleContextListFiltered(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetImportTitleContextListFiltered(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     const u32 list_count = rp.Pop<u32>();
-    [[maybe_unused]] const FS::MediaType media_type =
-        static_cast<Service::FS::MediaType>(rp.Pop<u8>());
+    [[maybe_unused]] const FS::MediaType media_type = static_cast<Service::FS::MediaType>(
+        rp.Pop<u8>());
     const u8 filter = rp.Pop<u8>();

-    GetImportTitleContextListImpl(rp, media_type, list_count, (filter & (1 << 0)) != 0,
+    GetImportTitleContextListImpl(rp,
+                                  media_type,
+                                  list_count,
+                                  (filter & (1 << 0)) != 0,
                                   (filter & (1 << 1)) != 0);

     LOG_WARNING(Service_AM, "(STUBBED) called, media_type={}, filter={}", media_type, filter);
 }
+#else
+void Module::Interface::GetPersonalizedTicketInfoList(Kernel::HLERequestContext& ctx)
+{
+    IPC::RequestParser rp(ctx);
+    [[maybe_unused]] u32 ticket_count = rp.Pop<u32>();
+    [[maybe_unused]] auto& buffer = rp.PopMappedBuffer();
+
+    std::scoped_lock lock(am->am_lists_mutex);
+
+    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
+    rb.Push(ResultSuccess); // No error
+    rb.Push(0);

-void Module::Interface::CheckContentRights(Kernel::HLERequestContext& ctx) {
+    LOG_WARNING(Service_AM, "(STUBBED) called, ticket_count={}", ticket_count);
+}
+
+void Module::Interface::GetNumImportTitleContextsFiltered(Kernel::HLERequestContext& ctx)
+{
+    IPC::RequestParser rp(ctx);
+    u8 media_type = rp.Pop<u8>();
+    u8 filter = rp.Pop<u8>();
+
+    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
+    rb.Push(ResultSuccess); // No error
+    rb.Push(0);
+
+    LOG_WARNING(Service_AM, "(STUBBED) called, media_type={}, filter={}", media_type, filter);
+}
+
+void Module::Interface::GetImportTitleContextListFiltered(Kernel::HLERequestContext& ctx)
+{
+    IPC::RequestParser rp(ctx);
+    [[maybe_unused]] const u32 count = rp.Pop<u32>();
+    const u8 media_type = rp.Pop<u8>();
+    const u8 filter = rp.Pop<u8>();
+    auto& buffer = rp.PopMappedBuffer();
+
+    IPC::RequestBuilder rb = rp.MakeBuilder(2, 2);
+    rb.Push(ResultSuccess); // No error
+    rb.Push(0);
+    rb.PushMappedBuffer(buffer);
+
+    LOG_WARNING(Service_AM, "(STUBBED) called, media_type={}, filter={}", media_type, filter);
+}
+#endif
+
+void Module::Interface::CheckContentRights(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     u64 tid = rp.Pop<u64>();
     u16 content_index = rp.Pop<u16>();
@@ -3051,8 +3535,8 @@ void Module::Interface::CheckContentRights(Kernel::HLERequestContext& ctx) {
     FileSys::Ticket ticket;
     std::scoped_lock lock(am->am_lists_mutex);
     auto entries = am->am_ticket_list.find(tid);
-    if (entries != am->am_ticket_list.end() &&
-        ticket.Load(tid, (*entries).second) == Loader::ResultStatus::Success) {
+    if (entries != am->am_ticket_list.end()
+        && ticket.Load(tid, (*entries).second) == Loader::ResultStatus::Success) {
         has_ticket = true;
     }

@@ -3065,7 +3549,8 @@ void Module::Interface::CheckContentRights(Kernel::HLERequestContext& ctx) {
     LOG_DEBUG(Service_AM, "tid={:016x}, content_index={}", tid, content_index);
 }

-void Module::Interface::CheckContentRightsIgnorePlatform(Kernel::HLERequestContext& ctx) {
+void Module::Interface::CheckContentRightsIgnorePlatform(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     u64 tid = rp.Pop<u64>();
     u16 content_index = rp.Pop<u16>();
@@ -3074,8 +3559,8 @@ void Module::Interface::CheckContentRightsIgnorePlatform(Kernel::HLERequestConte
     FileSys::Ticket ticket;
     std::scoped_lock lock(am->am_lists_mutex);
     auto entries = am->am_ticket_list.find(tid);
-    if (entries != am->am_ticket_list.end() &&
-        ticket.Load(tid, (*entries).second) == Loader::ResultStatus::Success) {
+    if (entries != am->am_ticket_list.end()
+        && ticket.Load(tid, (*entries).second) == Loader::ResultStatus::Success) {
         has_ticket = true;
     }

@@ -3088,22 +3573,34 @@ void Module::Interface::CheckContentRightsIgnorePlatform(Kernel::HLERequestConte
     LOG_DEBUG(Service_AM, "tid={:016x}, content_index={}", tid, content_index);
 }

-void Module::Interface::BeginImportProgram(Kernel::HLERequestContext& ctx) {
+void Module::Interface::BeginImportProgram(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     auto media_type = static_cast<Service::FS::MediaType>(rp.Pop<u8>());

     if (am->cia_installing) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidImportState, ErrorModule::AM, ErrorSummary::InvalidState,
+#ifdef todotodo
+        rb.Push(Result(ErrCodes::InvalidImportState,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
+                       ErrorLevel::Permanent));
+#else
+        rb.Push(Result(ErrCodes::CIACurrentlyInstalling,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
                        ErrorLevel::Permanent));
+#endif
         return;
     }

     // Create our CIAFile handle for the app to write to, and while the app writes
     // Citra will store contents out to sdmc/nand
     const FileSys::Path cia_path = {};
-    auto file = std::make_shared<Service::FS::File>(
-        am->system.Kernel(), std::make_unique<CIAFile>(am->system, media_type), cia_path);
+    auto file = std::make_shared<Service::FS::File>(am->system.Kernel(),
+                                                    std::make_unique<CIAFile>(am->system,
+                                                                              media_type),
+                                                    cia_path);

     am->cia_installing = true;

@@ -3114,13 +3611,23 @@ void Module::Interface::BeginImportProgram(Kernel::HLERequestContext& ctx) {
     LOG_WARNING(Service_AM, "(STUBBED) media_type={}", media_type);
 }

-void Module::Interface::BeginImportProgramTemporarily(Kernel::HLERequestContext& ctx) {
+void Module::Interface::BeginImportProgramTemporarily(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     if (am->cia_installing) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidImportState, ErrorModule::AM, ErrorSummary::InvalidState,
+#ifdef todotodo
+        rb.Push(Result(ErrCodes::InvalidImportState,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
+                       ErrorLevel::Permanent));
+#else
+        rb.Push(Result(ErrCodes::CIACurrentlyInstalling,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
                        ErrorLevel::Permanent));
+#endif
         return;
     }

@@ -3129,8 +3636,10 @@ void Module::Interface::BeginImportProgramTemporarily(Kernel::HLERequestContext&
     // Create our CIAFile handle for the app to write to, and while the app writes Citra will store
     // contents out to sdmc/nand
     const FileSys::Path cia_path = {};
-    auto file = std::make_shared<Service::FS::File>(
-        am->system.Kernel(), std::make_unique<CIAFile>(am->system, FS::MediaType::NAND), cia_path);
+    auto file = std::make_shared<Service::FS::File>(am->system.Kernel(),
+                                                    std::make_unique<CIAFile>(am->system,
+                                                                              FS::MediaType::NAND),
+                                                    cia_path);

     am->cia_installing = true;

@@ -3141,7 +3650,8 @@ void Module::Interface::BeginImportProgramTemporarily(Kernel::HLERequestContext&
     LOG_WARNING(Service_AM, "(STUBBED)");
 }

-void Module::Interface::EndImportProgram(Kernel::HLERequestContext& ctx) {
+void Module::Interface::EndImportProgram(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     [[maybe_unused]] const auto cia = rp.PopObject<Kernel::ClientSession>();

@@ -3154,7 +3664,8 @@ void Module::Interface::EndImportProgram(Kernel::HLERequestContext& ctx) {
     rb.Push(ResultSuccess);
 }

-void Module::Interface::EndImportProgramWithoutCommit(Kernel::HLERequestContext& ctx) {
+void Module::Interface::EndImportProgramWithoutCommit(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     [[maybe_unused]] const auto cia = rp.PopObject<Kernel::ClientSession>();

@@ -3169,34 +3680,56 @@ void Module::Interface::EndImportProgramWithoutCommit(Kernel::HLERequestContext&
     LOG_WARNING(Service_AM, "(STUBBED)");
 }

-void Module::Interface::CommitImportPrograms(Kernel::HLERequestContext& ctx) {
+void Module::Interface::CommitImportPrograms(Kernel::HLERequestContext& ctx)
+{
+#ifdef todotodo
     CommitImportTitlesImpl(ctx, false, false);
+#else
+    IPC::RequestParser rp(ctx);
+    [[maybe_unused]] const auto media_type = static_cast<FS::MediaType>(rp.Pop<u8>());
+    [[maybe_unused]] const u32 title_count = rp.Pop<u32>();
+    [[maybe_unused]] const u8 database = rp.Pop<u8>();
+    const auto buffer = rp.PopMappedBuffer();
+
+    // Note: This function is basically a no-op for us since we don't use title.db or ticket.db
+    // files to keep track of installed titles.
+    am->ScanForAllTitles();
+
+    IPC::RequestBuilder rb = rp.MakeBuilder(1, 2);
+    rb.Push(ResultSuccess);
+    rb.PushMappedBuffer(buffer);
+
+    LOG_WARNING(Service_AM, "(STUBBED)");
+#endif
 }

 /// Wraps all File operations to allow adding an offset to them.
-class AMFileWrapper : public FileSys::FileBackend {
+class AMFileWrapper : public FileSys::FileBackend
+{
 public:
     AMFileWrapper(std::shared_ptr<Service::FS::File> file, std::size_t offset, std::size_t size)
-        : file(std::move(file)), file_offset(offset), file_size(size) {}
+        : file(std::move(file))
+        , file_offset(offset)
+        , file_size(size)
+    {}

-    ResultVal<std::size_t> Read(u64 offset, std::size_t length, u8* buffer) const override {
+    ResultVal<std::size_t> Read(u64 offset, std::size_t length, u8* buffer) const override
+    {
         return file->backend->Read(offset + file_offset, length, buffer);
     }

-    ResultVal<std::size_t> Write(u64 offset, std::size_t length, bool flush, bool update_timestamp,
-                                 const u8* buffer) override {
+    ResultVal<std::size_t> Write(u64 offset,
+                                 std::size_t length,
+                                 bool flush,
+                                 bool update_timestamp,
+                                 const u8* buffer) override
+    {
         return file->backend->Write(offset + file_offset, length, flush, update_timestamp, buffer);
     }

-    u64 GetSize() const override {
-        return file_size;
-    }
-    bool SetSize(u64 size) const override {
-        return false;
-    }
-    bool Close() override {
-        return false;
-    }
+    u64 GetSize() const override { return file_size; }
+    bool SetSize(u64 size) const override { return false; }
+    bool Close() override { return false; }
     void Flush() const override {}

 private:
@@ -3206,7 +3739,8 @@ private:
 };

 ResultVal<std::unique_ptr<AMFileWrapper>> GetCiaFileFromSession(
-    std::shared_ptr<Kernel::ClientSession> file_session) {
+    std::shared_ptr<Kernel::ClientSession> file_session)
+{
     // Step up the chain from ClientSession->ServerSession and then
     // cast to File. For AM on 3DS, invalid handles actually hang the system.

@@ -3215,8 +3749,7 @@ ResultVal<std::unique_ptr<AMFileWrapper>> GetCiaFileFromSession(
         return Kernel::ResultInvalidHandle;
     }

-    std::shared_ptr<Kernel::ServerSession> server =
-        Kernel::SharedFrom(file_session->parent->server);
+    std::shared_ptr<Kernel::ServerSession> server = Kernel::SharedFrom(file_session->parent->server);
     if (server == nullptr) {
         LOG_WARNING(Service_AM, "File handle ServerSession disconnected!");
         return Kernel::ResultSessionClosed;
@@ -3244,8 +3777,9 @@ ResultVal<std::unique_ptr<AMFileWrapper>> GetCiaFileFromSession(
     return Kernel::ResultNotImplemented;
 }

-template <typename T>
-ResultVal<T*> GetFileBackendFromSession(std::shared_ptr<Kernel::ClientSession> file_session) {
+template<typename T>
+ResultVal<T*> GetFileBackendFromSession(std::shared_ptr<Kernel::ClientSession> file_session)
+{
     // Step up the chain from ClientSession->ServerSession and then
     // cast to file backend. For AM on 3DS, invalid handles actually hang the system.

@@ -3254,8 +3788,7 @@ ResultVal<T*> GetFileBackendFromSession(std::shared_ptr<Kernel::ClientSession> f
         return Kernel::ResultInvalidHandle;
     }

-    std::shared_ptr<Kernel::ServerSession> server =
-        Kernel::SharedFrom(file_session->parent->server);
+    std::shared_ptr<Kernel::ServerSession> server = Kernel::SharedFrom(file_session->parent->server);
     if (server == nullptr) {
         LOG_WARNING(Service_AM, "File handle ServerSession disconnected!");
         return Kernel::ResultSessionClosed;
@@ -3288,7 +3821,8 @@ ResultVal<T*> GetFileBackendFromSession(std::shared_ptr<Kernel::ClientSession> f
     return Kernel::ResultNotImplemented;
 }

-void Module::Interface::GetProgramInfoFromCia(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetProgramInfoFromCia(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     [[maybe_unused]] const auto media_type = static_cast<FS::MediaType>(rp.Pop<u8>());
     auto cia = rp.PopObject<Kernel::ClientSession>();
@@ -3305,7 +3839,9 @@ void Module::Interface::GetProgramInfoFromCia(Kernel::HLERequestContext& ctx) {
     FileSys::CIAContainer container;
     if (container.Load(*file_res.Unwrap()) != Loader::ResultStatus::Success) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        rb.Push(Result(ErrCodes::InvalidCIAHeader,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidArgument,
                        ErrorLevel::Permanent));
         return;
     }
@@ -3327,7 +3863,8 @@ void Module::Interface::GetProgramInfoFromCia(Kernel::HLERequestContext& ctx) {
     rb.PushRaw<TitleInfo>(title_info);
 }

-void Module::Interface::GetSystemMenuDataFromCia(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetSystemMenuDataFromCia(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     auto cia = rp.PopObject<Kernel::ClientSession>();
     auto& output_buffer = rp.PopMappedBuffer();
@@ -3348,7 +3885,9 @@ void Module::Interface::GetSystemMenuDataFromCia(Kernel::HLERequestContext& ctx)
     FileSys::CIAContainer container;
     if (container.Load(*file) != Loader::ResultStatus::Success) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 2);
-        rb.Push(Result(ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        rb.Push(Result(ErrCodes::InvalidCIAHeader,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidArgument,
                        ErrorLevel::Permanent));
         rb.PushMappedBuffer(output_buffer);
         return;
@@ -3357,10 +3896,13 @@ void Module::Interface::GetSystemMenuDataFromCia(Kernel::HLERequestContext& ctx)

     //  Read from the Meta offset + 0x400 for the 0x36C0-large SMDH
     auto read_result = file->Read(container.GetMetadataOffset() + FileSys::CIA_METADATA_SIZE,
-                                  temp.size(), temp.data());
+                                  temp.size(),
+                                  temp.data());
     if (read_result.Failed() || *read_result != temp.size()) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 2);
-        rb.Push(Result(ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        rb.Push(Result(ErrCodes::InvalidCIAHeader,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidArgument,
                        ErrorLevel::Permanent));
         rb.PushMappedBuffer(output_buffer);
         return;
@@ -3373,7 +3915,8 @@ void Module::Interface::GetSystemMenuDataFromCia(Kernel::HLERequestContext& ctx)
     rb.PushMappedBuffer(output_buffer);
 }

-void Module::Interface::GetDependencyListFromCia(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetDependencyListFromCia(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     auto cia = rp.PopObject<Kernel::ClientSession>();

@@ -3389,7 +3932,9 @@ void Module::Interface::GetDependencyListFromCia(Kernel::HLERequestContext& ctx)
     FileSys::CIAContainer container;
     if (container.Load(*file_res.Unwrap()) != Loader::ResultStatus::Success) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        rb.Push(Result(ErrCodes::InvalidCIAHeader,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidArgument,
                        ErrorLevel::Permanent));
         return;
     }
@@ -3402,7 +3947,8 @@ void Module::Interface::GetDependencyListFromCia(Kernel::HLERequestContext& ctx)
     rb.PushStaticBuffer(std::move(buffer), 0);
 }

-void Module::Interface::GetTransferSizeFromCia(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetTransferSizeFromCia(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     auto cia = rp.PopObject<Kernel::ClientSession>();

@@ -3418,7 +3964,9 @@ void Module::Interface::GetTransferSizeFromCia(Kernel::HLERequestContext& ctx) {
     FileSys::CIAContainer container;
     if (container.Load(*file_res.Unwrap()) != Loader::ResultStatus::Success) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        rb.Push(Result(ErrCodes::InvalidCIAHeader,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidArgument,
                        ErrorLevel::Permanent));
         return;
     }
@@ -3428,7 +3976,8 @@ void Module::Interface::GetTransferSizeFromCia(Kernel::HLERequestContext& ctx) {
     rb.Push(container.GetMetadataOffset());
 }

-void Module::Interface::GetCoreVersionFromCia(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetCoreVersionFromCia(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     auto cia = rp.PopObject<Kernel::ClientSession>();

@@ -3444,7 +3993,9 @@ void Module::Interface::GetCoreVersionFromCia(Kernel::HLERequestContext& ctx) {
     FileSys::CIAContainer container;
     if (container.Load(*file_res.Unwrap()) != Loader::ResultStatus::Success) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        rb.Push(Result(ErrCodes::InvalidCIAHeader,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidArgument,
                        ErrorLevel::Permanent));
         return;
     }
@@ -3454,7 +4005,8 @@ void Module::Interface::GetCoreVersionFromCia(Kernel::HLERequestContext& ctx) {
     rb.Push(container.GetCoreVersion());
 }

-void Module::Interface::GetRequiredSizeFromCia(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetRequiredSizeFromCia(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     [[maybe_unused]] const auto media_type = static_cast<FS::MediaType>(rp.Pop<u8>());
     auto cia = rp.PopObject<Kernel::ClientSession>();
@@ -3471,7 +4023,9 @@ void Module::Interface::GetRequiredSizeFromCia(Kernel::HLERequestContext& ctx) {
     FileSys::CIAContainer container;
     if (container.Load(*file_res.Unwrap()) != Loader::ResultStatus::Success) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        rb.Push(Result(ErrCodes::InvalidCIAHeader,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidArgument,
                        ErrorLevel::Permanent));
         return;
     }
@@ -3484,19 +4038,25 @@ void Module::Interface::GetRequiredSizeFromCia(Kernel::HLERequestContext& ctx) {
     rb.Push(container.GetTitleMetadata().GetContentSizeByIndex(FileSys::TMDContentIndex::Main));
 }

-void Module::Interface::CommitImportProgramsAndUpdateFirmwareAuto(Kernel::HLERequestContext& ctx) {
+void Module::Interface::CommitImportProgramsAndUpdateFirmwareAuto(Kernel::HLERequestContext& ctx)
+{
     CommitImportTitlesImpl(ctx, true, false);
 }

 void Module::Interface::CommitImportTitlesImpl(Kernel::HLERequestContext& ctx,
-                                               bool is_update_firm_auto, bool is_titles) {
+                                               bool is_update_firm_auto,
+                                               bool is_titles)
+{
     IPC::RequestParser rp(ctx);
     const auto media_type = static_cast<FS::MediaType>(rp.Pop<u8>());
     [[maybe_unused]] u32 count = rp.Pop<u32>();
     bool cleanup = rp.Pop<bool>();

-    LOG_WARNING(Service_AM, "(STUBBED) update_firm_auto={} is_titles={} cleanup={}",
-                is_update_firm_auto, is_titles, cleanup);
+    LOG_WARNING(Service_AM,
+                "(STUBBED) update_firm_auto={} is_titles={} cleanup={}",
+                is_update_firm_auto,
+                is_titles,
+                cleanup);

     auto& title_id_buf = rp.PopMappedBuffer();

@@ -3504,16 +4064,16 @@ void Module::Interface::CommitImportTitlesImpl(Kernel::HLERequestContext& ctx,
     title_id_buf.Read(title_ids.data(), 0, title_id_buf.GetSize());

     for (auto& key_value : am->import_content_contexts) {
-        if (std::find(title_ids.begin(), title_ids.end(), key_value.first) != title_ids.end() &&
-            key_value.second.state == ImportTitleContextState::WAITING_FOR_COMMIT) {
+        if (std::find(title_ids.begin(), title_ids.end(), key_value.first) != title_ids.end()
+            && key_value.second.state == ImportTitleContextState::WAITING_FOR_COMMIT) {
             key_value.second.state = ImportTitleContextState::NEEDS_CLEANUP;
         }
     }

     for (auto tid : title_ids) {
         auto it = am->import_title_contexts.find(tid);
-        if (it != am->import_title_contexts.end() &&
-            it->second.state == ImportTitleContextState::WAITING_FOR_COMMIT) {
+        if (it != am->import_title_contexts.end()
+            && it->second.state == ImportTitleContextState::WAITING_FOR_COMMIT) {
             it->second.state = ImportTitleContextState::NEEDS_CLEANUP;
         }
     }
@@ -3521,9 +4081,9 @@ void Module::Interface::CommitImportTitlesImpl(Kernel::HLERequestContext& ctx,
     if (cleanup) {
         for (auto it = am->import_content_contexts.begin();
              it != am->import_content_contexts.end();) {
-            if (it->second.state == ImportTitleContextState::RESUMABLE ||
-                it->second.state == ImportTitleContextState::WAITING_FOR_IMPORT ||
-                it->second.state == ImportTitleContextState::NEEDS_CLEANUP) {
+            if (it->second.state == ImportTitleContextState::RESUMABLE
+                || it->second.state == ImportTitleContextState::WAITING_FOR_IMPORT
+                || it->second.state == ImportTitleContextState::NEEDS_CLEANUP) {
                 it = am->import_content_contexts.erase(it);
             } else {
                 it++;
@@ -3531,9 +4091,9 @@ void Module::Interface::CommitImportTitlesImpl(Kernel::HLERequestContext& ctx,
         }

         for (auto it = am->import_title_contexts.begin(); it != am->import_title_contexts.end();) {
-            if (it->second.state == ImportTitleContextState::RESUMABLE ||
-                it->second.state == ImportTitleContextState::WAITING_FOR_IMPORT ||
-                it->second.state == ImportTitleContextState::NEEDS_CLEANUP) {
+            if (it->second.state == ImportTitleContextState::RESUMABLE
+                || it->second.state == ImportTitleContextState::WAITING_FOR_IMPORT
+                || it->second.state == ImportTitleContextState::NEEDS_CLEANUP) {
                 it = am->import_title_contexts.erase(it);
             } else {
                 it++;
@@ -3547,22 +4107,28 @@ void Module::Interface::CommitImportTitlesImpl(Kernel::HLERequestContext& ctx,
     rb.Push(ResultSuccess);
 }

-Result UninstallProgram(const FS::MediaType media_type, const u64 title_id) {
+Result UninstallProgram(const FS::MediaType media_type, const u64 title_id)
+{
     // Use the content folder so we don't delete the user's save data.
     const auto path = GetTitlePath(media_type, title_id) + "content/";
     if (!FileUtil::Exists(path)) {
-        return {ErrorDescription::NotFound, ErrorModule::AM, ErrorSummary::InvalidState,
+        return {ErrorDescription::NotFound,
+                ErrorModule::AM,
+                ErrorSummary::InvalidState,
                 ErrorLevel::Permanent};
     }
     if (!FileUtil::DeleteDirRecursively(path)) {
         // TODO: Determine the right error code for this.
-        return {ErrorDescription::NotFound, ErrorModule::AM, ErrorSummary::InvalidState,
+        return {ErrorDescription::NotFound,
+                ErrorModule::AM,
+                ErrorSummary::InvalidState,
                 ErrorLevel::Permanent};
     }
     return ResultSuccess;
 }

-void Module::Interface::DeleteProgram(Kernel::HLERequestContext& ctx) {
+void Module::Interface::DeleteProgram(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const auto media_type = rp.PopEnum<FS::MediaType>();
     const auto title_id = rp.Pop<u64>();
@@ -3576,7 +4142,8 @@ void Module::Interface::DeleteProgram(Kernel::HLERequestContext& ctx) {
     rb.Push(result);
 }

-void Module::Interface::GetSystemUpdaterMutex(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetSystemUpdaterMutex(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     LOG_DEBUG(Service_AM, "");
@@ -3586,7 +4153,8 @@ void Module::Interface::GetSystemUpdaterMutex(Kernel::HLERequestContext& ctx) {
     rb.PushCopyObjects(am->system_updater_mutex);
 }

-void Module::Interface::GetMetaSizeFromCia(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetMetaSizeFromCia(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     auto cia = rp.PopObject<Kernel::ClientSession>();

@@ -3601,9 +4169,10 @@ void Module::Interface::GetMetaSizeFromCia(Kernel::HLERequestContext& ctx) {

     FileSys::CIAContainer container;
     if (container.Load(*file_res.Unwrap()) != Loader::ResultStatus::Success) {
-
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        rb.Push(Result(ErrCodes::InvalidCIAHeader,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidArgument,
                        ErrorLevel::Permanent));
         return;
     }
@@ -3613,7 +4182,8 @@ void Module::Interface::GetMetaSizeFromCia(Kernel::HLERequestContext& ctx) {
     rb.Push(container.GetMetadataSize());
 }

-void Module::Interface::GetMetaDataFromCia(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetMetaDataFromCia(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     u32 output_size = rp.Pop<u32>();
@@ -3636,7 +4206,9 @@ void Module::Interface::GetMetaDataFromCia(Kernel::HLERequestContext& ctx) {
     FileSys::CIAContainer container;
     if (container.Load(*file) != Loader::ResultStatus::Success) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 2);
-        rb.Push(Result(ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        rb.Push(Result(ErrCodes::InvalidCIAHeader,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidArgument,
                        ErrorLevel::Permanent));
         rb.PushMappedBuffer(output_buffer);
         return;
@@ -3647,7 +4219,9 @@ void Module::Interface::GetMetaDataFromCia(Kernel::HLERequestContext& ctx) {
     auto read_result = file->Read(container.GetMetadataOffset(), output_size, temp.data());
     if (read_result.Failed() || *read_result != output_size) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        rb.Push(Result(ErrCodes::InvalidCIAHeader,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidArgument,
                        ErrorLevel::Permanent));
         return;
     }
@@ -3658,27 +4232,34 @@ void Module::Interface::GetMetaDataFromCia(Kernel::HLERequestContext& ctx) {
     rb.PushMappedBuffer(output_buffer);
 }

-void Module::Interface::BeginImportTicket(Kernel::HLERequestContext& ctx) {
+void Module::Interface::BeginImportTicket(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     LOG_DEBUG(Service_AM, "");

     // Create our TicketFile handle for the app to write to
-    auto file = std::make_shared<Service::FS::File>(
-        am->system.Kernel(), std::make_unique<TicketFile>(), FileSys::Path{});
+    auto file = std::make_shared<Service::FS::File>(am->system.Kernel(),
+                                                    std::make_unique<TicketFile>(),
+                                                    FileSys::Path{});

     IPC::RequestBuilder rb = rp.MakeBuilder(1, 2);
     rb.Push(ResultSuccess); // No error
     rb.PushCopyObjects(file->Connect());
+
+    LOG_WARNING(Service_AM, "(STUBBED) called");
 }

-void Module::Interface::EndImportTicket(Kernel::HLERequestContext& ctx) {
+#ifdef todotodo
+void Module::Interface::EndImportTicket(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const auto ticket = rp.PopObject<Kernel::ClientSession>();

     auto ticket_file = GetFileBackendFromSession<TicketFile>(ticket);
     if (ticket_file.Succeeded()) {
-        struct AsyncData {
+        struct AsyncData
+        {
             Service::AM::TicketFile* ticket_file;

             Result res{0};
@@ -3694,7 +4275,8 @@ void Module::Interface::EndImportTicket(Kernel::HLERequestContext& ctx) {
                 am->am_ticket_list.insert(std::make_pair(async_data->ticket_file->GetTitleID(),
                                                          async_data->ticket_file->GetTicketID()));

-                LOG_DEBUG(Service_AM, "EndImportTicket: title_id={:016X} ticket_id={:016X}",
+                LOG_DEBUG(Service_AM,
+                          "EndImportTicket: title_id={:016X} ticket_id={:016X}",
                           async_data->ticket_file->GetTitleID(),
                           async_data->ticket_file->GetTicketID());
                 return 0;
@@ -3709,8 +4291,21 @@ void Module::Interface::EndImportTicket(Kernel::HLERequestContext& ctx) {
         rb.Push(ticket_file.Code());
     }
 }
+#else
+void Module::Interface::EndImportTicket(Kernel::HLERequestContext& ctx)
+{
+    IPC::RequestParser rp(ctx);
+    [[maybe_unused]] const auto ticket = rp.PopObject<Kernel::ClientSession>();

-void Module::Interface::BeginImportTitle(Kernel::HLERequestContext& ctx) {
+    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
+    rb.Push(ResultSuccess);
+
+    LOG_WARNING(Service_AM, "(STUBBED) called");
+}
+#endif
+
+void Module::Interface::BeginImportTitle(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const auto media_type = static_cast<FS::MediaType>(rp.Pop<u8>());
     const u64 title_id = rp.Pop<u64>();
@@ -3720,8 +4315,9 @@ void Module::Interface::BeginImportTitle(Kernel::HLERequestContext& ctx) {

     IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);

-    am->importing_title =
-        std::make_shared<CurrentImportingTitle>(Core::System::GetInstance(), title_id, media_type);
+    am->importing_title = std::make_shared<CurrentImportingTitle>(Core::System::GetInstance(),
+                                                                  title_id,
+                                                                  media_type);

     std::scoped_lock lock(am->am_lists_mutex);
     auto entries = am->am_ticket_list.find(title_id);
@@ -3749,7 +4345,8 @@ void Module::Interface::BeginImportTitle(Kernel::HLERequestContext& ctx) {
     rb.Push(ResultSuccess);
 }

-void Module::Interface::StopImportTitle(Kernel::HLERequestContext& ctx) {
+void Module::Interface::StopImportTitle(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     if (!am->importing_title) {
@@ -3770,14 +4367,15 @@ void Module::Interface::StopImportTitle(Kernel::HLERequestContext& ctx) {
     LOG_WARNING(Service_AM, "(STUBBED)");
 }

-void Module::Interface::ResumeImportTitle(Kernel::HLERequestContext& ctx) {
+void Module::Interface::ResumeImportTitle(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     const auto media_type = static_cast<FS::MediaType>(rp.Pop<u8>());
     const u64 title_id = rp.Pop<u64>();

-    if (!am->importing_title || am->importing_title->title_id != title_id ||
-        am->importing_title->media_type != media_type) {
+    if (!am->importing_title || am->importing_title->title_id != title_id
+        || am->importing_title->media_type != media_type) {
         // Not importing a title
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
         rb.Push(ResultUnknown);
@@ -3785,8 +4383,8 @@ void Module::Interface::ResumeImportTitle(Kernel::HLERequestContext& ctx) {
     }

     auto it = am->import_title_contexts.find(am->importing_title->title_id);
-    if (it == am->import_title_contexts.end() ||
-        it->second.state != ImportTitleContextState::RESUMABLE) {
+    if (it == am->import_title_contexts.end()
+        || it->second.state != ImportTitleContextState::RESUMABLE) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
         rb.Push(ResultUnknown);
         return;
@@ -3800,7 +4398,8 @@ void Module::Interface::ResumeImportTitle(Kernel::HLERequestContext& ctx) {
     LOG_WARNING(Service_AM, "(STUBBED) title_id={:016X}", title_id);
 }

-void Module::Interface::CancelImportTitle(Kernel::HLERequestContext& ctx) {
+void Module::Interface::CancelImportTitle(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     if (!am->importing_title) {
@@ -3821,7 +4420,8 @@ void Module::Interface::CancelImportTitle(Kernel::HLERequestContext& ctx) {
     rb.Push(ResultSuccess);
 }

-void Module::Interface::EndImportTitle(Kernel::HLERequestContext& ctx) {
+void Module::Interface::EndImportTitle(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     LOG_DEBUG(Service_AM, "");
@@ -3839,17 +4439,20 @@ void Module::Interface::EndImportTitle(Kernel::HLERequestContext& ctx) {
     }

     am->importing_title->cia_file.SetDone();
+    am->ScanForTitles(am->importing_title->media_type);
     am->importing_title.reset();

     IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
     rb.Push(ResultSuccess);
 }

-void Module::Interface::CommitImportTitles(Kernel::HLERequestContext& ctx) {
+void Module::Interface::CommitImportTitles(Kernel::HLERequestContext& ctx)
+{
     CommitImportTitlesImpl(ctx, false, true);
 }

-void Module::Interface::BeginImportTmd(Kernel::HLERequestContext& ctx) {
+void Module::Interface::BeginImportTmd(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     LOG_DEBUG(Service_AM, "");
@@ -3862,15 +4465,17 @@ void Module::Interface::BeginImportTmd(Kernel::HLERequestContext& ctx) {
     }

     // Create our TMD handle for the app to write to
-    auto file = std::make_shared<Service::FS::File>(
-        am->system.Kernel(), std::make_unique<TMDFile>(am->importing_title), FileSys::Path{});
+    auto file = std::make_shared<Service::FS::File>(am->system.Kernel(),
+                                                    std::make_unique<TMDFile>(am->importing_title),
+                                                    FileSys::Path{});

     IPC::RequestBuilder rb = rp.MakeBuilder(1, 2);
     rb.Push(ResultSuccess); // No error
     rb.PushCopyObjects(file->Connect());
 }

-void Module::Interface::EndImportTmd(Kernel::HLERequestContext& ctx) {
+void Module::Interface::EndImportTmd(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const bool create_context = rp.Pop<bool>();
     const auto tmd = rp.PopObject<Kernel::ClientSession>();
@@ -3879,14 +4484,17 @@ void Module::Interface::EndImportTmd(Kernel::HLERequestContext& ctx) {

     if (!am->importing_title) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidImportState, ErrorModule::AM, ErrorSummary::InvalidState,
+        rb.Push(Result(ErrCodes::InvalidImportState,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
                        ErrorLevel::Permanent));
         return;
     }

     auto tmd_file = GetFileBackendFromSession<TMDFile>(tmd);
     if (tmd_file.Succeeded()) {
-        struct AsyncData {
+        struct AsyncData
+        {
             Service::AM::TMDFile* tmd_file;
             [[maybe_unused]] bool create_context;

@@ -3941,7 +4549,8 @@ void Module::Interface::EndImportTmd(Kernel::HLERequestContext& ctx) {
     }
 }

-void Module::Interface::CreateImportContentContexts(Kernel::HLERequestContext& ctx) {
+void Module::Interface::CreateImportContentContexts(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const u32 content_count = rp.Pop<u32>();
     auto content_buf = rp.PopMappedBuffer();
@@ -3950,12 +4559,15 @@ void Module::Interface::CreateImportContentContexts(Kernel::HLERequestContext& c

     if (!am->importing_title) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidImportState, ErrorModule::AM, ErrorSummary::InvalidState,
+        rb.Push(Result(ErrCodes::InvalidImportState,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
                        ErrorLevel::Permanent));
         return;
     }

-    struct AsyncData {
+    struct AsyncData
+    {
         std::vector<u16> content_indices;

         Result res{0};
@@ -3971,11 +4583,13 @@ void Module::Interface::CreateImportContentContexts(Kernel::HLERequestContext& c
                                                             am->importing_title->title_id);
                 FileSys::TitleMetadata tmd;
                 if (tmd.Load(tmd_path) != Loader::ResultStatus::Success) {
-                    LOG_ERROR(Service_AM, "Couldn't load TMD for title_id={:016X}, mediatype={}",
-                              am->importing_title->title_id, am->importing_title->media_type);
+                    LOG_ERROR(Service_AM,
+                              "Couldn't load TMD for title_id={:016X}, mediatype={}",
+                              am->importing_title->title_id,
+                              am->importing_title->media_type);

-                    async_data->res =
-                        Result(0xFFFFFFFF); // TODO(PabloMK7): Find the right error code
+                    async_data->res = Result(
+                        0xFFFFFFFF); // TODO(PabloMK7): Find the right error code
                     return 0;
                 }
                 am->importing_title->cia_file.ProvideTMDForAdditionalContent(tmd);
@@ -3987,9 +4601,10 @@ void Module::Interface::CreateImportContentContexts(Kernel::HLERequestContext& c
                 if (index > tmd.GetContentCount()) {
                     LOG_ERROR(Service_AM,
                               "Tried to create context for invalid index title_id={:016x} index={}",
-                              am->importing_title->title_id, index);
-                    async_data->res =
-                        Result(0xFFFFFFFF); // TODO(PabloMK7): Find the right error code
+                              am->importing_title->title_id,
+                              index);
+                    async_data->res = Result(
+                        0xFFFFFFFF); // TODO(PabloMK7): Find the right error code
                     return 0;
                 }
                 ImportContentContext content_context;
@@ -4010,7 +4625,8 @@ void Module::Interface::CreateImportContentContexts(Kernel::HLERequestContext& c
         true);
 }

-void Module::Interface::BeginImportContent(Kernel::HLERequestContext& ctx) {
+void Module::Interface::BeginImportContent(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     const u16 content_index = rp.Pop<u16>();
@@ -4038,17 +4654,19 @@ void Module::Interface::BeginImportContent(Kernel::HLERequestContext& ctx) {
     }

     // Create our TMD handle for the app to write to
-    auto file = std::make_shared<Service::FS::File>(
-        am->system.Kernel(),
-        std::make_unique<ContentFile>(am->importing_title, content_index, it->second),
-        FileSys::Path{});
+    auto file = std::make_shared<Service::FS::File>(am->system.Kernel(),
+                                                    std::make_unique<ContentFile>(am->importing_title,
+                                                                                  content_index,
+                                                                                  it->second),
+                                                    FileSys::Path{});

     IPC::RequestBuilder rb = rp.MakeBuilder(1, 2);
     rb.Push(ResultSuccess); // No error
     rb.PushCopyObjects(file->Connect());
 }

-void Module::Interface::ResumeImportContent(Kernel::HLERequestContext& ctx) {
+void Module::Interface::ResumeImportContent(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     const u16 content_index = rp.Pop<u16>();
@@ -4077,12 +4695,14 @@ void Module::Interface::ResumeImportContent(Kernel::HLERequestContext& ctx) {

     it->second.state = ImportTitleContextState::WAITING_FOR_IMPORT;

-    auto content_file =
-        std::make_unique<ContentFile>(am->importing_title, content_index, it->second);
+    auto content_file = std::make_unique<ContentFile>(am->importing_title,
+                                                      content_index,
+                                                      it->second);
     content_file->SetWritten(it->second.current_size);

     // Create our TMD handle for the app to write to
-    auto file = std::make_shared<Service::FS::File>(am->system.Kernel(), std::move(content_file),
+    auto file = std::make_shared<Service::FS::File>(am->system.Kernel(),
+                                                    std::move(content_file),
                                                     FileSys::Path{});

     IPC::RequestBuilder rb = rp.MakeBuilder(3, 2);
@@ -4091,7 +4711,8 @@ void Module::Interface::ResumeImportContent(Kernel::HLERequestContext& ctx) {
     rb.PushCopyObjects(file->Connect());
 }

-void Module::Interface::StopImportContent(Kernel::HLERequestContext& ctx) {
+void Module::Interface::StopImportContent(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const auto content = rp.PopObject<Kernel::ClientSession>();
     IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
@@ -4115,7 +4736,8 @@ void Module::Interface::StopImportContent(Kernel::HLERequestContext& ctx) {
     rb.Push(ResultSuccess);
 }

-void Module::Interface::CancelImportContent(Kernel::HLERequestContext& ctx) {
+void Module::Interface::CancelImportContent(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const auto content = rp.PopObject<Kernel::ClientSession>();
     IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
@@ -4140,7 +4762,8 @@ void Module::Interface::CancelImportContent(Kernel::HLERequestContext& ctx) {
     rb.Push(ResultSuccess);
 }

-void Module::Interface::EndImportContent(Kernel::HLERequestContext& ctx) {
+void Module::Interface::EndImportContent(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const auto content = rp.PopObject<Kernel::ClientSession>();
     IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
@@ -4164,46 +4787,58 @@ void Module::Interface::EndImportContent(Kernel::HLERequestContext& ctx) {
     rb.Push(ResultSuccess);
 }

-void Module::Interface::GetNumCurrentImportContentContexts(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetNumCurrentImportContentContexts(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     if (!am->importing_title) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidImportState, ErrorModule::AM, ErrorSummary::InvalidState,
+        rb.Push(Result(ErrCodes::InvalidImportState,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
                        ErrorLevel::Permanent));
         return;
     }

-    GetNumImportContentContextsImpl(rp, am->importing_title->title_id,
+    GetNumImportContentContextsImpl(rp,
+                                    am->importing_title->title_id,
                                     am->importing_title->media_type);

     LOG_WARNING(Service_AM, "(STUBBED) title_id={:016X}", am->importing_title->title_id);
 }

-void Module::Interface::GetCurrentImportContentContextList(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetCurrentImportContentContextList(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     if (!am->importing_title) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidImportState, ErrorModule::AM, ErrorSummary::InvalidState,
+        rb.Push(Result(ErrCodes::InvalidImportState,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
                        ErrorLevel::Permanent));
         return;
     }

     const u32 list_count = rp.Pop<u32>();

-    GetImportContentContextListImpl(rp, list_count, am->importing_title->title_id,
+    GetImportContentContextListImpl(rp,
+                                    list_count,
+                                    am->importing_title->title_id,
                                     am->importing_title->media_type);

     LOG_WARNING(Service_AM, "(STUBBED) title_id={:016X}", am->importing_title->title_id);
 }

-void Module::Interface::GetCurrentImportContentContexts(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetCurrentImportContentContexts(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     if (!am->importing_title) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidImportState, ErrorModule::AM, ErrorSummary::InvalidState,
+        rb.Push(Result(ErrCodes::InvalidImportState,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
                        ErrorLevel::Permanent));
         return;
     }
@@ -4212,11 +4847,14 @@ void Module::Interface::GetCurrentImportContentContexts(Kernel::HLERequestContex

     LOG_WARNING(Service_AM, "(STUBBED) title_id={:016X}", am->importing_title->title_id);

-    GetImportContentContextsImpl(rp, list_count, am->importing_title->title_id,
+    GetImportContentContextsImpl(rp,
+                                 list_count,
+                                 am->importing_title->title_id,
                                  am->importing_title->media_type);
 }

-void Module::Interface::Sign(Kernel::HLERequestContext& ctx) {
+void Module::Interface::Sign(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     size_t signature_size = rp.Pop<u32>();
     size_t certificate_size = rp.Pop<u32>();
@@ -4235,15 +4873,18 @@ void Module::Interface::Sign(Kernel::HLERequestContext& ctx) {
     FileSys::Certificate& ct_cert = HW::UniqueData::GetCTCert();
     if (!ct_cert.IsValid()) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrorDescription::NotFound, ErrorModule::AM, ErrorSummary::NotFound,
+        rb.Push(Result(ErrorDescription::NotFound,
+                       ErrorModule::AM,
+                       ErrorSummary::NotFound,
                        ErrorLevel::Permanent));
         return;
     }

     FileSys::Certificate ap_cert;
-    std::string new_issuer_str =
-        fmt::format("{}-{}", reinterpret_cast<const char*>(ct_cert.GetIssuer().data()),
-                    reinterpret_cast<const char*>(ct_cert.GetName().data()));
+    std::string new_issuer_str
+        = fmt::format("{}-{}",
+                      reinterpret_cast<const char*>(ct_cert.GetIssuer().data()),
+                      reinterpret_cast<const char*>(ct_cert.GetName().data()));
     std::string new_name_str = fmt::format("AP{:016x}", title_id);

     std::array<u8, 0x40> new_issuer = {0};
@@ -4264,18 +4905,22 @@ void Module::Interface::Sign(Kernel::HLERequestContext& ctx) {
     rb.Push(0);
 }

-template <class Archive>
-void Module::serialize(Archive& ar, const unsigned int) {
+template<class Archive>
+void Module::serialize(Archive& ar, const unsigned int)
+{
     std::scoped_lock lock(am_lists_mutex);
     DEBUG_SERIALIZATION_POINT;
     ar & cia_installing;
     ar & force_old_device_id;
     ar & force_new_device_id;
+    ar & am_title_list;
     ar & system_updater_mutex;
 }
 SERIALIZE_IMPL(Module)

-void Module::Interface::GetDeviceCert(Kernel::HLERequestContext& ctx) {
+#ifdef todotodo
+void Module::Interface::GetDeviceCert(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     [[maybe_unused]] u32 size = rp.Pop<u32>();
     auto buffer = rp.PopMappedBuffer();
@@ -4285,7 +4930,9 @@ void Module::Interface::GetDeviceCert(Kernel::HLERequestContext& ctx) {
     const auto& ct_cert = HW::UniqueData::GetCTCert();
     if (!ct_cert.IsValid()) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrorDescription::NotFound, ErrorModule::AM, ErrorSummary::NotFound,
+        rb.Push(Result(ErrorDescription::NotFound,
+                       ErrorModule::AM,
+                       ErrorSummary::NotFound,
                        ErrorLevel::Permanent));
         return;
     }
@@ -4298,12 +4945,63 @@ void Module::Interface::GetDeviceCert(Kernel::HLERequestContext& ctx) {
     rb.Push(0);
     rb.PushMappedBuffer(buffer);
 }
+#else
+void Module::Interface::GetDeviceCert(Kernel::HLERequestContext& ctx)
+{
+    IPC::RequestParser rp(ctx);
+    [[maybe_unused]] u32 size = rp.Pop<u32>();
+    auto buffer = rp.PopMappedBuffer();

-void Module::Interface::CommitImportTitlesAndUpdateFirmwareAuto(Kernel::HLERequestContext& ctx) {
+    if (!am->ct_cert.IsValid()) {
+        LOG_ERROR(Service_AM, "Invalid or missing CTCert");
+    }
+
+    buffer.Write(&am->ct_cert, 0, std::min(sizeof(CTCert), buffer.GetSize()));
+    IPC::RequestBuilder rb = rp.MakeBuilder(2, 2);
+    rb.Push(ResultSuccess);
+    rb.Push(0);
+    rb.PushMappedBuffer(buffer);
+}
+#endif
+
+std::string Module::GetCTCertPath()
+{
+    return FileUtil::GetUserPath(FileUtil::UserPath::SysDataDir) + "CTCert.bin";
+}
+
+CTCertLoadStatus Module::LoadCTCertFile(CTCert& output)
+{
+    if (output.IsValid()) {
+        return CTCertLoadStatus::Loaded;
+    }
+    std::string file_path = GetCTCertPath();
+    if (!FileUtil::Exists(file_path)) {
+        return CTCertLoadStatus::NotFound;
+    }
+    FileUtil::IOFile file(file_path, "rb");
+    if (!file.IsOpen()) {
+        return CTCertLoadStatus::IOError;
+    }
+    if (file.GetSize() != sizeof(CTCert)) {
+        return CTCertLoadStatus::Invalid;
+    }
+    if (file.ReadBytes(&output, sizeof(CTCert)) != sizeof(CTCert)) {
+        return CTCertLoadStatus::IOError;
+    }
+    if (!output.IsValid()) {
+        output = CTCert();
+        return CTCertLoadStatus::Invalid;
+    }
+    return CTCertLoadStatus::Loaded;
+}
+
+void Module::Interface::CommitImportTitlesAndUpdateFirmwareAuto(Kernel::HLERequestContext& ctx)
+{
     CommitImportTitlesImpl(ctx, true, true);
 }

-void Module::Interface::DeleteTicketId(Kernel::HLERequestContext& ctx) {
+void Module::Interface::DeleteTicketId(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     u64 title_id = rp.Pop<u64>();
     u64 ticket_id = rp.Pop<u64>();
@@ -4320,7 +5018,9 @@ void Module::Interface::DeleteTicketId(Kernel::HLERequestContext& ctx) {
         }
     }
     if (range.first == range.second) {
-        rb.Push(Result(ErrorDescription::AlreadyDone, ErrorModule::AM, ErrorSummary::Success,
+        rb.Push(Result(ErrorDescription::AlreadyDone,
+                       ErrorModule::AM,
+                       ErrorSummary::Success,
                        ErrorLevel::Success));
         return;
     }
@@ -4328,12 +5028,17 @@ void Module::Interface::DeleteTicketId(Kernel::HLERequestContext& ctx) {
     auto path = GetTicketPath(title_id, ticket_id);
     FileUtil::Delete(path);

+#ifdef todotodo
     am->am_ticket_list.erase(it);
+#else
+    am->ScanForTickets();
+#endif

     rb.Push(ResultSuccess);
 }

-void Module::Interface::GetNumTicketIds(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetNumTicketIds(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     u64 title_id = rp.Pop<u64>();

@@ -4348,7 +5053,8 @@ void Module::Interface::GetNumTicketIds(Kernel::HLERequestContext& ctx) {
     rb.Push(count);
 }

-void Module::Interface::GetTicketIdList(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetTicketIdList(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const u32 list_count = rp.Pop<u32>();
     const u64 title_id = rp.Pop<u64>();
@@ -4361,7 +5067,8 @@ void Module::Interface::GetTicketIdList(Kernel::HLERequestContext& ctx) {
     u32 index = 0;
     std::scoped_lock lock(am->am_lists_mutex);
     for (auto [it, rangeEnd] = am->am_ticket_list.equal_range(title_id);
-         it != rangeEnd && index < list_count; index++, it++) {
+         it != rangeEnd && index < list_count;
+         index++, it++) {
         u64 ticket_id = it->second;
         out_buf.Write(&ticket_id, index * sizeof(u64), sizeof(u64));
     }
@@ -4371,7 +5078,8 @@ void Module::Interface::GetTicketIdList(Kernel::HLERequestContext& ctx) {
     rb.Push(index);
 }

-void Module::Interface::GetNumTicketsOfProgram(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetNumTicketsOfProgram(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     u64 title_id = rp.Pop<u64>();

@@ -4386,7 +5094,8 @@ void Module::Interface::GetNumTicketsOfProgram(Kernel::HLERequestContext& ctx) {
     rb.Push(count);
 }

-void Module::Interface::ListTicketInfos(Kernel::HLERequestContext& ctx) {
+void Module::Interface::ListTicketInfos(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     u32 ticket_count = rp.Pop<u32>();
     u64 title_id = rp.Pop<u64>();
@@ -4398,8 +5107,9 @@ void Module::Interface::ListTicketInfos(Kernel::HLERequestContext& ctx) {
     std::scoped_lock lock(am->am_lists_mutex);
     auto range = am->am_ticket_list.equal_range(title_id);
     auto it = range.first;
-    std::advance(it, std::min(static_cast<size_t>(skip),
-                              static_cast<size_t>(std::distance(range.first, range.second))));
+    std::advance(it,
+                 std::min(static_cast<size_t>(skip),
+                          static_cast<size_t>(std::distance(range.first, range.second))));

     u32 written = 0;
     for (; it != range.second && written < ticket_count; it++) {
@@ -4422,7 +5132,8 @@ void Module::Interface::ListTicketInfos(Kernel::HLERequestContext& ctx) {
     rb.Push(written);
 }

-void Module::Interface::GetNumCurrentContentInfos(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetNumCurrentContentInfos(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     LOG_DEBUG(Service_AM, "");
@@ -4439,7 +5150,8 @@ void Module::Interface::GetNumCurrentContentInfos(Kernel::HLERequestContext& ctx
     rb.Push(static_cast<u32>(am->importing_title->cia_file.GetTMD().GetContentCount()));
 }

-void Module::Interface::FindCurrentContentInfos(Kernel::HLERequestContext& ctx) {
+void Module::Interface::FindCurrentContentInfos(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     LOG_DEBUG(Service_AM, "");
@@ -4451,7 +5163,8 @@ void Module::Interface::FindCurrentContentInfos(Kernel::HLERequestContext& ctx)
         return;
     }

-    struct AsyncData {
+    struct AsyncData
+    {
         u32 content_count;
         std::vector<u16_le> content_requested;

@@ -4464,7 +5177,8 @@ void Module::Interface::FindCurrentContentInfos(Kernel::HLERequestContext& ctx)

     auto& content_requested_in = rp.PopMappedBuffer();
     async_data->content_requested.resize(async_data->content_count);
-    content_requested_in.Read(async_data->content_requested.data(), 0,
+    content_requested_in.Read(async_data->content_requested.data(),
+                              0,
                               async_data->content_count * sizeof(u16));
     async_data->content_info_out = &rp.PopMappedBuffer();

@@ -4492,16 +5206,17 @@ void Module::Interface::FindCurrentContentInfos(Kernel::HLERequestContext& ctx)
                 content_info.ownership = ticket.HasRights(index) ? OWNERSHIP_OWNED : 0;

                 if (FileUtil::Exists(GetTitleContentPath(am->importing_title->media_type,
-                                                         am->importing_title->title_id, index))) {
+                                                         am->importing_title->title_id,
+                                                         index))) {
                     bool pending = false;
                     for (auto& import_ctx : am->import_content_contexts) {
-                        if (import_ctx.first == am->importing_title->title_id &&
-                            import_ctx.second.index == index &&
-                            (import_ctx.second.state ==
-                                 ImportTitleContextState::WAITING_FOR_IMPORT ||
-                             import_ctx.second.state ==
-                                 ImportTitleContextState::WAITING_FOR_COMMIT ||
-                             import_ctx.second.state == ImportTitleContextState::RESUMABLE)) {
+                        if (import_ctx.first == am->importing_title->title_id
+                            && import_ctx.second.index == index
+                            && (import_ctx.second.state
+                                    == ImportTitleContextState::WAITING_FOR_IMPORT
+                                || import_ctx.second.state
+                                       == ImportTitleContextState::WAITING_FOR_COMMIT
+                                || import_ctx.second.state == ImportTitleContextState::RESUMABLE)) {
                             LOG_DEBUG(Service_AM, "content pending commit index={:016X}", index);
                             pending = true;
                             break;
@@ -4519,15 +5234,17 @@ void Module::Interface::FindCurrentContentInfos(Kernel::HLERequestContext& ctx)
             IPC::RequestBuilder rb(ctx, 1, 0);
             rb.Push(async_data->res);
             if (async_data->res.IsSuccess()) {
-                async_data->content_info_out->Write(async_data->out_vec.data(), 0,
-                                                    async_data->out_vec.size() *
-                                                        sizeof(ContentInfo));
+                async_data->content_info_out->Write(async_data->out_vec.data(),
+                                                    0,
+                                                    async_data->out_vec.size()
+                                                        * sizeof(ContentInfo));
             }
         },
         true);
 }

-void Module::Interface::ListCurrentContentInfos(Kernel::HLERequestContext& ctx) {
+void Module::Interface::ListCurrentContentInfos(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     LOG_DEBUG(Service_AM, "");
@@ -4539,7 +5256,8 @@ void Module::Interface::ListCurrentContentInfos(Kernel::HLERequestContext& ctx)
         return;
     }

-    struct AsyncData {
+    struct AsyncData
+    {
         u32 content_count;
         u32 start_index;

@@ -4565,20 +5283,21 @@ void Module::Interface::ListCurrentContentInfos(Kernel::HLERequestContext& ctx)
                 content_info.type = tmd.GetContentTypeByIndex(i);
                 content_info.content_id = tmd.GetContentIDByIndex(i);
                 content_info.size = tmd.GetContentSizeByIndex(i);
-                content_info.ownership =
-                    ticket.HasRights(static_cast<u16>(i)) ? OWNERSHIP_OWNED : 0;
+                content_info.ownership = ticket.HasRights(static_cast<u16>(i)) ? OWNERSHIP_OWNED
+                                                                               : 0;

                 if (FileUtil::Exists(GetTitleContentPath(am->importing_title->media_type,
-                                                         am->importing_title->title_id, i))) {
+                                                         am->importing_title->title_id,
+                                                         i))) {
                     bool pending = false;
                     for (auto& import_ctx : am->import_content_contexts) {
-                        if (import_ctx.first == am->importing_title->title_id &&
-                            import_ctx.second.index == i &&
-                            (import_ctx.second.state ==
-                                 ImportTitleContextState::WAITING_FOR_IMPORT ||
-                             import_ctx.second.state ==
-                                 ImportTitleContextState::WAITING_FOR_COMMIT ||
-                             import_ctx.second.state == ImportTitleContextState::RESUMABLE)) {
+                        if (import_ctx.first == am->importing_title->title_id
+                            && import_ctx.second.index == i
+                            && (import_ctx.second.state
+                                    == ImportTitleContextState::WAITING_FOR_IMPORT
+                                || import_ctx.second.state
+                                       == ImportTitleContextState::WAITING_FOR_COMMIT
+                                || import_ctx.second.state == ImportTitleContextState::RESUMABLE)) {
                             LOG_DEBUG(Service_AM, "content pending commit index={:016X}", i);
                             pending = true;
                             break;
@@ -4598,15 +5317,17 @@ void Module::Interface::ListCurrentContentInfos(Kernel::HLERequestContext& ctx)
             rb.Push(async_data->res);
             rb.Push(static_cast<u32>(async_data->out_vec.size()));
             if (async_data->res.IsSuccess()) {
-                async_data->content_info_out->Write(async_data->out_vec.data(), 0,
-                                                    async_data->out_vec.size() *
-                                                        sizeof(ContentInfo));
+                async_data->content_info_out->Write(async_data->out_vec.data(),
+                                                    0,
+                                                    async_data->out_vec.size()
+                                                        * sizeof(ContentInfo));
             }
         },
         true);
 }

-void Module::Interface::CalculateContextRequiredSize(Kernel::HLERequestContext& ctx) {
+void Module::Interface::CalculateContextRequiredSize(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     LOG_DEBUG(Service_AM, "");
@@ -4622,7 +5343,9 @@ void Module::Interface::CalculateContextRequiredSize(Kernel::HLERequestContext&
     std::string tmd_path = GetTitleMetadataPath(media_type, title_id);
     FileSys::TitleMetadata tmd;
     if (tmd.Load(tmd_path) != Loader::ResultStatus::Success) {
-        LOG_ERROR(Service_AM, "Couldn't load TMD for title_id={:016X}, mediatype={}", title_id,
+        LOG_ERROR(Service_AM,
+                  "Couldn't load TMD for title_id={:016X}, mediatype={}",
+                  title_id,
                   media_type);

         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
@@ -4633,7 +5356,8 @@ void Module::Interface::CalculateContextRequiredSize(Kernel::HLERequestContext&
     // Get info for each content index requested
     for (std::size_t i = 0; i < content_count; i++) {
         if (content_requested[i] >= tmd.GetContentCount()) {
-            LOG_ERROR(Service_AM, "Attempted to get info for non-existent content index {:04x}.",
+            LOG_ERROR(Service_AM,
+                      "Attempted to get info for non-existent content index {:04x}.",
                       content_requested[i]);

             IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
@@ -4641,7 +5365,8 @@ void Module::Interface::CalculateContextRequiredSize(Kernel::HLERequestContext&
             return;
         }
         if (!tmd.GetContentOptional(content_requested[i])) {
-            LOG_ERROR(Service_AM, "Attempted to get info for non-optional content index {:04x}.",
+            LOG_ERROR(Service_AM,
+                      "Attempted to get info for non-optional content index {:04x}.",
                       content_requested[i]);

             IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
@@ -4657,7 +5382,8 @@ void Module::Interface::CalculateContextRequiredSize(Kernel::HLERequestContext&
     rb.Push<u64>(size_out);
 }

-void Module::Interface::UpdateImportContentContexts(Kernel::HLERequestContext& ctx) {
+void Module::Interface::UpdateImportContentContexts(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const u32 content_count = rp.Pop<u32>();
     auto content_buf = rp.PopMappedBuffer();
@@ -4671,7 +5397,8 @@ void Module::Interface::UpdateImportContentContexts(Kernel::HLERequestContext& c
     LOG_WARNING(Service_AM, "(STUBBED)");
 }

-void Module::Interface::ExportTicketWrapped(Kernel::HLERequestContext& ctx) {
+void Module::Interface::ExportTicketWrapped(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);

     const u32 ticket_buf_size = rp.Pop<u32>();
@@ -4688,7 +5415,9 @@ void Module::Interface::ExportTicketWrapped(Kernel::HLERequestContext& ctx) {
     u32 tid_high = static_cast<u32>(title_id >> 32);
     if ((tid_high & 0x00048001) == 0x00048001 || tid_high == 0x00040001 || (tid_high & 0x10) != 0) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidTIDInList, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        rb.Push(Result(ErrCodes::InvalidTIDInList,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidArgument,
                        ErrorLevel::Usage));
         return;
     }
@@ -4701,7 +5430,9 @@ void Module::Interface::ExportTicketWrapped(Kernel::HLERequestContext& ctx) {
             break;
     if (it == range.second) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrorDescription::NotFound, ErrorModule::AM, ErrorSummary::InvalidState,
+        rb.Push(Result(ErrorDescription::NotFound,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
                        ErrorLevel::Permanent));
         return;
     }
@@ -4709,7 +5440,9 @@ void Module::Interface::ExportTicketWrapped(Kernel::HLERequestContext& ctx) {
     FileSys::Ticket ticket;
     if (ticket.Load(title_id, ticket_id) != Loader::ResultStatus::Success) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrorDescription::NotFound, ErrorModule::AM, ErrorSummary::InvalidState,
+        rb.Push(Result(ErrorDescription::NotFound,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
                        ErrorLevel::Permanent));
         return;
     }
@@ -4728,10 +5461,10 @@ void Module::Interface::ExportTicketWrapped(Kernel::HLERequestContext& ctx) {

     const auto& wrap_key = HW::RSA::GetTicketWrapSlot();
     u32 padding_len = static_cast<u32>(
-        ((CryptoPP::Integer(wrap_key.GetModulus().data(), wrap_key.GetModulus().size()).BitCount() +
-          7) /
-         8) -
-        (key.size() + iv.size()) - 3);
+        ((CryptoPP::Integer(wrap_key.GetModulus().data(), wrap_key.GetModulus().size()).BitCount()
+          + 7)
+         / 8)
+        - (key.size() + iv.size()) - 3);

     std::vector<u8> m;
     m.reserve(3 + padding_len + (key.size() + iv.size()));
@@ -4745,9 +5478,11 @@ void Module::Interface::ExportTicketWrapped(Kernel::HLERequestContext& ctx) {

     auto rsa_out = wrap_key.ModularExponentiation(m, static_cast<int>(m.size()));

-    ticket_buf.Write(ticket_data.data(), 0,
+    ticket_buf.Write(ticket_data.data(),
+                     0,
                      std::min(static_cast<size_t>(ticket_buf_size), ticket_data.size()));
-    keyiv_buf.Write(rsa_out.data(), 0,
+    keyiv_buf.Write(rsa_out.data(),
+                    0,
                     std::min(static_cast<size_t>(keyiv_buf_size), rsa_out.size()));

     IPC::RequestBuilder rb = rp.MakeBuilder(3, 0);
@@ -4756,24 +5491,30 @@ void Module::Interface::ExportTicketWrapped(Kernel::HLERequestContext& ctx) {
     rb.Push(static_cast<u32>(rsa_out.size()));
 }

-Module::Module(Core::System& _system) : system(_system) {
+Module::Module(Core::System& _system)
+    : system(_system)
+{
     FileUtil::CreateFullPath(GetTicketDirectory());
     ScanForAllTitles();
+    LoadCTCertFile(ct_cert);
     system_updater_mutex = system.Kernel().CreateMutex(false, "AM::SystemUpdaterMutex");
 }

-Module::~Module() {
+Module::~Module()
+{
     stop_scan_flag = true;
 }

-std::shared_ptr<Module> GetModule(Core::System& system) {
+std::shared_ptr<Module> GetModule(Core::System& system)
+{
     auto am = system.ServiceManager().GetService<Service::AM::Module::Interface>("am:u");
     if (!am)
         return nullptr;
     return am->GetModule();
 }

-void InstallInterfaces(Core::System& system) {
+void InstallInterfaces(Core::System& system)
+{
     auto& service_manager = system.ServiceManager();
     auto am = std::make_shared<Module>(system);
     std::make_shared<AM_APP>(am)->InstallAsService(service_manager);
diff --git a/src/core/hle/service/am/am.h b/src/core/hle/service/am/am.h
index 9585f96e3..1a90f584b 100644
--- a/src/core/hle/service/am/am.h
+++ b/src/core/hle/service/am/am.h
@@ -4,16 +4,6 @@

 #pragma once

-#include <array>
-#include <atomic>
-#include <functional>
-#include <future>
-#include <memory>
-#include <mutex>
-#include <string>
-#include <vector>
-#include <boost/serialization/array.hpp>
-#include <boost/serialization/shared_ptr.hpp>
 #include "common/common_types.h"
 #include "common/construct.h"
 #include "common/swap.h"
@@ -25,6 +15,16 @@
 #include "core/hle/result.h"
 #include "core/hle/service/service.h"
 #include "network/artic_base/artic_base_client.h"
+#include <array>
+#include <atomic>
+#include <boost/serialization/array.hpp>
+#include <boost/serialization/shared_ptr.hpp>
+#include <functional>
+#include <future>
+#include <memory>
+#include <mutex>
+#include <string>
+#include <vector>

 namespace Core {
 class System;
@@ -51,6 +51,7 @@ namespace Service::AM {
 namespace ErrCodes {
 enum {
     InvalidImportState = 4,
+    CIACurrentlyInstalling = 4,
     InvalidTID = 31,
     EmptyCIA = 32,
     TryingToUninstallSystemApp = 44,
@@ -87,7 +88,15 @@ enum class ImportTitleContextState : u8 {
     NEEDS_CLEANUP = 6,
 };

-struct ImportTitleContext {
+enum class CTCertLoadStatus {
+    Loaded,
+    NotFound,
+    Invalid,
+    IOError,
+};
+
+struct ImportTitleContext
+{
     u64 title_id;
     u16 version;
     ImportTitleContextState state;
@@ -96,7 +105,8 @@ struct ImportTitleContext {
 };
 static_assert(sizeof(ImportTitleContext) == 0x18, "Invalid ImportTitleContext size");

-struct ImportContentContext {
+struct ImportContentContext
+{
     u32 content_id;
     u16 index;
     ImportTitleContextState state;
@@ -105,6 +115,25 @@ struct ImportContentContext {
 };
 static_assert(sizeof(ImportContentContext) == 0x18, "Invalid ImportContentContext size");

+struct CTCert
+{
+    u32_be signature_type{};
+    std::array<u8, 0x1E> signature_r{};
+    std::array<u8, 0x1E> signature_s{};
+    INSERT_PADDING_BYTES(0x40) {};
+    std::array<char, 0x40> issuer{};
+    u32_be key_type{};
+    std::array<char, 0x40> key_id{};
+    u32_be expiration_time{};
+    std::array<u8, 0x1E> public_key_x{};
+    std::array<u8, 0x1E> public_key_y{};
+    INSERT_PADDING_BYTES(0x3C) {};
+
+    bool IsValid() const;
+    u32 GetDeviceID() const;
+};
+static_assert(sizeof(CTCert) == 0x180, "Invalid CTCert size.");
+
 // Title ID valid length
 constexpr std::size_t TITLE_ID_VALID_LENGTH = 16;

@@ -113,14 +142,13 @@ constexpr u64 TWL_TITLE_ID_FLAG = 0x0000800000000000ULL;
 // Progress callback for InstallCIA, receives bytes written and total bytes
 using ProgressCallback = void(std::size_t, std::size_t);

-class NCCHCryptoFile final {
+class NCCHCryptoFile final
+{
 public:
     NCCHCryptoFile(const std::string& out_file, bool encrypted_content);

     void Write(const u8* buffer, std::size_t length);
-    bool IsError() {
-        return is_error;
-    }
+    bool IsError() { return is_error; }

 private:
     friend class CIAFile;
@@ -136,14 +164,14 @@ private:
     bool header_parsed = false;

     bool is_encrypted = false;
-    std::array<u8, 16>
-        primary_key{}; // for decrypting exheader, exefs header and icon/banner section
+    std::array<u8, 16> primary_key{}; // for decrypting exheader, exefs header and icon/banner section
     std::array<u8, 16> secondary_key{}; // for decrypting romfs and .code section
     std::array<u8, 16> exheader_ctr{};
     std::array<u8, 16> exefs_ctr{};
     std::array<u8, 16> romfs_ctr{};

-    struct CryptoRegion {
+    struct CryptoRegion
+    {
         enum Type {
             EXHEADER = 0,
             EXEFS_HDR = 1,
@@ -168,9 +196,11 @@ class CIAFile;
 void AuthorizeCIAFileDecryption(CIAFile* cia_file, Kernel::HLERequestContext& ctx);

 // A file handled returned for CIAs to be written into and subsequently installed.
-class CIAFile final : public FileSys::FileBackend {
+class CIAFile final : public FileSys::FileBackend
+{
 public:
-    explicit CIAFile(Core::System& system_, Service::FS::MediaType media_type,
+    explicit CIAFile(Core::System& system_,
+                     Service::FS::MediaType media_type,
                      bool from_cdn = false);
     ~CIAFile();

@@ -178,7 +208,10 @@ public:
     Result WriteTicket();
     Result WriteTitleMetadata(std::span<const u8> tmd_data, std::size_t offset);
     ResultVal<std::size_t> WriteContentData(u64 offset, std::size_t length, const u8* buffer);
-    ResultVal<std::size_t> Write(u64 offset, std::size_t length, bool flush, bool update_timestamp,
+    ResultVal<std::size_t> Write(u64 offset,
+                                 std::size_t length,
+                                 bool flush,
+                                 bool update_timestamp,
                                  const u8* buffer) override;

     Result PrepareToImportContent(const FileSys::TitleMetadata& tmd);
@@ -186,21 +219,19 @@ public:
     Result ProvideTMDForAdditionalContent(const FileSys::TitleMetadata& tmd);
     const FileSys::TitleMetadata& GetTMD();
     FileSys::Ticket& GetTicket();
-    CIAInstallState GetCiaInstallState() {
-        return install_state;
-    }
+    CIAInstallState GetCiaInstallState() { return install_state; }

-    ResultVal<std::size_t> WriteContentDataIndexed(u16 content_index, u64 offset,
-                                                   std::size_t length, const u8* buffer);
+    ResultVal<std::size_t> WriteContentDataIndexed(u16 content_index,
+                                                   u64 offset,
+                                                   std::size_t length,
+                                                   const u8* buffer);

     u64 GetSize() const override;
     bool SetSize(u64 size) const override;
     bool Close() override;
     void Flush() const override;

-    void SetDone() {
-        is_done = true;
-    }
+    void SetDone() { is_done = true; }

 private:
     friend void AuthorizeCIAFileDecryption(CIAFile* cia_file, Kernel::HLERequestContext& ctx);
@@ -227,18 +258,24 @@ private:
     std::vector<std::string> content_file_paths;
     u16 current_content_index = -1;
     std::unique_ptr<NCCHCryptoFile> current_content_file;
+    std::vector<FileUtil::IOFile> content_files;
     Service::FS::MediaType media_type;

     class DecryptionState;
     std::unique_ptr<DecryptionState> decryption_state;
 };

-class CurrentImportingTitle {
+class CurrentImportingTitle
+{
 public:
-    explicit CurrentImportingTitle(Core::System& system_, u64 title_id_,
+    explicit CurrentImportingTitle(Core::System& system_,
+                                   u64 title_id_,
                                    Service::FS::MediaType media_type_)
-        : cia_file(system_, media_type_, true), title_id(title_id_), media_type(media_type_),
-          tmd_provided(false) {}
+        : cia_file(system_, media_type_, true)
+        , title_id(title_id_)
+        , media_type(media_type_)
+        , tmd_provided(false)
+    {}

     CIAFile cia_file;
     u64 title_id;
@@ -247,13 +284,17 @@ public:
 };

 // A file handled returned for Tickets to be written into and subsequently installed.
-class TicketFile final : public FileSys::FileBackend {
+class TicketFile final : public FileSys::FileBackend
+{
 public:
     explicit TicketFile();
     ~TicketFile();

     ResultVal<std::size_t> Read(u64 offset, std::size_t length, u8* buffer) const override;
-    ResultVal<std::size_t> Write(u64 offset, std::size_t length, bool flush, bool update_timestamp,
+    ResultVal<std::size_t> Write(u64 offset,
+                                 std::size_t length,
+                                 bool flush,
+                                 bool update_timestamp,
                                  const u8* buffer) override;
     u64 GetSize() const override;
     bool SetSize(u64 size) const override;
@@ -261,12 +302,8 @@ public:
     void Flush() const override;

     Result Commit();
-    u64 GetTitleID() {
-        return title_id;
-    }
-    u64 GetTicketID() {
-        return ticket_id;
-    }
+    u64 GetTitleID() { return title_id; }
+    u64 GetTicketID() { return ticket_id; }

 private:
     u64 written = 0;
@@ -275,14 +312,19 @@ private:
 };

 // A file handled returned for TMDs to be written into and subsequently installed.
-class TMDFile final : public FileSys::FileBackend {
+class TMDFile final : public FileSys::FileBackend
+{
 public:
     explicit TMDFile(const std::shared_ptr<CurrentImportingTitle>& import_context)
-        : importing_title(import_context) {}
+        : importing_title(import_context)
+    {}
     ~TMDFile();

     ResultVal<std::size_t> Read(u64 offset, std::size_t length, u8* buffer) const override;
-    ResultVal<std::size_t> Write(u64 offset, std::size_t length, bool flush, bool update_timestamp,
+    ResultVal<std::size_t> Write(u64 offset,
+                                 std::size_t length,
+                                 bool flush,
+                                 bool update_timestamp,
                                  const u8* buffer) override;
     u64 GetSize() const override;
     bool SetSize(u64 size) const override;
@@ -298,15 +340,23 @@ private:
 };

 // A file handled returned for contents to be written into and subsequently installed.
-class ContentFile final : public FileSys::FileBackend {
+class ContentFile final : public FileSys::FileBackend
+{
 public:
-    explicit ContentFile(const std::shared_ptr<CurrentImportingTitle>& import_context, u16 index_,
+    explicit ContentFile(const std::shared_ptr<CurrentImportingTitle>& import_context,
+                         u16 index_,
                          ImportContentContext& import_context_)
-        : import_context(import_context_), importing_title(import_context), index(index_) {}
+        : import_context(import_context_)
+        , importing_title(import_context)
+        , index(index_)
+    {}
     ~ContentFile();

     ResultVal<std::size_t> Read(u64 offset, std::size_t length, u8* buffer) const override;
-    ResultVal<std::size_t> Write(u64 offset, std::size_t length, bool flush, bool update_timestamp,
+    ResultVal<std::size_t> Write(u64 offset,
+                                 std::size_t length,
+                                 bool flush,
+                                 bool update_timestamp,
                                  const u8* buffer) override;
     u64 GetSize() const override;
     bool SetSize(u64 size) const override;
@@ -315,13 +365,9 @@ public:

     void Cancel(FS::MediaType media_type, u64 title_id);

-    ImportContentContext& GetImportContext() {
-        return import_context;
-    }
+    ImportContentContext& GetImportContext() { return import_context; }

-    void SetWritten(u64 written_) {
-        written = written_;
-    }
+    void SetWritten(u64 written_) { written = written_; }

 private:
     ImportContentContext& import_context;
@@ -340,6 +386,13 @@ private:
 InstallStatus InstallCIA(const std::string& path,
                          std::function<ProgressCallback>&& update_callback = nullptr);

+/**
+ * Downloads and installs title form the Nintendo Update Service.
+ * @param title_id the title_id to download
+ * @returns  whether the install was successful or error code
+ */
+InstallStatus InstallFromNus(u64 title_id, int version = -1);
+
 /**
  * Get the update title ID for a title
  * @param titleId the title ID
@@ -376,7 +429,9 @@ std::string GetTitleMetadataPath(Service::FS::MediaType media_type, u64 tid, boo
  * @param update set true if the incoming TMD should be used instead of the current TMD
  * @returns string path to the .app file
  */
-std::string GetTitleContentPath(FS::MediaType media_type, u64 tid, std::size_t index = 0,
+std::string GetTitleContentPath(FS::MediaType media_type,
+                                u64 tid,
+                                std::size_t index = 0,
                                 bool update = false);

 /**
@@ -402,28 +457,30 @@ std::string GetMediaTitlePath(Service::FS::MediaType media_type);
  */
 Result UninstallProgram(const FS::MediaType media_type, const u64 title_id);

-class Module final {
+class Module final
+{
 public:
     explicit Module(Core::System& system);
     ~Module();

-    class Interface : public ServiceFramework<Interface> {
+    class Interface : public ServiceFramework<Interface>
+    {
     public:
         Interface(std::shared_ptr<Module> am, const char* name, u32 max_session);
         ~Interface();

-        std::shared_ptr<Module> GetModule() const {
-            return am;
-        }
+        std::shared_ptr<Module> GetModule() const { return am; }

-        void UseArticClient(std::shared_ptr<Network::ArticBase::Client>& client) {
+        void UseArticClient(std::shared_ptr<Network::ArticBase::Client>& client)
+        {
             artic_client = client;
         }

     protected:
         void GetProgramInfosImpl(Kernel::HLERequestContext& ctx, bool ignore_platform);

-        void CommitImportTitlesImpl(Kernel::HLERequestContext& ctx, bool is_update_firm_auto,
+        void CommitImportTitlesImpl(Kernel::HLERequestContext& ctx,
+                                    bool is_update_firm_auto,
                                     bool is_titles);

         /**
@@ -634,11 +691,15 @@ public:
          */
         void GetDeviceID(Kernel::HLERequestContext& ctx);

-        void GetNumImportTitleContextsImpl(IPC::RequestParser& rp, FS::MediaType media_type,
-                                           bool include_installing, bool include_finalizing);
+        void GetNumImportTitleContextsImpl(IPC::RequestParser& rp,
+                                           FS::MediaType media_type,
+                                           bool include_installing,
+                                           bool include_finalizing);

-        void GetImportTitleContextListImpl(IPC::RequestParser& rp, FS::MediaType media_type,
-                                           u32 list_count, bool include_installing,
+        void GetImportTitleContextListImpl(IPC::RequestParser& rp,
+                                           FS::MediaType media_type,
+                                           u32 list_count,
+                                           bool include_installing,
                                            bool include_finalizing);

         void GetNumImportTitleContexts(Kernel::HLERequestContext& ctx);
@@ -649,13 +710,18 @@ public:

         void DeleteImportTitleContext(Kernel::HLERequestContext& ctx);

-        void GetNumImportContentContextsImpl(IPC::RequestParser& rp, u64 title_id,
+        void GetNumImportContentContextsImpl(IPC::RequestParser& rp,
+                                             u64 title_id,
                                              FS::MediaType media_type);

-        void GetImportContentContextListImpl(IPC::RequestParser& rp, u32 list_count, u64 title_id,
+        void GetImportContentContextListImpl(IPC::RequestParser& rp,
+                                             u32 list_count,
+                                             u64 title_id,
                                              FS::MediaType media_type);

-        void GetImportContentContextsImpl(IPC::RequestParser& rp, u32 list_count, u64 title_id,
+        void GetImportContentContextsImpl(IPC::RequestParser& rp,
+                                          u32 list_count,
+                                          u64 title_id,
                                           FS::MediaType media_type);

         void GetNumImportContentContexts(Kernel::HLERequestContext& ctx);
@@ -1030,13 +1096,21 @@ public:
         std::shared_ptr<Network::ArticBase::Client> artic_client = nullptr;
     };

-    void ForceO3DSDeviceID() {
-        force_old_device_id = true;
-    }
+    void ForceO3DSDeviceID() { force_old_device_id = true; }
+
+    void ForceN3DSDeviceID() { force_new_device_id = true; }
+
+    /**
+     * Gets the CTCert.bin path in the host filesystem
+     * @returns std::string CTCert.bin path in the host filesystem
+     */
+    static std::string GetCTCertPath();

-    void ForceN3DSDeviceID() {
-        force_new_device_id = true;
-    }
+    /**
+     * Loads the CTCert.bin file from the filesystem.
+     * @returns CTCertLoadStatus indicating the file load status.
+     */
+    static CTCertLoadStatus LoadCTCertFile(CTCert& output);

 private:
     void ScanForTickets();
@@ -1070,11 +1144,12 @@ private:
     std::multimap<u64, u64> am_ticket_list;

     std::shared_ptr<Kernel::Mutex> system_updater_mutex;
+    CTCert ct_cert{};
     std::shared_ptr<CurrentImportingTitle> importing_title;
     std::map<u64, ImportTitleContext> import_title_contexts;
     std::multimap<u64, ImportContentContext> import_content_contexts;

-    template <class Archive>
+    template<class Archive>
     void serialize(Archive& ar, const unsigned int);
     friend class boost::serialization::access;
 };
diff --git a/src/core/loader/ncch.cpp b/src/core/loader/ncch.cpp
index 9ecf64685..d18f7c6a1 100644
--- a/src/core/loader/ncch.cpp
+++ b/src/core/loader/ncch.cpp
@@ -31,6 +31,13 @@

 namespace Loader {

+std::string g_program_id;
+
+std::string getProgramId()
+{
+    return g_program_id;
+}
+
 using namespace Common::Literals;
 static constexpr u64 UPDATE_TID_HIGH = 0x0004000e00000000;

@@ -282,6 +289,7 @@ ResultStatus AppLoader_NCCH::Load(std::shared_ptr<Kernel::Process>& process) {
     std::string program_id{fmt::format("{:016X}", ncch_program_id)};

     LOG_INFO(Loader, "Program ID: {}", program_id);
+    g_program_id = program_id;

     u64 update_tid = (ncch_program_id & 0xFFFFFFFFULL) | UPDATE_TID_HIGH;
     update_ncch.OpenFile(
diff --git a/src/core/loader/ncch.h b/src/core/loader/ncch.h
index 099644b75..86459d05c 100644
--- a/src/core/loader/ncch.h
+++ b/src/core/loader/ncch.h
@@ -12,8 +12,11 @@

 namespace Loader {

+std::string getProgramId();
+
 /// Loads an NCCH file (e.g. from a CCI, or the first NCCH in a CXI)
-class AppLoader_NCCH final : public AppLoader {
+class AppLoader_NCCH final : public AppLoader
+{
 public:
     AppLoader_NCCH(Core::System& system_, FileUtil::IOFile&& file, const std::string& filepath)
         : AppLoader(system_, std::move(file)), base_ncch(filepath), overlay_ncch(&base_ncch),
