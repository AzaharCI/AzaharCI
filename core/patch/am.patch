diff --git a/src/core/hle/service/am/am.cpp b/src/core/hle/service/am/am.cpp
index 8d9ec4bc5..f9c2534c4 100644
--- a/src/core/hle/service/am/am.cpp
+++ b/src/core/hle/service/am/am.cpp
@@ -2,13 +2,7 @@
 // Licensed under GPLv2 or any later version
 // Refer to the license.txt file included.
 
-#include <algorithm>
-#include <cstddef>
-#include <cstring>
-#include <cryptopp/aes.h>
-#include <cryptopp/modes.h>
-#include <fmt/format.h>
-#include <openssl/rand.h>
+#include "core/hle/service/am/am.h"
 #include "common/alignment.h"
 #include "common/archives.h"
 #include "common/common_paths.h"
@@ -29,7 +23,6 @@
 #include "core/hle/kernel/process.h"
 #include "core/hle/kernel/server_session.h"
 #include "core/hle/kernel/session.h"
-#include "core/hle/service/am/am.h"
 #include "core/hle/service/am/am_app.h"
 #include "core/hle/service/am/am_net.h"
 #include "core/hle/service/am/am_sys.h"
@@ -40,8 +33,16 @@
 #include "core/hw/rsa/rsa.h"
 #include "core/hw/unique_data.h"
 #include "core/loader/loader.h"
+#include "core/loader/ncch.h"
 #include "core/loader/smdh.h"
 #include "core/nus_download.h"
+#include <algorithm>
+#include <cryptopp/aes.h>
+#include <cryptopp/modes.h>
+#include <cstddef>
+#include <cstring>
+#include <fmt/format.h>
+#include <openssl/rand.h>
 
 SERIALIZE_EXPORT_IMPL(Service::AM::Module)
 SERVICE_CONSTRUCT_IMPL(Service::AM::Module)
@@ -55,7 +56,8 @@ constexpr u8 VARIATION_SYSTEM = 0x02;
 constexpr u32 TID_HIGH_UPDATE = 0x0004000E;
 constexpr u32 TID_HIGH_DLC = 0x0004008C;
 
-struct TitleInfo {
+struct TitleInfo
+{
     u64_le tid;
     u64_le size;
     u16_le version;
@@ -68,7 +70,8 @@ static_assert(sizeof(TitleInfo) == 0x18, "Title info structure size is wrong");
 constexpr u8 OWNERSHIP_DOWNLOADED = 0x01;
 constexpr u8 OWNERSHIP_OWNED = 0x02;
 
-struct ContentInfo {
+struct ContentInfo
+{
     u16_le index;
     u16_le type;
     u32_le content_id;
@@ -79,7 +82,8 @@ struct ContentInfo {
 
 static_assert(sizeof(ContentInfo) == 0x18, "Content info structure size is wrong");
 
-struct TicketInfo {
+struct TicketInfo
+{
     u64_le title_id;
     u64_le ticket_id;
     u16_le version;
@@ -89,17 +93,52 @@ struct TicketInfo {
 
 static_assert(sizeof(TicketInfo) == 0x18, "Ticket info structure size is wrong");
 
-class CIAFile::DecryptionState {
+bool CTCert::IsValid() const
+{
+    constexpr std::string_view expected_issuer_prod = "Nintendo CA - G3_NintendoCTR2prod";
+    constexpr std::string_view expected_issuer_dev = "Nintendo CA - G3_NintendoCTR2dev";
+    constexpr u32 expected_signature_type = 0x010005;
+
+    return signature_type == expected_signature_type
+           && (std::string(issuer.data()) == expected_issuer_prod
+               || std::string(issuer.data()) == expected_issuer_dev);
+
+    return false;
+}
+
+u32 CTCert::GetDeviceID() const
+{
+    constexpr std::string_view key_id_prefix = "CT";
+
+    const std::string key_id_str(key_id.data());
+    if (key_id_str.starts_with(key_id_prefix)) {
+        const std::string device_id = key_id_str.substr(key_id_prefix.size(),
+                                                        key_id_str.find('-') - key_id_prefix.size());
+        char* end_ptr;
+        const u32 device_id_value = std::strtoul(device_id.c_str(), &end_ptr, 16);
+        if (*end_ptr == '\0') {
+            return device_id_value;
+        }
+    }
+    // Error
+    return 0;
+}
+
+class CIAFile::DecryptionState
+{
 public:
     std::vector<CryptoPP::CBC_Mode<CryptoPP::AES>::Decryption> content;
 };
 
-NCCHCryptoFile::NCCHCryptoFile(const std::string& out_file, bool encrypted_content) {
+NCCHCryptoFile::NCCHCryptoFile(const std::string& out_file, bool encrypted_content)
+{
+#ifdef todotodo
     if (encrypted_content) {
         // A console unique crypto file is used to store the decrypted NCCH file. This is done
         // to prevent Azahar being used as a tool to download easy shareable decrypted contents
         // from the eshop.
-        file = HW::UniqueData::OpenUniqueCryptoFile(out_file, "wb",
+        file = HW::UniqueData::OpenUniqueCryptoFile(out_file,
+                                                    "wb",
                                                     HW::UniqueData::UniqueCryptoFileID::NCCH);
     } else {
         file = std::make_unique<FileUtil::IOFile>(out_file, "wb");
@@ -108,9 +147,13 @@ NCCHCryptoFile::NCCHCryptoFile(const std::string& out_file, bool encrypted_conte
     if (!file->IsOpen()) {
         is_error = true;
     }
+#else
+    file = std::make_unique<FileUtil::IOFile>(out_file, "wb");
+#endif
 }
 
-void NCCHCryptoFile::Write(const u8* buffer, std::size_t length) {
+void NCCHCryptoFile::Write(const u8* buffer, std::size_t length)
+{
     if (is_error)
         return;
 
@@ -155,7 +198,8 @@ void NCCHCryptoFile::Write(const u8* buffer, std::size_t length) {
                 InitKeys();
                 std::array<u8, 16> key_y_primary, key_y_secondary;
 
-                std::copy(ncch_header.signature, ncch_header.signature + key_y_primary.size(),
+                std::copy(ncch_header.signature,
+                          ncch_header.signature + key_y_primary.size(),
                           key_y_primary.begin());
 
                 if (!ncch_header.seed_crypto) {
@@ -163,7 +207,8 @@ void NCCHCryptoFile::Write(const u8* buffer, std::size_t length) {
                 } else {
                     auto opt{FileSys::GetSeed(ncch_header.program_id)};
                     if (!opt.has_value()) {
-                        LOG_ERROR(Service_AM, "Seed for program {:016X} not found",
+                        LOG_ERROR(Service_AM,
+                                  "Seed for program {:016X} not found",
                                   ncch_header.program_id);
                         is_error = true;
                     } else {
@@ -232,7 +277,8 @@ void NCCHCryptoFile::Write(const u8* buffer, std::size_t length) {
                 LOG_DEBUG(Service_AM, "NCCH version 0/2");
                 // In this version, CTR for each section is a magic number prefixed by partition ID
                 // (reverse order)
-                std::reverse_copy(ncch_header.partition_id, ncch_header.partition_id + 8,
+                std::reverse_copy(ncch_header.partition_id,
+                                  ncch_header.partition_id + 8,
                                   exheader_ctr.begin());
                 exefs_ctr = romfs_ctr = exheader_ctr;
                 exheader_ctr[8] = 1;
@@ -242,7 +288,8 @@ void NCCHCryptoFile::Write(const u8* buffer, std::size_t length) {
                 LOG_DEBUG(Service_AM, "NCCH version 1");
                 // In this version, CTR for each section is the section offset prefixed by partition
                 // ID, as if the entire NCCH image is encrypted using a single CTR stream.
-                std::copy(ncch_header.partition_id, ncch_header.partition_id + 8,
+                std::copy(ncch_header.partition_id,
+                          ncch_header.partition_id + 8,
                           exheader_ctr.begin());
                 exefs_ctr = romfs_ctr = exheader_ctr;
                 auto u32ToBEArray = [](u32 value) -> std::array<u8, 4> {
@@ -256,8 +303,7 @@ void NCCHCryptoFile::Write(const u8* buffer, std::size_t length) {
                 auto offset_exheader = u32ToBEArray(0x200); // exheader offset
                 auto offset_exefs = u32ToBEArray(ncch_header.exefs_offset * kBlockSize);
                 auto offset_romfs = u32ToBEArray(ncch_header.romfs_offset * kBlockSize);
-                std::copy(offset_exheader.begin(), offset_exheader.end(),
-                          exheader_ctr.begin() + 12);
+                std::copy(offset_exheader.begin(), offset_exheader.end(), exheader_ctr.begin() + 12);
                 std::copy(offset_exefs.begin(), offset_exefs.end(), exefs_ctr.begin() + 12);
                 std::copy(offset_romfs.begin(), offset_romfs.end(), romfs_ctr.begin() + 12);
             } else {
@@ -351,8 +397,8 @@ void NCCHCryptoFile::Write(const u8* buffer, std::size_t length) {
                     if (reg->type == CryptoRegion::EXHEADER) {
                         key = &primary_key;
                         ctr = &exheader_ctr;
-                    } else if (reg->type == CryptoRegion::EXEFS_HDR ||
-                               reg->type == CryptoRegion::EXEFS_PRI) {
+                    } else if (reg->type == CryptoRegion::EXEFS_HDR
+                               || reg->type == CryptoRegion::EXEFS_PRI) {
                         key = &primary_key;
                         ctr = &exefs_ctr;
                     } else if (reg->type == CryptoRegion::EXEFS_SEC) {
@@ -363,7 +409,8 @@ void NCCHCryptoFile::Write(const u8* buffer, std::size_t length) {
                         ctr = &romfs_ctr;
                     }
 
-                    CryptoPP::CTR_Mode<CryptoPP::AES>::Decryption d(key->data(), key->size(),
+                    CryptoPP::CTR_Mode<CryptoPP::AES>::Decryption d(key->data(),
+                                                                    key->size(),
                                                                     ctr->data());
                     size_t offset = written - reg->seek_from;
                     if (offset != 0) {
@@ -375,24 +422,26 @@ void NCCHCryptoFile::Write(const u8* buffer, std::size_t length) {
                     if (reg->type == CryptoRegion::EXEFS_HDR) {
                         if (exefs_header_written != sizeof(ExeFs_Header)) {
                             memcpy(reinterpret_cast<u8*>(&exefs_header) + exefs_header_written,
-                                   temp.data(), to_write);
+                                   temp.data(),
+                                   to_write);
                             exefs_header_written += to_write;
                         }
-                        if (!exefs_header_processed &&
-                            exefs_header_written == sizeof(ExeFs_Header)) {
+                        if (!exefs_header_processed
+                            && exefs_header_written == sizeof(ExeFs_Header)) {
                             for (int i = 0; i < 8; i++) {
                                 if (exefs_header.section[i].size != 0) {
-                                    bool is_primary =
-                                        memcmp(exefs_header.section[i].name, "icon", 4) == 0 ||
-                                        memcmp(exefs_header.section[i].name, "banner", 6) == 0;
-                                    regions.push_back(CryptoRegion{
-                                        .type = is_primary ? CryptoRegion::EXEFS_PRI
-                                                           : CryptoRegion::EXEFS_SEC,
-                                        .offset = reg->offset + sizeof(ExeFs_Header) +
-                                                  exefs_header.section[i].offset,
-                                        .size =
-                                            Common::AlignUp(exefs_header.section[i].size, 0x200),
-                                        .seek_from = reg->offset});
+                                    bool is_primary
+                                        = memcmp(exefs_header.section[i].name, "icon", 4) == 0
+                                          || memcmp(exefs_header.section[i].name, "banner", 6) == 0;
+                                    regions.push_back(
+                                        CryptoRegion{.type = is_primary ? CryptoRegion::EXEFS_PRI
+                                                                        : CryptoRegion::EXEFS_SEC,
+                                                     .offset = reg->offset + sizeof(ExeFs_Header)
+                                                               + exefs_header.section[i].offset,
+                                                     .size
+                                                     = Common::AlignUp(exefs_header.section[i].size,
+                                                                       0x200),
+                                                     .seek_from = reg->offset});
                                 }
                             }
                             exefs_header_processed = true;
@@ -409,19 +458,31 @@ void NCCHCryptoFile::Write(const u8* buffer, std::size_t length) {
     }
 }
 
-void AuthorizeCIAFileDecryption(CIAFile* cia_file, Kernel::HLERequestContext& ctx) {
+void AuthorizeCIAFileDecryption(CIAFile* cia_file, Kernel::HLERequestContext& ctx)
+{
     u64 caller_tid = ctx.ClientThread()->owner_process.lock()->codeset->program_id;
-    if (Common::Hacks::hack_manager.GetHackAllowMode(
-            Common::Hacks::HackType::DECRYPTION_AUTHORIZED, caller_tid,
-            Common::Hacks::HackAllowMode::DISALLOW) == Common::Hacks::HackAllowMode::ALLOW) {
+    if (Common::Hacks::hack_manager.GetHackAllowMode(Common::Hacks::HackType::DECRYPTION_AUTHORIZED,
+                                                     caller_tid,
+                                                     Common::Hacks::HackAllowMode::DISALLOW)
+        == Common::Hacks::HackAllowMode::ALLOW) {
         LOG_INFO(Service_AM, "Authorized encrypted CIA installation.");
         cia_file->decryption_authorized = true;
     }
 }
 
 CIAFile::CIAFile(Core::System& system_, Service::FS::MediaType media_type, bool from_cdn_)
-    : system(system_), from_cdn(from_cdn_), decryption_authorized(false), media_type(media_type),
-      decryption_state(std::make_unique<DecryptionState>()) {
+    : system(system_)
+    , from_cdn(from_cdn_)
+    , decryption_authorized(true)
+    , media_type(media_type)
+    , decryption_state(std::make_unique<DecryptionState>())
+{
+    if(Loader::getProgramId() == "0004000003070C00")
+    {
+        LOG_ERROR(Service_AM, "Avoiding Decryption");
+        decryption_authorized = false;
+    }
+
     // If data is being installing from CDN, provide a fake header to the container so that
     // it's not uninitialized.
     if (from_cdn) {
@@ -448,16 +509,13 @@ ResultVal<std::size_t> CIAFile::Read(u64 offset, std::size_t length, u8* buffer)
     return length;
 }
 
-CIAFile::InstallResult CIAFile::WriteTicket() {
-    InstallResult res{};
-    res.type = InstallResult::Type::TIK;
+Result CIAFile::WriteTicket() {
     auto load_result = container.LoadTicket(data, container.GetTicketOffset());
     if (load_result != Loader::ResultStatus::Success) {
         LOG_ERROR(Service_AM, "Could not read ticket from CIA.");
         // TODO: Correct result code.
-        res.result = {ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
-                      ErrorLevel::Permanent};
-        return res;
+        return {ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
+                ErrorLevel::Permanent};
     }
 
     const auto& ticket = container.GetTicket();
@@ -469,30 +527,23 @@ CIAFile::InstallResult CIAFile::WriteTicket() {
     FileUtil::CreateFullPath(ticket_folder);
 
     // Save ticket
-    res.install_full_path = ticket_path;
     if (ticket.Save(ticket_path) != Loader::ResultStatus::Success) {
         LOG_ERROR(Service_AM, "Failed to install ticket file from CIA.");
         // TODO: Correct result code.
-        res.result = FileSys::ResultFileNotFound;
-        return res;
+        return FileSys::ResultFileNotFound;
     }
 
     install_state = CIAInstallState::TicketLoaded;
-    res.result = ResultSuccess;
-    return res;
+    return ResultSuccess;
 }
 
-CIAFile::InstallResult CIAFile::WriteTitleMetadata(std::span<const u8> tmd_data,
-                                                   std::size_t offset) {
-    InstallResult res{};
-    res.type = InstallResult::Type::TMD;
+Result CIAFile::WriteTitleMetadata(std::span<const u8> tmd_data, std::size_t offset) {
     auto load_result = container.LoadTitleMetadata(tmd_data, offset);
     if (load_result != Loader::ResultStatus::Success) {
         LOG_ERROR(Service_AM, "Could not read title metadata.");
         // TODO: Correct result code.
-        res.result = {ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
-                      ErrorLevel::Permanent};
-        return res;
+        return {ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
+                ErrorLevel::Permanent};
     }
 
     FileSys::TitleMetadata tmd = container.GetTitleMetadata();
@@ -513,23 +564,22 @@ CIAFile::InstallResult CIAFile::WriteTitleMetadata(std::span<const u8> tmd_data,
     FileUtil::CreateFullPath(tmd_folder);
 
     // Save TMD so that we can start getting new .app paths
-    res.install_full_path = tmd_path;
     if (tmd.Save(tmd_path) != Loader::ResultStatus::Success) {
         LOG_ERROR(Service_AM, "Failed to install title metadata file from CIA.");
         // TODO: Correct result code.
-        res.result = FileSys::ResultFileNotFound;
-        return res;
+        return FileSys::ResultFileNotFound;
     }
 
-    res.result = PrepareToImportContent(tmd);
-    return res;
+    return PrepareToImportContent(tmd);
 }
 
-ResultVal<std::size_t> CIAFile::WriteContentData(u64 offset, std::size_t length, const u8* buffer) {
+ResultVal<std::size_t> CIAFile::WriteContentData(u64 offset, std::size_t length, const u8* buffer)
+{
     // Data is not being buffered, so we have to keep track of how much of each <ID>.app
     // has been written since we might get a written buffer which contains multiple .app
     // contents or only part of a larger .app's contents.
     const u64 offset_max = offset + length;
+    bool success = true;
     for (std::size_t i = 0; i < content_written.size(); i++) {
         if (content_written[i] < container.GetContentSize(i)) {
             // The size, minimum unwritten offset, and maximum unwritten offset of this content
@@ -546,63 +596,55 @@ ResultVal<std::size_t> CIAFile::WriteContentData(u64 offset, std::size_t length,
             // Figure out how much of this content ID we have just recieved/can write out
             const u64 available_to_write = std::min(offset_max, range_max) - range_min;
 
-            // Since the incoming TMD has already been written, we can use GetTitleContentPath
-            // to get the content paths to write to.
+// Since the incoming TMD has already been written, we can use GetTitleContentPath
+// to get the content paths to write to.
+#ifdef todotodo
             const FileSys::TitleMetadata& tmd = container.GetTitleMetadata();
             if (i != current_content_index) {
-                // A previous content file was being installed, save it first
-                if (current_content_install_result.type == InstallResult::Type::APP) {
-                    install_results.push_back(current_content_install_result);
-                }
                 current_content_index = static_cast<u16>(i);
-                current_content_file =
-                    std::make_unique<NCCHCryptoFile>(content_file_paths[i], decryption_authorized);
+                current_content_file = std::make_unique<NCCHCryptoFile>(content_file_paths[i],
+                                                                        decryption_authorized);
                 current_content_file->decryption_authorized = decryption_authorized;
-
-                current_content_install_result.type = InstallResult::Type::APP;
-                current_content_install_result.install_full_path = content_file_paths[i];
-                current_content_install_result.result = ResultSuccess;
             }
             auto& file = *current_content_file;
 
+#else
+            FileSys::TitleMetadata tmd = container.GetTitleMetadata();
+            auto& file = content_files[i];
+#endif
             std::vector<u8> temp(buffer + (range_min - offset),
                                  buffer + (range_min - offset) + available_to_write);
 
             if ((tmd.GetContentTypeByIndex(i) & FileSys::TMDContentTypeFlag::Encrypted) != 0) {
                 if (!decryption_authorized) {
                     LOG_ERROR(Service_AM, "Blocked unauthorized encrypted CIA installation.");
-                    current_content_install_result.result =
-                        Result(ErrorDescription::NotAuthorized, ErrorModule::AM,
-                               ErrorSummary::InvalidState, ErrorLevel::Permanent);
-                    install_results.push_back(current_content_install_result);
-                    return current_content_install_result.result;
+                    return Result(ErrorDescription::NotAuthorized,
+                                  ErrorModule::AM,
+                                  ErrorSummary::InvalidState,
+                                  ErrorLevel::Permanent);
                 }
                 decryption_state->content[i].ProcessData(temp.data(), temp.data(), temp.size());
             }
 
-            file.Write(temp.data(), temp.size());
-            if (file.IsError()) {
-                // This can never happen in real HW
-                current_content_install_result.result =
-                    Result(ErrCodes::InvalidImportState, ErrorModule::AM,
-                           ErrorSummary::InvalidState, ErrorLevel::Permanent);
-                install_results.push_back(current_content_install_result);
-                return current_content_install_result.result;
-            }
+            file.WriteBytes(temp.data(), temp.size());
 
             // Keep tabs on how much of this content ID has been written so new range_min
             // values can be calculated.
             content_written[i] += available_to_write;
-            LOG_DEBUG(Service_AM, "Wrote {} to content {}, total {}", available_to_write, i,
+            LOG_DEBUG(Service_AM,
+                      "Wrote {} to content {}, total {}",
+                      available_to_write,
+                      i,
                       content_written[i]);
         }
     }
 
-    return length;
+    return success ? length : 0;
 }
 
-ResultVal<std::size_t> CIAFile::Write(u64 offset, std::size_t length, bool flush,
-                                      bool update_timestamp, const u8* buffer) {
+ResultVal<std::size_t> CIAFile::Write(
+    u64 offset, std::size_t length, bool flush, bool update_timestamp, const u8* buffer)
+{
     written += length;
 
     // TODO(shinyquagsire23): Can we assume that things will only be written in sequence?
@@ -615,8 +657,8 @@ ResultVal<std::size_t> CIAFile::Write(u64 offset, std::size_t length, bool flush
     // written and what we have been able to pick up.
     if (install_state == CIAInstallState::InstallStarted) {
         std::size_t buf_copy_size = std::min(length, FileSys::CIA_HEADER_SIZE);
-        std::size_t buf_max_size =
-            std::min(static_cast<std::size_t>(offset + length), FileSys::CIA_HEADER_SIZE);
+        std::size_t buf_max_size = std::min(static_cast<std::size_t>(offset + length),
+                                            FileSys::CIA_HEADER_SIZE);
         data.resize(buf_max_size);
         std::memcpy(data.data() + offset, buffer, buf_copy_size);
 
@@ -639,9 +681,10 @@ ResultVal<std::size_t> CIAFile::Write(u64 offset, std::size_t length, bool flush
         std::size_t buf_loaded = data.size();
         std::size_t copy_offset = std::max(static_cast<std::size_t>(offset), buf_loaded);
         std::size_t buf_offset = buf_loaded - offset;
-        std::size_t buf_copy_size =
-            std::min(length, static_cast<std::size_t>(container.GetContentOffset() - offset)) -
-            buf_offset;
+        std::size_t buf_copy_size = std::min(length,
+                                             static_cast<std::size_t>(container.GetContentOffset()
+                                                                      - offset))
+                                    - buf_offset;
         std::size_t buf_max_size = std::min(offset + length, container.GetContentOffset());
         data.resize(buf_max_size);
         std::memcpy(data.data() + copy_offset, buffer + buf_offset, buf_copy_size);
@@ -650,16 +693,14 @@ ResultVal<std::size_t> CIAFile::Write(u64 offset, std::size_t length, bool flush
     // The end of our TMD is at the beginning of Content data, so ensure we have that much
     // buffered before trying to parse.
     if (written >= container.GetContentOffset() && install_state != CIAInstallState::TMDLoaded) {
-        InstallResult result = WriteTicket();
-        install_results.push_back(result);
-        if (result.result.IsError()) {
-            return result.result;
+        auto result = WriteTicket();
+        if (result.IsError()) {
+            return result;
         }
 
         result = WriteTitleMetadata(data, container.GetTitleMetadataOffset());
-        install_results.push_back(result);
-        if (result.result.IsError()) {
-            return result.result;
+        if (result.IsError()) {
+            return result;
         }
     }
 
@@ -671,45 +712,62 @@ ResultVal<std::size_t> CIAFile::Write(u64 offset, std::size_t length, bool flush
     // From this point forward, data will no longer be buffered in data
     auto result = WriteContentData(offset, length, buffer);
     if (result.Failed()) {
-        current_content_install_result.type = InstallResult::Type::NONE;
         return result;
     }
 
     return length;
 }
 
-Result CIAFile::PrepareToImportContent(const FileSys::TitleMetadata& tmd) {
-
+Result CIAFile::PrepareToImportContent(const FileSys::TitleMetadata& tmd)
+{
     // Create any other .app folders which may not exist yet
     std::string app_folder;
-    auto main_content_path = GetTitleContentPath(media_type, tmd.GetTitleID(),
-                                                 FileSys::TMDContentIndex::Main, is_update);
+    auto main_content_path = GetTitleContentPath(media_type,
+                                                 tmd.GetTitleID(),
+                                                 FileSys::TMDContentIndex::Main,
+                                                 is_update);
     Common::SplitPath(main_content_path, &app_folder, nullptr, nullptr);
     FileUtil::CreateFullPath(app_folder);
 
     auto content_count = container.GetTitleMetadata().GetContentCount();
     content_written.resize(content_count);
 
+#ifdef todotodo
     current_content_file.reset();
     current_content_index = -1;
     content_file_paths.clear();
+#else
+    content_files.clear();
+#endif
     for (std::size_t i = 0; i < content_count; i++) {
         auto path = GetTitleContentPath(media_type, tmd.GetTitleID(), i, is_update);
+#ifdef todotodo
         content_file_paths.emplace_back(path);
+#else
+        auto& file = content_files.emplace_back(path, "wb");
+        if (!file.IsOpen()) {
+            LOG_ERROR(Service_AM, "Could not open output file '{}' for content {}.", path, i);
+            // TODO: Correct error code.
+            return FileSys::ResultFileNotFound;
+        }
+#endif
     }
 
     if (container.GetTitleMetadata().HasEncryptedContent(from_cdn ? nullptr
                                                                   : container.GetHeader())) {
         if (!decryption_authorized) {
             LOG_ERROR(Service_AM, "Blocked unauthorized encrypted CIA installation.");
-            return {ErrorDescription::NotAuthorized, ErrorModule::AM, ErrorSummary::InvalidState,
+            return {ErrorDescription::NotAuthorized,
+                    ErrorModule::AM,
+                    ErrorSummary::InvalidState,
                     ErrorLevel::Permanent};
         } else {
             if (auto title_key = container.GetTicket().GetTitleKey()) {
                 decryption_state->content.resize(content_count);
                 for (std::size_t i = 0; i < content_count; ++i) {
                     auto ctr = tmd.GetContentCTRByIndex(i);
-                    decryption_state->content[i].SetKeyWithIV(title_key->data(), title_key->size(),
+                    decryption_state->content[i].SetKeyWithIV(title_key->data(),
+                                                              title_key->size(),
                                                               ctr.data());
                 }
             } else {
@@ -728,7 +786,8 @@ Result CIAFile::PrepareToImportContent(const FileSys::TitleMetadata& tmd) {
     return ResultSuccess;
 }
 
-Result CIAFile::ProvideTicket(const FileSys::Ticket& ticket) {
+Result CIAFile::ProvideTicket(const FileSys::Ticket& ticket)
+{
     // There is no need to write the ticket to nand, as that will
     ASSERT_MSG(from_cdn, "This method should only be used when installing from CDN");
 
@@ -736,7 +795,9 @@ Result CIAFile::ProvideTicket(const FileSys::Ticket& ticket) {
     if (load_result != Loader::ResultStatus::Success) {
         LOG_ERROR(Service_AM, "Could not read ticket from CIA.");
         // TODO: Correct result code.
-        return {ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        return {ErrCodes::InvalidCIAHeader,
+                ErrorModule::AM,
+                ErrorSummary::InvalidArgument,
                 ErrorLevel::Permanent};
     }
 
@@ -744,13 +805,16 @@ Result CIAFile::ProvideTicket(const FileSys::Ticket& ticket) {
     return ResultSuccess;
 }
 
-Result CIAFile::ProvideTMDForAdditionalContent(const FileSys::TitleMetadata& tmd) {
+Result CIAFile::ProvideTMDForAdditionalContent(const FileSys::TitleMetadata& tmd)
+{
     ASSERT_MSG(from_cdn, "This method should only be used when installing from CDN");
 
     if (install_state != CIAInstallState::TicketLoaded) {
         LOG_ERROR(Service_AM, "Ticket not provided yet");
         // TODO: Correct result code.
-        return {ErrCodes::InvalidImportState, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        return {ErrCodes::InvalidImportState,
+                ErrorModule::AM,
+                ErrorSummary::InvalidArgument,
                 ErrorLevel::Permanent};
     }
 
@@ -758,7 +822,9 @@ Result CIAFile::ProvideTMDForAdditionalContent(const FileSys::TitleMetadata& tmd
     if (load_result != Loader::ResultStatus::Success) {
         LOG_ERROR(Service_AM, "Could not read ticket from CIA.");
         // TODO: Correct result code.
-        return {ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        return {ErrCodes::InvalidCIAHeader,
+                ErrorModule::AM,
+                ErrorSummary::InvalidArgument,
                 ErrorLevel::Permanent};
     }
 
@@ -767,38 +833,33 @@ Result CIAFile::ProvideTMDForAdditionalContent(const FileSys::TitleMetadata& tmd
     return PrepareToImportContent(container.GetTitleMetadata());
 }
 
-const FileSys::TitleMetadata& CIAFile::GetTMD() {
+const FileSys::TitleMetadata& CIAFile::GetTMD()
+{
     return container.GetTitleMetadata();
 }
 
-FileSys::Ticket& CIAFile::GetTicket() {
+FileSys::Ticket& CIAFile::GetTicket()
+{
     return container.GetTicket();
 }
 
-ResultVal<std::size_t> CIAFile::WriteContentDataIndexed(u16 content_index, u64 offset,
-                                                        std::size_t length, const u8* buffer) {
-
+ResultVal<std::size_t> CIAFile::WriteContentDataIndexed(u16 content_index,
+                                                        u64 offset,
+                                                        std::size_t length,
+                                                        const u8* buffer)
+{
     ASSERT_MSG(from_cdn, "This method should only be used when installing from CDN");
 
     const FileSys::TitleMetadata& tmd = container.GetTitleMetadata();
 
-    u64 remaining_to_write =
-        tmd.GetContentSizeByIndex(content_index) - content_written[content_index];
+    u64 remaining_to_write = tmd.GetContentSizeByIndex(content_index)
+                             - content_written[content_index];
 
     if (content_index != current_content_index) {
-        // A previous content file was being installed, save it first
-        if (current_content_install_result.type == InstallResult::Type::APP) {
-            install_results.push_back(current_content_install_result);
-        }
-
         current_content_index = content_index;
         current_content_file = std::make_unique<NCCHCryptoFile>(content_file_paths[content_index],
                                                                 decryption_authorized);
         current_content_file->decryption_authorized = decryption_authorized;
-
-        current_content_install_result.type = InstallResult::Type::APP;
-        current_content_install_result.install_full_path = content_file_paths[content_index];
-        current_content_install_result.result = ResultSuccess;
     }
     auto& file = *current_content_file;
 
@@ -807,60 +868,53 @@ ResultVal<std::size_t> CIAFile::WriteContentDataIndexed(u16 content_index, u64 o
     if ((tmd.GetContentTypeByIndex(content_index) & FileSys::TMDContentTypeFlag::Encrypted) != 0) {
         if (!decryption_authorized) {
             LOG_ERROR(Service_AM, "Blocked unauthorized encrypted CIA installation.");
-            current_content_install_result.result =
-                Result(ErrorDescription::NotAuthorized, ErrorModule::AM, ErrorSummary::InvalidState,
-                       ErrorLevel::Permanent);
-            install_results.push_back(current_content_install_result);
-            return current_content_install_result.result;
+            return Result(ErrorDescription::NotAuthorized,
+                          ErrorModule::AM,
+                          ErrorSummary::InvalidState,
+                          ErrorLevel::Permanent);
         }
         decryption_state->content[content_index].ProcessData(temp.data(), temp.data(), temp.size());
     }
 
     file.Write(temp.data(), temp.size());
-    if (file.IsError()) {
-        // This can never happen in real HW
-        current_content_install_result.result =
-            Result(ErrCodes::InvalidImportState, ErrorModule::AM, ErrorSummary::InvalidState,
-                   ErrorLevel::Permanent);
-        install_results.push_back(current_content_install_result);
-        return current_content_install_result.result;
-    }
+    bool success = !file.IsError();
 
     content_written[content_index] += temp.size();
-    LOG_DEBUG(Service_AM, "Wrote {} to content {}, total {}", temp.size(), content_index,
+    LOG_DEBUG(Service_AM,
+              "Wrote {} to content {}, total {}",
+              temp.size(),
+              content_index,
               content_written[content_index]);
 
-    return temp.size();
+    return success ? temp.size() : 0;
 }
 
-u64 CIAFile::GetSize() const {
+u64 CIAFile::GetSize() const
+{
     return written;
 }
 
-bool CIAFile::SetSize(u64 size) const {
+bool CIAFile::SetSize(u64 size) const
+{
     return false;
 }
 
-bool CIAFile::Close() {
+bool CIAFile::Close()
+{
     if (is_closed)
         return true;
     is_closed = true;
 
-    // Commit last pending install result
-    if (current_content_install_result.type != InstallResult::Type::NONE) {
-        install_results.push_back(current_content_install_result);
-        current_content_install_result.type = InstallResult::Type::NONE;
-    }
-
-    bool complete =
-        from_cdn ? is_done
-                 : (install_state >= CIAInstallState::TMDLoaded &&
-                    content_written.size() == container.GetTitleMetadata().GetContentCount() &&
-                    std::all_of(content_written.begin(), content_written.end(),
-                                [this, i = 0](auto& bytes_written) mutable {
-                                    return bytes_written >=
-                                           container.GetContentSize(static_cast<u16>(i++));
-                                }));
+    bool complete = from_cdn ? is_done
+                             : (install_state >= CIAInstallState::TMDLoaded
+                                && content_written.size()
+                                       == container.GetTitleMetadata().GetContentCount()
+                                && std::all_of(content_written.begin(),
+                                               content_written.end(),
+                                               [this, i = 0](auto& bytes_written) mutable {
+                                                   return bytes_written >= container.GetContentSize(
+                                                              static_cast<u16>(i++));
+                                               }));
 
     // Install aborted
     if (!complete) {
@@ -873,17 +927,12 @@ bool CIAFile::Close() {
     }
 
     // Clean up older content data if we installed newer content on top
-    std::string old_tmd_path =
-        GetTitleMetadataPath(media_type, container.GetTitleMetadata().GetTitleID(), false);
-    std::string new_tmd_path = old_tmd_path;
-
-    for (auto result : install_results) {
-        if (result.type == InstallResult::Type::TMD && result.result.IsSuccess()) {
-            new_tmd_path = result.install_full_path;
-            break;
-        }
-    }
-
+    std::string old_tmd_path = GetTitleMetadataPath(media_type,
+                                                    container.GetTitleMetadata().GetTitleID(),
+                                                    false);
+    std::string new_tmd_path = GetTitleMetadataPath(media_type,
+                                                    container.GetTitleMetadata().GetTitleID(),
+                                                    true);
     if (FileUtil::Exists(new_tmd_path) && old_tmd_path != new_tmd_path) {
         FileSys::TitleMetadata old_tmd;
         FileSys::TitleMetadata new_tmd;
@@ -897,8 +946,8 @@ bool CIAFile::Close() {
         for (std::size_t old_index = 0; old_index < old_tmd.GetContentCount(); old_index++) {
             bool abort = false;
             for (std::size_t new_index = 0; new_index < new_tmd.GetContentCount(); new_index++) {
-                if (old_tmd.GetContentIDByIndex(old_index) ==
-                    new_tmd.GetContentIDByIndex(new_index)) {
+                if (old_tmd.GetContentIDByIndex(old_index)
+                    == new_tmd.GetContentIDByIndex(new_index)) {
                     abort = true;
                 }
             }
@@ -909,8 +958,7 @@ bool CIAFile::Close() {
             // If the file to delete is the current launched rom, signal the system to delete
             // the current rom instead of deleting it now, once all the handles to the file
             // are closed.
-            std::string to_delete =
-                GetTitleContentPath(media_type, old_tmd.GetTitleID(), old_index);
+            std::string to_delete = GetTitleContentPath(media_type, old_tmd.GetTitleID(), old_index);
             if (!system.IsPoweredOn() || !system.SetSelfDelete(to_delete)) {
                 FileUtil::Delete(to_delete);
             }
@@ -925,38 +973,51 @@ void CIAFile::Flush() const {}
 
 TicketFile::TicketFile() {}
 
-TicketFile::~TicketFile() {
+TicketFile::~TicketFile()
+{
     Close();
 }
 
-ResultVal<std::size_t> TicketFile::Read(u64 offset, std::size_t length, u8* buffer) const {
+ResultVal<std::size_t> TicketFile::Read(u64 offset, std::size_t length, u8* buffer) const
+{
     UNIMPLEMENTED();
     return length;
 }
 
-ResultVal<std::size_t> TicketFile::Write(u64 offset, std::size_t length, bool flush,
-                                         bool update_timestamp, const u8* buffer) {
+ResultVal<std::size_t> TicketFile::Write(
+    u64 offset, std::size_t length, bool flush, bool update_timestamp, const u8* buffer)
+{
     written += length;
     data.resize(written);
     std::memcpy(data.data() + offset, buffer, length);
     return length;
 }
 
-u64 TicketFile::GetSize() const {
+u64 TicketFile::GetSize() const
+{
     return written;
 }
 
-bool TicketFile::SetSize(u64 size) const {
+bool TicketFile::SetSize(u64 size) const
+{
     return false;
 }
 
-bool TicketFile::Close() {
+bool TicketFile::Close()
+{
+    FileSys::Ticket ticket;
+    if (ticket.Load(data, 0) == Loader::ResultStatus::Success) {
+        LOG_WARNING(Service_AM, "Discarding ticket for {:#016X}.", ticket.GetTitleID());
+    } else {
+        LOG_ERROR(Service_AM, "Invalid ticket provided to TicketFile.");
+    }
     return true;
 }
 
 void TicketFile::Flush() const {}
 
-Result TicketFile::Commit() {
+Result TicketFile::Commit()
+{
     FileSys::Ticket ticket;
     if (ticket.Load(data, 0) == Loader::ResultStatus::Success) {
         if (ticket.DoTitlekeyFixup() != Loader::ResultStatus::Success) {
@@ -968,6 +1029,11 @@ Result TicketFile::Commit() {
         ticket_id = ticket.GetTicketID();
         const auto ticket_path = GetTicketPath(ticket.GetTitleID(), ticket.GetTicketID());
 
+        // Create ticket folder if it does not exist
+        std::string ticket_folder;
+        Common::SplitPath(ticket_path, &ticket_folder, nullptr, nullptr);
+        FileUtil::CreateFullPath(ticket_folder);
+
         // Save ticket
         if (ticket.Save(ticket_path) != Loader::ResultStatus::Success) {
             LOG_ERROR(Service_AM, "Failed to install ticket provided to TicketFile.");
@@ -980,52 +1046,62 @@ Result TicketFile::Commit() {
     }
 }
 
-TMDFile::~TMDFile() {
+TMDFile::~TMDFile()
+{
     Close();
 }
 
-ResultVal<std::size_t> TMDFile::Read(u64 offset, std::size_t length, u8* buffer) const {
+ResultVal<std::size_t> TMDFile::Read(u64 offset, std::size_t length, u8* buffer) const
+{
     UNIMPLEMENTED();
     return length;
 }
 
-ResultVal<std::size_t> TMDFile::Write(u64 offset, std::size_t length, bool flush,
-                                      bool update_timestamp, const u8* buffer) {
+ResultVal<std::size_t> TMDFile::Write(
+    u64 offset, std::size_t length, bool flush, bool update_timestamp, const u8* buffer)
+{
     written += length;
     data.resize(written);
     std::memcpy(data.data() + offset, buffer, length);
     return length;
 }
 
-u64 TMDFile::GetSize() const {
+u64 TMDFile::GetSize() const
+{
     return written;
 }
 
-bool TMDFile::SetSize(u64 size) const {
+bool TMDFile::SetSize(u64 size) const
+{
     return false;
 }
 
-bool TMDFile::Close() {
+bool TMDFile::Close()
+{
     return true;
 }
 
 void TMDFile::Flush() const {}
 
-Result TMDFile::Commit() {
-    return importing_title->cia_file.WriteTitleMetadata(data, 0).result;
+Result TMDFile::Commit()
+{
+    return importing_title->cia_file.WriteTitleMetadata(data, 0);
 }
 
-ContentFile::~ContentFile() {
+ContentFile::~ContentFile()
+{
     Close();
 }
 
-ResultVal<std::size_t> ContentFile::Read(u64 offset, std::size_t length, u8* buffer) const {
+ResultVal<std::size_t> ContentFile::Read(u64 offset, std::size_t length, u8* buffer) const
+{
     UNIMPLEMENTED();
     return length;
 }
 
-ResultVal<std::size_t> ContentFile::Write(u64 offset, std::size_t length, bool flush,
-                                          bool update_timestamp, const u8* buffer) {
+ResultVal<std::size_t> ContentFile::Write(
+    u64 offset, std::size_t length, bool flush, bool update_timestamp, const u8* buffer)
+{
     auto res = importing_title->cia_file.WriteContentDataIndexed(index, offset, length, buffer);
     if (res.Succeeded()) {
         import_context.current_size += static_cast<u64>(res.Unwrap());
@@ -1033,27 +1109,31 @@ ResultVal<std::size_t> ContentFile::Write(u64 offset, std::size_t length, bool f
     return res;
 }
 
-u64 ContentFile::GetSize() const {
+u64 ContentFile::GetSize() const
+{
     return written;
 }
 
-bool ContentFile::SetSize(u64 size) const {
+bool ContentFile::SetSize(u64 size) const
+{
     return false;
 }
 
-bool ContentFile::Close() {
+bool ContentFile::Close()
+{
     return false;
 }
 
 void ContentFile::Flush() const {}
 
-void ContentFile::Cancel(FS::MediaType media_type, u64 title_id) {
+void ContentFile::Cancel(FS::MediaType media_type, u64 title_id)
+{
     auto path = GetTitleContentPath(media_type, title_id, index, true);
     FileUtil::Delete(path);
 }
 
-InstallStatus InstallCIA(const std::string& path,
-                         std::function<ProgressCallback>&& update_callback) {
+InstallStatus InstallCIA(const std::string& path, std::function<ProgressCallback>&& update_callback)
+{
     LOG_INFO(Service_AM, "Installing {}...", path);
 
     if (!FileUtil::Exists(path)) {
@@ -1063,12 +1143,15 @@ InstallStatus InstallCIA(const std::string& path,
 
     FileSys::CIAContainer container;
     if (container.Load(path) == Loader::ResultStatus::Success) {
-        Service::AM::CIAFile installFile(
-            Core::System::GetInstance(),
-            Service::AM::GetTitleMediaType(container.GetTitleMetadata().GetTitleID()));
-
-        if (container.GetTitleMetadata().HasEncryptedContent(container.GetHeader())) {
-            LOG_ERROR(Service_AM, "File {} is encrypted! Aborting...", path);
+        Service::AM::CIAFile installFile(Core::System::GetInstance(),
+                                         Service::AM::GetTitleMediaType(
+                                             container.GetTitleMetadata().GetTitleID()));
+
+        bool title_key_available = container.GetTicket().GetTitleKey().has_value();
+        if (!title_key_available && container.GetTitleMetadata().HasEncryptedContent()) {
+            LOG_ERROR(Service_AM,
+                      "File {} is encrypted and no title key is available! Aborting...",
+                      path);
             return InstallStatus::ErrorEncrypted;
         }
 
@@ -1078,20 +1161,28 @@ InstallStatus InstallCIA(const std::string& path,
             return InstallStatus::ErrorFailedToOpenFile;
         }
 
+#ifdef todotodo
         std::vector<u8> buffer;
         buffer.resize(0x10000);
+#else
+        std::array<u8, 0x10000> buffer;
+#endif
         auto file_size = file.GetSize();
         std::size_t total_bytes_read = 0;
         while (total_bytes_read != file_size) {
             std::size_t bytes_read = file.ReadBytes(buffer.data(), buffer.size());
-            auto result = installFile.Write(static_cast<u64>(total_bytes_read), bytes_read, true,
-                                            false, static_cast<u8*>(buffer.data()));
+            auto result = installFile.Write(static_cast<u64>(total_bytes_read),
+                                            bytes_read,
+                                            true,
+                                            false,
+                                            static_cast<u8*>(buffer.data()));
 
             if (update_callback) {
                 update_callback(total_bytes_read, file_size);
             }
             if (result.Failed()) {
-                LOG_ERROR(Service_AM, "CIA file installation aborted with error code {:08x}",
+                LOG_ERROR(Service_AM,
+                          "CIA file installation aborted with error code {:08x}",
                           result.Code().raw);
                 return InstallStatus::ErrorAborted;
             }
@@ -1099,41 +1190,145 @@ InstallStatus InstallCIA(const std::string& path,
         }
         installFile.Close();
 
-        InstallStatus install_res = InstallStatus::Success;
-        for (auto result : installFile.GetInstallResults()) {
-            if (result.type != CIAFile::InstallResult::Type::APP || result.result.IsError()) {
-                continue;
-            }
-
-            std::unique_ptr<Loader::AppLoader> loader = Loader::GetLoader(result.install_full_path);
-            if (!loader) {
-                continue;
-            }
+        LOG_INFO(Service_AM, "Installed {} successfully.", path);
+
+        const FileUtil::DirectoryEntryCallable callback =
+            [&callback](u64* num_entries_out,
+                        const std::string& directory,
+                        const std::string& virtual_name) -> bool {
+            const std::string physical_name = directory + DIR_SEP + virtual_name;
+            const bool is_dir = FileUtil::IsDirectory(physical_name);
+            if (!is_dir) {
+                std::unique_ptr<Loader::AppLoader> loader = Loader::GetLoader(physical_name);
+                if (!loader) {
+                    return true;
+                }
 
-            bool executable = false;
-            const auto res = loader->IsExecutable(executable);
-            if (res == Loader::ResultStatus::ErrorEncrypted) {
-                LOG_ERROR(Service_AM, "CIA contains encrypted content: {}", path,
-                          result.install_full_path);
-                install_res = InstallStatus::ErrorEncrypted;
+                bool executable = false;
+                const auto res = loader->IsExecutable(executable);
+                if (res == Loader::ResultStatus::ErrorEncrypted) {
+                    return false;
+                }
+                return true;
+            } else {
+                return FileUtil::ForeachDirectoryEntry(nullptr, physical_name, callback);
             }
+        };
+        if (!FileUtil::ForeachDirectoryEntry(nullptr,
+                                             GetTitlePath(Service::AM::GetTitleMediaType(
+                                                              container.GetTitleMetadata()
+                                                                  .GetTitleID()),
+                                                          container.GetTitleMetadata().GetTitleID()),
+                                             callback)) {
+            LOG_ERROR(Service_AM, "CIA {} contained encrypted files.", path);
+            return InstallStatus::ErrorEncrypted;
         }
-        if (install_res == InstallStatus::Success) {
-            LOG_INFO(Service_AM, "Installed {} successfully.", path);
-        }
-        return install_res;
+        return InstallStatus::Success;
     }
 
     LOG_ERROR(Service_AM, "CIA file {} is invalid!", path);
     return InstallStatus::ErrorInvalid;
 }
 
-u64 GetTitleUpdateId(u64 title_id) {
+InstallStatus InstallFromNus(u64 title_id, int version)
+{
+    LOG_DEBUG(Service_AM, "Downloading {:X}", title_id);
+
+    CIAFile install_file{Core::System::GetInstance(), GetTitleMediaType(title_id)};
+
+    std::string path = fmt::format("/ccs/download/{:016X}/tmd", title_id);
+    if (version != -1) {
+        path += fmt::format(".{}", version);
+    }
+    auto tmd_response = Core::NUS::Download(path);
+    if (!tmd_response) {
+        LOG_ERROR(Service_AM, "Failed to download tmd for {:016X}", title_id);
+        return InstallStatus::ErrorFileNotFound;
+    }
+    FileSys::TitleMetadata tmd;
+    tmd.Load(*tmd_response);
+
+    path = fmt::format("/ccs/download/{:016X}/cetk", title_id);
+    auto cetk_response = Core::NUS::Download(path);
+    if (!cetk_response) {
+        LOG_ERROR(Service_AM, "Failed to download cetk for {:016X}", title_id);
+        return InstallStatus::ErrorFileNotFound;
+    }
+
+    std::vector<u8> content;
+    const auto content_count = tmd.GetContentCount();
+    for (std::size_t i = 0; i < content_count; ++i) {
+        const std::string filename = fmt::format("{:08x}", tmd.GetContentIDByIndex(i));
+        path = fmt::format("/ccs/download/{:016X}/{}", title_id, filename);
+        const auto temp_response = Core::NUS::Download(path);
+        if (!temp_response) {
+            LOG_ERROR(Service_AM, "Failed to download content for {:016X}", title_id);
+            return InstallStatus::ErrorFileNotFound;
+        }
+        content.insert(content.end(), temp_response->begin(), temp_response->end());
+    }
+
+    FileSys::CIAHeader fake_header{
+        .header_size = sizeof(FileSys::CIAHeader),
+        .type = 0,
+        .version = 0,
+        .cert_size = 0,
+        .tik_size = static_cast<u32_le>(cetk_response->size()),
+        .tmd_size = static_cast<u32_le>(tmd_response->size()),
+        .meta_size = 0,
+    };
+    for (u16 i = 0; i < content_count; ++i) {
+        fake_header.SetContentPresent(i);
+    }
+    std::vector<u8> header_data(sizeof(fake_header));
+    std::memcpy(header_data.data(), &fake_header, sizeof(fake_header));
+
+    std::size_t current_offset = 0;
+    const auto write_to_cia_file_aligned = [&install_file, &current_offset](std::vector<u8>& data) {
+        const u64 offset = Common::AlignUp(current_offset + data.size(),
+                                           FileSys::CIA_SECTION_ALIGNMENT);
+        data.resize(offset - current_offset, 0);
+        const auto result = install_file.Write(current_offset, data.size(), true, false, data.data());
+        if (result.Failed()) {
+            LOG_ERROR(Service_AM,
+                      "CIA file installation aborted with error code {:08x}",
+                      result.Code().raw);
+            return InstallStatus::ErrorAborted;
+        }
+        current_offset += data.size();
+        return InstallStatus::Success;
+    };
+
+    auto result = write_to_cia_file_aligned(header_data);
+    if (result != InstallStatus::Success) {
+        return result;
+    }
+
+    result = write_to_cia_file_aligned(*cetk_response);
+    if (result != InstallStatus::Success) {
+        return result;
+    }
+
+    result = write_to_cia_file_aligned(*tmd_response);
+    if (result != InstallStatus::Success) {
+        return result;
+    }
+
+    result = write_to_cia_file_aligned(content);
+    if (result != InstallStatus::Success) {
+        return result;
+    }
+    return InstallStatus::Success;
+}
+
+u64 GetTitleUpdateId(u64 title_id)
+{
     // Real services seem to just discard and replace the whole high word.
     return (title_id & 0xFFFFFFFF) | (static_cast<u64>(TID_HIGH_UPDATE) << 32);
 }
 
-Service::FS::MediaType GetTitleMediaType(u64 titleId) {
+Service::FS::MediaType GetTitleMediaType(u64 titleId)
+{
     u16 platform = static_cast<u16>(titleId >> 48);
     u16 category = static_cast<u16>((titleId >> 32) & 0xFFFF);
     u8 variation = static_cast<u8>(titleId & 0xFF);
@@ -1147,15 +1342,18 @@ Service::FS::MediaType GetTitleMediaType(u64 titleId) {
     return Service::FS::MediaType::SDMC;
 }
 
-std::string GetTicketDirectory() {
+std::string GetTicketDirectory()
+{
     return fmt::format("{}/dbs/ticket.db/", FileUtil::GetUserPath(FileUtil::UserPath::NANDDir));
 }
 
-std::string GetTicketPath(u64 title_id, u64 ticket_id) {
+std::string GetTicketPath(u64 title_id, u64 ticket_id)
+{
     return GetTicketDirectory() + fmt::format("{:016X}.{:016X}.tik", title_id, ticket_id);
 }
 
-std::string GetTitleMetadataPath(Service::FS::MediaType media_type, u64 tid, bool update) {
+std::string GetTitleMetadataPath(Service::FS::MediaType media_type, u64 tid, bool update)
+{
     std::string content_path = GetTitlePath(media_type, tid) + "content/";
 
     if (media_type == Service::FS::MediaType::GameCard) {
@@ -1193,14 +1391,15 @@ std::string GetTitleMetadataPath(Service::FS::MediaType media_type, u64 tid, boo
     return content_path + fmt::format("{:08x}.tmd", (update ? update_id : base_id));
 }
 
-std::string GetTitleContentPath(Service::FS::MediaType media_type, u64 tid, std::size_t index,
-                                bool update) {
-
+std::string GetTitleContentPath(Service::FS::MediaType media_type,
+                                u64 tid,
+                                std::size_t index,
+                                bool update)
+{
     if (media_type == Service::FS::MediaType::GameCard) {
         // TODO(B3N30): check if TID matches
-        auto fs_user =
-            Core::System::GetInstance().ServiceManager().GetService<Service::FS::FS_USER>(
-                "fs:USER");
+        auto fs_user = Core::System::GetInstance().ServiceManager().GetService<Service::FS::FS_USER>(
+            "fs:USER");
         return fs_user->GetCurrentGamecardPath();
     }
 
@@ -1214,7 +1413,8 @@ std::string GetTitleContentPath(Service::FS::MediaType media_type, u64 tid, std:
         if (index < tmd.GetContentCount()) {
             content_id = tmd.GetContentIDByIndex(index);
         } else {
-            LOG_ERROR(Service_AM, "Attempted to get path for non-existent content index {:04x}.",
+            LOG_ERROR(Service_AM,
+                      "Attempted to get path for non-existent content index {:04x}.",
                       index);
             return "";
         }
@@ -1223,8 +1423,8 @@ std::string GetTitleContentPath(Service::FS::MediaType media_type, u64 tid, std:
         // For now, check if the second (index 1) content has the optional flag set, for most
         // apps this is usually the manual and not set optional, DLC has it set optional.
         // All .apps (including index 0) will be in the 00000000/ folder for DLC.
-        if (tmd.GetContentCount() > 1 &&
-            tmd.GetContentTypeByIndex(1) & FileSys::TMDContentTypeFlag::Optional) {
+        if (tmd.GetContentCount() > 1
+            && tmd.GetContentTypeByIndex(1) & FileSys::TMDContentTypeFlag::Optional) {
             content_path += "00000000/";
         }
     }
@@ -1232,7 +1432,8 @@ std::string GetTitleContentPath(Service::FS::MediaType media_type, u64 tid, std:
     return fmt::format("{}{:08x}.app", content_path, content_id);
 }
 
-std::string GetTitlePath(Service::FS::MediaType media_type, u64 tid) {
+std::string GetTitlePath(Service::FS::MediaType media_type, u64 tid)
+{
     // TODO(PabloMK7) TWL titles should be in TWL Nand. Assuming CTR Nand for now.
 
     u32 high = static_cast<u32>(tid >> 32);
@@ -1243,37 +1444,39 @@ std::string GetTitlePath(Service::FS::MediaType media_type, u64 tid) {
 
     if (media_type == Service::FS::MediaType::GameCard) {
         // TODO(B3N30): check if TID matches
-        auto fs_user =
-            Core::System::GetInstance().ServiceManager().GetService<Service::FS::FS_USER>(
-                "fs:USER");
+        auto fs_user = Core::System::GetInstance().ServiceManager().GetService<Service::FS::FS_USER>(
+            "fs:USER");
         return fs_user->GetCurrentGamecardPath();
     }
 
     return "";
 }
 
-std::string GetMediaTitlePath(Service::FS::MediaType media_type) {
+std::string GetMediaTitlePath(Service::FS::MediaType media_type)
+{
     if (media_type == Service::FS::MediaType::NAND)
-        return fmt::format("{}{}/title/", FileUtil::GetUserPath(FileUtil::UserPath::NANDDir),
+        return fmt::format("{}{}/title/",
+                           FileUtil::GetUserPath(FileUtil::UserPath::NANDDir),
                            SYSTEM_ID);
 
     if (media_type == Service::FS::MediaType::SDMC)
         return fmt::format("{}Nintendo 3DS/{}/{}/title/",
-                           FileUtil::GetUserPath(FileUtil::UserPath::SDMCDir), SYSTEM_ID,
+                           FileUtil::GetUserPath(FileUtil::UserPath::SDMCDir),
+                           SYSTEM_ID,
                            SDCARD_ID);
 
     if (media_type == Service::FS::MediaType::GameCard) {
         // TODO(B3N30): check if TID matchess
-        auto fs_user =
-            Core::System::GetInstance().ServiceManager().GetService<Service::FS::FS_USER>(
-                "fs:USER");
+        auto fs_user = Core::System::GetInstance().ServiceManager().GetService<Service::FS::FS_USER>(
+            "fs:USER");
         return fs_user->GetCurrentGamecardPath();
     }
 
     return "";
 }
 
-void Module::ScanForTickets() {
+void Module::ScanForTickets()
+{
     if (Settings::values.deterministic_async_operations) {
         ScanForTicketsImpl();
     } else {
@@ -1284,7 +1487,8 @@ void Module::ScanForTickets() {
     }
 }
 
-void Module::ScanForTicketsImpl() {
+void Module::ScanForTicketsImpl()
+{
     am_ticket_list.clear();
 
     LOG_DEBUG(Service_AM, "Starting ticket scan");
@@ -1314,7 +1518,8 @@ void Module::ScanForTicketsImpl() {
     LOG_DEBUG(Service_AM, "Finished ticket scan");
 }
 
-void Module::ScanForTitles(Service::FS::MediaType media_type) {
+void Module::ScanForTitles(Service::FS::MediaType media_type)
+{
     if (Settings::values.deterministic_async_operations) {
         ScanForTitlesImpl(media_type);
     } else {
@@ -1325,7 +1530,8 @@ void Module::ScanForTitles(Service::FS::MediaType media_type) {
     }
 }
 
-void Module::ScanForTitlesImpl(Service::FS::MediaType media_type) {
+void Module::ScanForTitlesImpl(Service::FS::MediaType media_type)
+{
     am_title_list[static_cast<u32>(media_type)].clear();
 
     LOG_DEBUG(Service_AM, "Starting title scan for media_type={}", static_cast<int>(media_type));
@@ -1366,7 +1572,8 @@ void Module::ScanForTitlesImpl(Service::FS::MediaType media_type) {
     LOG_DEBUG(Service_AM, "Finished title scan for media_type={}", static_cast<int>(media_type));
 }
 
-void Module::ScanForAllTitles() {
+void Module::ScanForAllTitles()
+{
     if (Settings::values.deterministic_async_operations) {
         ScanForTicketsImpl();
         ScanForTitlesImpl(Service::FS::MediaType::NAND);
@@ -1386,18 +1593,22 @@ void Module::ScanForAllTitles() {
 }
 
 Module::Interface::Interface(std::shared_ptr<Module> am, const char* name, u32 max_session)
-    : ServiceFramework(name, max_session), am(std::move(am)) {}
+    : ServiceFramework(name, max_session)
+    , am(std::move(am))
+{}
 
 Module::Interface::~Interface() = default;
 
-void Module::Interface::GetNumPrograms(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetNumPrograms(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     u8 media_type = rp.Pop<u8>();
 
     LOG_DEBUG(Service_AM, "media_type={}", media_type);
 
     if (artic_client.get()) {
-        struct AsyncData {
+        struct AsyncData
+        {
             u8 media_type;
 
             ResultVal<s32> res;
@@ -1449,8 +1660,8 @@ void Module::Interface::GetNumPrograms(Kernel::HLERequestContext& ctx) {
     }
 }
 
-void Module::Interface::FindDLCContentInfos(Kernel::HLERequestContext& ctx) {
-
+void Module::Interface::FindDLCContentInfos(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     auto media_type = static_cast<Service::FS::MediaType>(rp.Pop<u8>());
     u64 title_id = rp.Pop<u64>();
@@ -1460,7 +1671,8 @@ void Module::Interface::FindDLCContentInfos(Kernel::HLERequestContext& ctx) {
     LOG_DEBUG(Service_AM, "title_id={:016X}", title_id);
 
     if (artic_client.get()) {
-        struct AsyncData {
+        struct AsyncData
+        {
             u8 media_type;
             u64 title_id;
             std::vector<u16> content_requested;
@@ -1473,7 +1685,8 @@ void Module::Interface::FindDLCContentInfos(Kernel::HLERequestContext& ctx) {
         async_data->media_type = static_cast<u8>(media_type);
         async_data->title_id = title_id;
         async_data->content_requested.resize(content_count);
-        content_requested_in.Read(async_data->content_requested.data(), 0,
+        content_requested_in.Read(async_data->content_requested.data(),
+                                  0,
                                   content_count * sizeof(u16));
         async_data->content_info_out = &rp.PopMappedBuffer();
 
@@ -1511,7 +1724,8 @@ void Module::Interface::FindDLCContentInfos(Kernel::HLERequestContext& ctx) {
             },
             [async_data](Kernel::HLERequestContext& ctx) {
                 if (async_data->res.IsSuccess()) {
-                    async_data->content_info_out->Write(async_data->out.data(), 0,
+                    async_data->content_info_out->Write(async_data->out.data(),
+                                                        0,
                                                         async_data->out.size());
                 }
                 IPC::RequestBuilder rb(ctx, 1, 0);
@@ -1519,8 +1733,8 @@ void Module::Interface::FindDLCContentInfos(Kernel::HLERequestContext& ctx) {
             },
             true);
     } else {
-
-        struct AsyncData {
+        struct AsyncData
+        {
             Service::FS::MediaType media_type;
             u64 title_id;
             std::vector<u16> content_requested;
@@ -1533,7 +1747,8 @@ void Module::Interface::FindDLCContentInfos(Kernel::HLERequestContext& ctx) {
         async_data->media_type = media_type;
         async_data->title_id = title_id;
         async_data->content_requested.resize(content_count);
-        content_requested_in.Read(async_data->content_requested.data(), 0,
+        content_requested_in.Read(async_data->content_requested.data(),
+                                  0,
                                   content_count * sizeof(u16));
         async_data->content_info_out = &rp.PopMappedBuffer();
 
@@ -1542,13 +1757,15 @@ void Module::Interface::FindDLCContentInfos(Kernel::HLERequestContext& ctx) {
                 // Validate that only DLC TIDs are passed in
                 u32 tid_high = static_cast<u32>(async_data->title_id >> 32);
                 if (tid_high != TID_HIGH_DLC) {
-                    async_data->res = Result(ErrCodes::InvalidTIDInList, ErrorModule::AM,
-                                             ErrorSummary::InvalidArgument, ErrorLevel::Usage);
+                    async_data->res = Result(ErrCodes::InvalidTIDInList,
+                                             ErrorModule::AM,
+                                             ErrorSummary::InvalidArgument,
+                                             ErrorLevel::Usage);
                     return 0;
                 }
 
-                std::string tmd_path =
-                    GetTitleMetadataPath(async_data->media_type, async_data->title_id);
+                std::string tmd_path = GetTitleMetadataPath(async_data->media_type,
+                                                            async_data->title_id);
 
                 // In normal circumstances, if there is no ticket we shouldn't be able to have
                 // any contents either. However to keep compatibility with older emulator builds,
@@ -1557,9 +1774,9 @@ void Module::Interface::FindDLCContentInfos(Kernel::HLERequestContext& ctx) {
                 FileSys::Ticket ticket;
                 std::scoped_lock lock(am->am_lists_mutex);
                 auto entries = am->am_ticket_list.find(async_data->title_id);
-                if (entries != am->am_ticket_list.end() &&
-                    ticket.Load(async_data->title_id, (*entries).second) ==
-                        Loader::ResultStatus::Success) {
+                if (entries != am->am_ticket_list.end()
+                    && ticket.Load(async_data->title_id, (*entries).second)
+                           == Loader::ResultStatus::Success) {
                     has_ticket = true;
                 }
 
@@ -1583,23 +1800,24 @@ void Module::Interface::FindDLCContentInfos(Kernel::HLERequestContext& ctx) {
                         content_info.type = tmd.GetContentTypeByIndex(index);
                         content_info.content_id = tmd.GetContentIDByIndex(index);
                         content_info.size = tmd.GetContentSizeByIndex(index);
-                        content_info.ownership =
-                            (!has_ticket || ticket.HasRights(index)) ? OWNERSHIP_OWNED : 0;
+                        content_info.ownership = (!has_ticket || ticket.HasRights(index))
+                                                     ? OWNERSHIP_OWNED
+                                                     : 0;
 
                         if (FileUtil::Exists(GetTitleContentPath(async_data->media_type,
-                                                                 async_data->title_id, index))) {
+                                                                 async_data->title_id,
+                                                                 index))) {
                             bool pending = false;
                             for (auto& import_ctx : am->import_content_contexts) {
-                                if (import_ctx.first == async_data->title_id &&
-                                    import_ctx.second.index == index &&
-                                    (import_ctx.second.state ==
-                                         ImportTitleContextState::WAITING_FOR_IMPORT ||
-                                     import_ctx.second.state ==
-                                         ImportTitleContextState::WAITING_FOR_COMMIT ||
-                                     import_ctx.second.state ==
-                                         ImportTitleContextState::RESUMABLE)) {
-                                    LOG_DEBUG(Service_AM, "content pending commit index={:016X}",
-                                              i);
+                                if (import_ctx.first == async_data->title_id
+                                    && import_ctx.second.index == index
+                                    && (import_ctx.second.state
+                                            == ImportTitleContextState::WAITING_FOR_IMPORT
+                                        || import_ctx.second.state
+                                               == ImportTitleContextState::WAITING_FOR_COMMIT
+                                        || import_ctx.second.state
+                                               == ImportTitleContextState::RESUMABLE)) {
+                                    LOG_DEBUG(Service_AM, "content pending commit index={:016X}", i);
                                     pending = true;
                                     break;
                                 }
@@ -1619,16 +1837,18 @@ void Module::Interface::FindDLCContentInfos(Kernel::HLERequestContext& ctx) {
                 IPC::RequestBuilder rb(ctx, 2, 0);
                 rb.Push(async_data->res);
                 if (async_data->res.IsSuccess()) {
-                    async_data->content_info_out->Write(async_data->out_vec.data(), 0,
-                                                        async_data->out_vec.size() *
-                                                            sizeof(ContentInfo));
+                    async_data->content_info_out->Write(async_data->out_vec.data(),
+                                                        0,
+                                                        async_data->out_vec.size()
+                                                            * sizeof(ContentInfo));
                 }
             },
             true);
     }
 }
 
-void Module::Interface::ListDLCContentInfos(Kernel::HLERequestContext& ctx) {
+void Module::Interface::ListDLCContentInfos(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     u32 content_count = rp.Pop<u32>();
@@ -1639,7 +1859,8 @@ void Module::Interface::ListDLCContentInfos(Kernel::HLERequestContext& ctx) {
     LOG_DEBUG(Service_AM, "title_id={:016X}", title_id);
 
     if (artic_client.get()) {
-        struct AsyncData {
+        struct AsyncData
+        {
             u8 media_type;
             u64 title_id;
             u32 content_count;
@@ -1690,7 +1911,8 @@ void Module::Interface::ListDLCContentInfos(Kernel::HLERequestContext& ctx) {
             },
             [async_data](Kernel::HLERequestContext& ctx) {
                 if (async_data->res.IsSuccess()) {
-                    async_data->content_info_out->Write(async_data->out.data(), 0,
+                    async_data->content_info_out->Write(async_data->out.data(),
+                                                        0,
                                                         async_data->out.size());
                 }
                 IPC::RequestBuilder rb(ctx, 2, 0);
@@ -1699,8 +1921,8 @@ void Module::Interface::ListDLCContentInfos(Kernel::HLERequestContext& ctx) {
             },
             true);
     } else {
-
-        struct AsyncData {
+        struct AsyncData
+        {
             Service::FS::MediaType media_type;
             u64 title_id;
             u32 content_count;
@@ -1722,13 +1944,15 @@ void Module::Interface::ListDLCContentInfos(Kernel::HLERequestContext& ctx) {
                 // Validate that only DLC TIDs are passed in
                 u32 tid_high = static_cast<u32>(async_data->title_id >> 32);
                 if (tid_high != TID_HIGH_DLC) {
-                    async_data->res = Result(ErrCodes::InvalidTIDInList, ErrorModule::AM,
-                                             ErrorSummary::InvalidArgument, ErrorLevel::Usage);
+                    async_data->res = Result(ErrCodes::InvalidTIDInList,
+                                             ErrorModule::AM,
+                                             ErrorSummary::InvalidArgument,
+                                             ErrorLevel::Usage);
                     return 0;
                 }
 
-                std::string tmd_path =
-                    GetTitleMetadataPath(async_data->media_type, async_data->title_id);
+                std::string tmd_path = GetTitleMetadataPath(async_data->media_type,
+                                                            async_data->title_id);
 
                 // In normal circumstances, if there is no ticket we shouldn't be able to have
                 // any contents either. However to keep compatibility with older emulator builds,
@@ -1737,9 +1961,9 @@ void Module::Interface::ListDLCContentInfos(Kernel::HLERequestContext& ctx) {
                 FileSys::Ticket ticket;
                 std::scoped_lock lock(am->am_lists_mutex);
                 auto entries = am->am_ticket_list.find(async_data->title_id);
-                if (entries != am->am_ticket_list.end() &&
-                    ticket.Load(async_data->title_id, (*entries).second) ==
-                        Loader::ResultStatus::Success) {
+                if (entries != am->am_ticket_list.end()
+                    && ticket.Load(async_data->title_id, (*entries).second)
+                           == Loader::ResultStatus::Success) {
                     has_ticket = true;
                 }
 
@@ -1753,24 +1977,25 @@ void Module::Interface::ListDLCContentInfos(Kernel::HLERequestContext& ctx) {
                         content_info.type = tmd.GetContentTypeByIndex(i);
                         content_info.content_id = tmd.GetContentIDByIndex(i);
                         content_info.size = tmd.GetContentSizeByIndex(i);
-                        content_info.ownership =
-                            (!has_ticket || ticket.HasRights(static_cast<u16>(i))) ? OWNERSHIP_OWNED
-                                                                                   : 0;
+                        content_info.ownership = (!has_ticket
+                                                  || ticket.HasRights(static_cast<u16>(i)))
+                                                     ? OWNERSHIP_OWNED
+                                                     : 0;
 
                         if (FileUtil::Exists(GetTitleContentPath(async_data->media_type,
-                                                                 async_data->title_id, i))) {
+                                                                 async_data->title_id,
+                                                                 i))) {
                             bool pending = false;
                             for (auto& import_ctx : am->import_content_contexts) {
-                                if (import_ctx.first == async_data->title_id &&
-                                    import_ctx.second.index == i &&
-                                    (import_ctx.second.state ==
-                                         ImportTitleContextState::WAITING_FOR_IMPORT ||
-                                     import_ctx.second.state ==
-                                         ImportTitleContextState::WAITING_FOR_COMMIT ||
-                                     import_ctx.second.state ==
-                                         ImportTitleContextState::RESUMABLE)) {
-                                    LOG_DEBUG(Service_AM, "content pending commit index={:016X}",
-                                              i);
+                                if (import_ctx.first == async_data->title_id
+                                    && import_ctx.second.index == i
+                                    && (import_ctx.second.state
+                                            == ImportTitleContextState::WAITING_FOR_IMPORT
+                                        || import_ctx.second.state
+                                               == ImportTitleContextState::WAITING_FOR_COMMIT
+                                        || import_ctx.second.state
+                                               == ImportTitleContextState::RESUMABLE)) {
+                                    LOG_DEBUG(Service_AM, "content pending commit index={:016X}", i);
                                     pending = true;
                                     break;
                                 }
@@ -1790,16 +2015,18 @@ void Module::Interface::ListDLCContentInfos(Kernel::HLERequestContext& ctx) {
                 rb.Push(async_data->res);
                 rb.Push(static_cast<u32>(async_data->out_vec.size()));
                 if (async_data->res.IsSuccess()) {
-                    async_data->content_info_out->Write(async_data->out_vec.data(), 0,
-                                                        async_data->out_vec.size() *
-                                                            sizeof(ContentInfo));
+                    async_data->content_info_out->Write(async_data->out_vec.data(),
+                                                        0,
+                                                        async_data->out_vec.size()
+                                                            * sizeof(ContentInfo));
                 }
             },
             true);
     }
 }
 
-void Module::Interface::DeleteContents(Kernel::HLERequestContext& ctx) {
+void Module::Interface::DeleteContents(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     u8 media_type = rp.Pop<u8>();
     u64 title_id = rp.Pop<u64>();
@@ -1809,11 +2036,15 @@ void Module::Interface::DeleteContents(Kernel::HLERequestContext& ctx) {
     IPC::RequestBuilder rb = rp.MakeBuilder(1, 2);
     rb.Push(ResultSuccess);
     rb.PushMappedBuffer(content_ids_in);
-    LOG_WARNING(Service_AM, "(STUBBED) media_type={}, title_id=0x{:016x}, content_count={}",
-                media_type, title_id, content_count);
+    LOG_WARNING(Service_AM,
+                "(STUBBED) media_type={}, title_id=0x{:016x}, content_count={}",
+                media_type,
+                title_id,
+                content_count);
 }
 
-void Module::Interface::GetProgramList(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetProgramList(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     u32 count = rp.Pop<u32>();
     u8 media_type = rp.Pop<u8>();
@@ -1821,7 +2052,8 @@ void Module::Interface::GetProgramList(Kernel::HLERequestContext& ctx) {
     LOG_DEBUG(Service_AM, "media_type={}", media_type);
 
     if (artic_client.get()) {
-        struct AsyncData {
+        struct AsyncData
+        {
             u32 count;
             u8 media_type;
 
@@ -1871,7 +2103,8 @@ void Module::Interface::GetProgramList(Kernel::HLERequestContext& ctx) {
                     rb.Push(async_data->res);
                     rb.Push<u32>(0);
                 } else {
-                    async_data->title_ids_output->Write(async_data->out.data(), 0,
+                    async_data->title_ids_output->Write(async_data->out.data(),
+                                                        0,
                                                         async_data->out.size());
 
                     IPC::RequestBuilder rb(ctx, 2, 0);
@@ -1903,8 +2136,10 @@ void Module::Interface::GetProgramList(Kernel::HLERequestContext& ctx) {
     }
 }
 
-Result GetTitleInfoFromList(std::span<const u64> title_id_list, Service::FS::MediaType media_type,
-                            std::vector<TitleInfo>& title_info_out) {
+Result GetTitleInfoFromList(std::span<const u64> title_id_list,
+                            Service::FS::MediaType media_type,
+                            std::vector<TitleInfo>& title_info_out)
+{
     title_info_out.reserve(title_id_list.size());
     for (u32 i = 0; i < title_id_list.size(); i++) {
         std::string tmd_path = GetTitleMetadataPath(media_type, title_id_list[i]);
@@ -1921,10 +2156,14 @@ Result GetTitleInfoFromList(std::span<const u64> title_id_list, Service::FS::Med
             title_info.type = tmd.GetTitleType();
         } else {
             LOG_DEBUG(Service_AM, "not found title_id={:016X}", title_id_list[i]);
-            return Result(ErrorDescription::NotFound, ErrorModule::AM, ErrorSummary::InvalidState,
+            return Result(ErrorDescription::NotFound,
+                          ErrorModule::AM,
+                          ErrorSummary::InvalidState,
                           ErrorLevel::Permanent);
         }
-        LOG_DEBUG(Service_AM, "found title_id={:016X} version={:04X}", title_id_list[i],
+        LOG_DEBUG(Service_AM,
+                  "found title_id={:016X} version={:04X}",
+                  title_id_list[i],
                   title_info.version);
         title_info_out.push_back(title_info);
     }
@@ -1932,7 +2171,8 @@ Result GetTitleInfoFromList(std::span<const u64> title_id_list, Service::FS::Med
     return ResultSuccess;
 }
 
-void Module::Interface::GetProgramInfosImpl(Kernel::HLERequestContext& ctx, bool ignore_platform) {
+void Module::Interface::GetProgramInfosImpl(Kernel::HLERequestContext& ctx, bool ignore_platform)
+{
     IPC::RequestParser rp(ctx);
 
     auto media_type = static_cast<Service::FS::MediaType>(rp.Pop<u8>());
@@ -1941,7 +2181,8 @@ void Module::Interface::GetProgramInfosImpl(Kernel::HLERequestContext& ctx, bool
     LOG_DEBUG(Service_AM, "media_type={}, ignore_platform={}", media_type, ignore_platform);
 
     if (artic_client.get()) {
-        struct AsyncData {
+        struct AsyncData
+        {
             u8 media_type;
             bool ignore_platform;
             std::vector<u64> title_id_list;
@@ -1956,7 +2197,8 @@ void Module::Interface::GetProgramInfosImpl(Kernel::HLERequestContext& ctx, bool
         async_data->ignore_platform = ignore_platform;
         async_data->title_id_list.resize(title_count);
         async_data->title_id_list_buffer = &rp.PopMappedBuffer();
-        async_data->title_id_list_buffer->Read(async_data->title_id_list.data(), 0,
+        async_data->title_id_list_buffer->Read(async_data->title_id_list.data(),
+                                               0,
                                                title_count * sizeof(u64));
         async_data->title_info_out = &rp.PopMappedBuffer();
 
@@ -2002,7 +2244,8 @@ void Module::Interface::GetProgramInfosImpl(Kernel::HLERequestContext& ctx, bool
                         rb.PushMappedBuffer(*async_data->title_info_out);
                     }
                 } else {
-                    async_data->title_info_out->Write(async_data->out.data(), 0,
+                    async_data->title_info_out->Write(async_data->out.data(),
+                                                      0,
                                                       async_data->out.size() / sizeof(TitleInfo));
 
                     IPC::RequestBuilder rb(ctx, 1, async_data->ignore_platform ? 0 : 4);
@@ -2016,7 +2259,8 @@ void Module::Interface::GetProgramInfosImpl(Kernel::HLERequestContext& ctx, bool
             true);
 
     } else {
-        struct AsyncData {
+        struct AsyncData
+        {
             Service::FS::MediaType media_type;
             std::vector<u64> title_id_list;
 
@@ -2029,43 +2273,47 @@ void Module::Interface::GetProgramInfosImpl(Kernel::HLERequestContext& ctx, bool
         async_data->media_type = media_type;
         async_data->title_id_list.resize(title_count);
         async_data->title_id_list_buffer = &rp.PopMappedBuffer();
-        async_data->title_id_list_buffer->Read(async_data->title_id_list.data(), 0,
+        async_data->title_id_list_buffer->Read(async_data->title_id_list.data(),
+                                               0,
                                                title_count * sizeof(u64));
         async_data->title_info_out = &rp.PopMappedBuffer();
-
-        ctx.RunAsync(
-            [this, async_data](Kernel::HLERequestContext& ctx) {
-                // nim checks if the current importing title already exists during installation.
-                // Normally, since the program wouldn't be commited, getting the title info returns
-                // not found. However, since GetTitleInfoFromList does not care if the program was
-                // commited and only checks for the tmd, it will detect the title and return
-                // information while it shouldn't. To prevent this, we check if the importing
-                // context is present and not committed. If that's the case, return not found
-                for (auto tid : async_data->title_id_list) {
-                    for (auto& import_ctx : am->import_title_contexts) {
-                        if (import_ctx.first == tid &&
-                            (import_ctx.second.state ==
-                                 ImportTitleContextState::WAITING_FOR_IMPORT ||
-                             import_ctx.second.state ==
-                                 ImportTitleContextState::WAITING_FOR_COMMIT ||
-                             import_ctx.second.state == ImportTitleContextState::RESUMABLE)) {
-                            LOG_DEBUG(Service_AM, "title pending commit title_id={:016X}", tid);
-                            async_data->res =
-                                Result(ErrorDescription::NotFound, ErrorModule::AM,
-                                       ErrorSummary::InvalidState, ErrorLevel::Permanent);
-                        }
-                    }
+#ifdef todotodo
+        // nim checks if the current importing title already exists during installation.
+        // Normally, since the program wouldn't be commited, getting the title info returns not
+        // found. However, since GetTitleInfoFromList does not care if the program was commited and
+        // only checks for the tmd, it will detect the title and return information while it
+        // shouldn't. To prevent this, we check if the importing context is present and not
+        // committed. If that's the case, return not found
+        Result result = ResultSuccess;
+        for (auto tid : title_id_list) {
+            for (auto& import_ctx : am->import_title_contexts) {
+                if (import_ctx.first == tid
+                    && (import_ctx.second.state == ImportTitleContextState::WAITING_FOR_IMPORT
+                        || import_ctx.second.state == ImportTitleContextState::WAITING_FOR_COMMIT
+                        || import_ctx.second.state == ImportTitleContextState::RESUMABLE)) {
+                    LOG_DEBUG(Service_AM, "title pending commit title_id={:016X}", tid);
+                    result = Result(ErrorDescription::NotFound,
+                                    ErrorModule::AM,
+                                    ErrorSummary::InvalidState,
+                                    ErrorLevel::Permanent);
                 }
+            }
+        }
 
-                if (async_data->res.IsSuccess()) {
-                    async_data->res = GetTitleInfoFromList(async_data->title_id_list,
-                                                           async_data->media_type, async_data->out);
-                }
+        if (result.IsSuccess())
+            result = GetTitleInfoFromList(title_id_list, media_type, title_info_out);
+#else
+        ctx.RunAsync(
+            [async_data](Kernel::HLERequestContext& ctx) {
+                async_data->res = GetTitleInfoFromList(async_data->title_id_list,
+                                                       async_data->media_type,
+                                                       async_data->out);
                 return 0;
             },
             [async_data](Kernel::HLERequestContext& ctx) {
                 if (async_data->res.IsSuccess()) {
-                    async_data->title_info_out->Write(async_data->out.data(), 0,
+                    async_data->title_info_out->Write(async_data->out.data(),
+                                                      0,
                                                       async_data->out.size() * sizeof(TitleInfo));
                 }
                 IPC::RequestBuilder rb(ctx, 1, 4);
@@ -2074,18 +2322,22 @@ void Module::Interface::GetProgramInfosImpl(Kernel::HLERequestContext& ctx, bool
                 rb.PushMappedBuffer(*async_data->title_info_out);
             },
             true);
+#endif
     }
 }
 
-void Module::Interface::GetProgramInfos(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetProgramInfos(Kernel::HLERequestContext& ctx)
+{
     GetProgramInfosImpl(ctx, false);
 }
 
-void Module::Interface::GetProgramInfosIgnorePlatform(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetProgramInfosIgnorePlatform(Kernel::HLERequestContext& ctx)
+{
     GetProgramInfosImpl(ctx, true);
 }
 
-void Module::Interface::DeleteUserProgram(Kernel::HLERequestContext& ctx) {
+void Module::Interface::DeleteUserProgram(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     auto media_type = rp.PopEnum<FS::MediaType>();
     u64 title_id = rp.Pop<u64>();
@@ -2097,14 +2349,18 @@ void Module::Interface::DeleteUserProgram(Kernel::HLERequestContext& ctx) {
     u8 variation = static_cast<u8>(title_id & 0xFF);
     if (category & CATEGORY_SYSTEM || category & CATEGORY_DLP || variation & VARIATION_SYSTEM) {
         LOG_ERROR(Service_AM, "Trying to uninstall system app");
-        rb.Push(Result(ErrCodes::TryingToUninstallSystemApp, ErrorModule::AM,
-                       ErrorSummary::InvalidArgument, ErrorLevel::Usage));
+        rb.Push(Result(ErrCodes::TryingToUninstallSystemApp,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidArgument,
+                       ErrorLevel::Usage));
         return;
     }
     LOG_INFO(Service_AM, "Deleting title 0x{:016x}", title_id);
     std::string path = GetTitlePath(media_type, title_id);
     if (!FileUtil::Exists(path)) {
-        rb.Push(Result(ErrorDescription::NotFound, ErrorModule::AM, ErrorSummary::InvalidState,
+        rb.Push(Result(ErrorDescription::NotFound,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
                        ErrorLevel::Permanent));
         LOG_ERROR(Service_AM, "Title not found");
         return;
@@ -2116,7 +2372,8 @@ void Module::Interface::DeleteUserProgram(Kernel::HLERequestContext& ctx) {
         LOG_ERROR(Service_AM, "FileUtil::DeleteDirRecursively unexpectedly failed");
 }
 
-void Module::Interface::GetProductCode(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetProductCode(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     FS::MediaType media_type = rp.PopEnum<FS::MediaType>();
     u64 title_id = rp.Pop<u64>();
@@ -2126,10 +2383,13 @@ void Module::Interface::GetProductCode(Kernel::HLERequestContext& ctx) {
 
     if (!FileUtil::Exists(path)) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrorDescription::NotFound, ErrorModule::AM, ErrorSummary::InvalidState,
+        rb.Push(Result(ErrorDescription::NotFound,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
                        ErrorLevel::Permanent));
     } else {
-        struct ProductCode {
+        struct ProductCode
+        {
             u8 code[0x10];
         };
 
@@ -2144,7 +2404,8 @@ void Module::Interface::GetProductCode(Kernel::HLERequestContext& ctx) {
     }
 }
 
-void Module::Interface::GetDLCTitleInfos(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetDLCTitleInfos(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     auto media_type = static_cast<Service::FS::MediaType>(rp.Pop<u8>());
@@ -2153,7 +2414,8 @@ void Module::Interface::GetDLCTitleInfos(Kernel::HLERequestContext& ctx) {
     LOG_DEBUG(Service_AM, "media_type={}", media_type);
 
     if (artic_client.get()) {
-        struct AsyncData {
+        struct AsyncData
+        {
             u8 media_type;
             std::vector<u64> title_id_list;
 
@@ -2166,7 +2428,8 @@ void Module::Interface::GetDLCTitleInfos(Kernel::HLERequestContext& ctx) {
         async_data->media_type = static_cast<u8>(media_type);
         async_data->title_id_list.resize(title_count);
         async_data->title_id_list_buffer = &rp.PopMappedBuffer();
-        async_data->title_id_list_buffer->Read(async_data->title_id_list.data(), 0,
+        async_data->title_id_list_buffer->Read(async_data->title_id_list.data(),
+                                               0,
                                                title_count * sizeof(u64));
         async_data->title_info_out = &rp.PopMappedBuffer();
 
@@ -2209,7 +2472,8 @@ void Module::Interface::GetDLCTitleInfos(Kernel::HLERequestContext& ctx) {
                     rb.PushMappedBuffer(*async_data->title_id_list_buffer);
                     rb.PushMappedBuffer(*async_data->title_info_out);
                 } else {
-                    async_data->title_info_out->Write(async_data->out.data(), 0,
+                    async_data->title_info_out->Write(async_data->out.data(),
+                                                      0,
                                                       async_data->out.size());
 
                     IPC::RequestBuilder rb(ctx, 1, 4);
@@ -2220,7 +2484,8 @@ void Module::Interface::GetDLCTitleInfos(Kernel::HLERequestContext& ctx) {
             },
             true);
     } else {
-        struct AsyncData {
+        struct AsyncData
+        {
             Service::FS::MediaType media_type;
             std::vector<u64> title_id_list;
 
@@ -2233,7 +2498,8 @@ void Module::Interface::GetDLCTitleInfos(Kernel::HLERequestContext& ctx) {
         async_data->media_type = media_type;
         async_data->title_id_list.resize(title_count);
         async_data->title_id_list_buffer = &rp.PopMappedBuffer();
-        async_data->title_id_list_buffer->Read(async_data->title_id_list.data(), 0,
+        async_data->title_id_list_buffer->Read(async_data->title_id_list.data(),
+                                               0,
                                                title_count * sizeof(u64));
         async_data->title_info_out = &rp.PopMappedBuffer();
 
@@ -2243,8 +2509,10 @@ void Module::Interface::GetDLCTitleInfos(Kernel::HLERequestContext& ctx) {
                 for (u32 i = 0; i < async_data->title_id_list.size(); i++) {
                     u32 tid_high = static_cast<u32>(async_data->title_id_list[i] >> 32);
                     if (tid_high != TID_HIGH_DLC) {
-                        async_data->res = Result(ErrCodes::InvalidTIDInList, ErrorModule::AM,
-                                                 ErrorSummary::InvalidArgument, ErrorLevel::Usage);
+                        async_data->res = Result(ErrCodes::InvalidTIDInList,
+                                                 ErrorModule::AM,
+                                                 ErrorSummary::InvalidArgument,
+                                                 ErrorLevel::Usage);
                         break;
                     }
                 }
@@ -2257,29 +2525,32 @@ void Module::Interface::GetDLCTitleInfos(Kernel::HLERequestContext& ctx) {
                 // context is present and not committed. If that's the case, return not found
                 for (auto tid : async_data->title_id_list) {
                     for (auto& import_ctx : am->import_title_contexts) {
-                        if (import_ctx.first == tid &&
-                            (import_ctx.second.state ==
-                                 ImportTitleContextState::WAITING_FOR_IMPORT ||
-                             import_ctx.second.state ==
-                                 ImportTitleContextState::WAITING_FOR_COMMIT ||
-                             import_ctx.second.state == ImportTitleContextState::RESUMABLE)) {
+                        if (import_ctx.first == tid
+                            && (import_ctx.second.state
+                                    == ImportTitleContextState::WAITING_FOR_IMPORT
+                                || import_ctx.second.state
+                                       == ImportTitleContextState::WAITING_FOR_COMMIT
+                                || import_ctx.second.state == ImportTitleContextState::RESUMABLE)) {
                             LOG_DEBUG(Service_AM, "title pending commit title_id={:016X}", tid);
-                            async_data->res =
-                                Result(ErrorDescription::NotFound, ErrorModule::AM,
-                                       ErrorSummary::InvalidState, ErrorLevel::Permanent);
+                            async_data->res = Result(ErrorDescription::NotFound,
+                                                     ErrorModule::AM,
+                                                     ErrorSummary::InvalidState,
+                                                     ErrorLevel::Permanent);
                         }
                     }
                 }
 
                 if (async_data->res.IsSuccess()) {
                     async_data->res = GetTitleInfoFromList(async_data->title_id_list,
-                                                           async_data->media_type, async_data->out);
+                                                           async_data->media_type,
+                                                           async_data->out);
                 }
                 return 0;
             },
             [async_data](Kernel::HLERequestContext& ctx) {
                 if (async_data->res.IsSuccess()) {
-                    async_data->title_info_out->Write(async_data->out.data(), 0,
+                    async_data->title_info_out->Write(async_data->out.data(),
+                                                      0,
                                                       async_data->out.size() * sizeof(TitleInfo));
                 }
                 IPC::RequestBuilder rb(ctx, 1, 4);
@@ -2291,7 +2562,8 @@ void Module::Interface::GetDLCTitleInfos(Kernel::HLERequestContext& ctx) {
     }
 }
 
-void Module::Interface::GetPatchTitleInfos(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetPatchTitleInfos(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     auto media_type = static_cast<Service::FS::MediaType>(rp.Pop<u8>());
@@ -2300,7 +2572,8 @@ void Module::Interface::GetPatchTitleInfos(Kernel::HLERequestContext& ctx) {
     LOG_DEBUG(Service_AM, "media_type={}", media_type);
 
     if (artic_client.get()) {
-        struct AsyncData {
+        struct AsyncData
+        {
             u8 media_type;
             std::vector<u64> title_id_list;
 
@@ -2313,7 +2586,8 @@ void Module::Interface::GetPatchTitleInfos(Kernel::HLERequestContext& ctx) {
         async_data->media_type = static_cast<u8>(media_type);
         async_data->title_id_list.resize(title_count);
         async_data->title_id_list_buffer = &rp.PopMappedBuffer();
-        async_data->title_id_list_buffer->Read(async_data->title_id_list.data(), 0,
+        async_data->title_id_list_buffer->Read(async_data->title_id_list.data(),
+                                               0,
                                                title_count * sizeof(u64));
         async_data->title_info_out = &rp.PopMappedBuffer();
 
@@ -2356,7 +2630,8 @@ void Module::Interface::GetPatchTitleInfos(Kernel::HLERequestContext& ctx) {
                     rb.PushMappedBuffer(*async_data->title_id_list_buffer);
                     rb.PushMappedBuffer(*async_data->title_info_out);
                 } else {
-                    async_data->title_info_out->Write(async_data->out.data(), 0,
+                    async_data->title_info_out->Write(async_data->out.data(),
+                                                      0,
                                                       async_data->out.size() * sizeof(TitleInfo));
 
                     IPC::RequestBuilder rb(ctx, 1, 4);
@@ -2367,7 +2642,8 @@ void Module::Interface::GetPatchTitleInfos(Kernel::HLERequestContext& ctx) {
             },
             true);
     } else {
-        struct AsyncData {
+        struct AsyncData
+        {
             Service::FS::MediaType media_type;
             std::vector<u64> title_id_list;
 
@@ -2380,7 +2656,8 @@ void Module::Interface::GetPatchTitleInfos(Kernel::HLERequestContext& ctx) {
         async_data->media_type = media_type;
         async_data->title_id_list.resize(title_count);
         async_data->title_id_list_buffer = &rp.PopMappedBuffer();
-        async_data->title_id_list_buffer->Read(async_data->title_id_list.data(), 0,
+        async_data->title_id_list_buffer->Read(async_data->title_id_list.data(),
+                                               0,
                                                title_count * sizeof(u64));
         async_data->title_info_out = &rp.PopMappedBuffer();
 
@@ -2390,8 +2667,10 @@ void Module::Interface::GetPatchTitleInfos(Kernel::HLERequestContext& ctx) {
                 for (u32 i = 0; i < async_data->title_id_list.size(); i++) {
                     u32 tid_high = static_cast<u32>(async_data->title_id_list[i] >> 32);
                     if (tid_high != TID_HIGH_UPDATE) {
-                        async_data->res = Result(ErrCodes::InvalidTIDInList, ErrorModule::AM,
-                                                 ErrorSummary::InvalidArgument, ErrorLevel::Usage);
+                        async_data->res = Result(ErrCodes::InvalidTIDInList,
+                                                 ErrorModule::AM,
+                                                 ErrorSummary::InvalidArgument,
+                                                 ErrorLevel::Usage);
                         break;
                     }
                 }
@@ -2404,29 +2683,32 @@ void Module::Interface::GetPatchTitleInfos(Kernel::HLERequestContext& ctx) {
                 // context is present and not committed. If that's the case, return not found
                 for (auto tid : async_data->title_id_list) {
                     for (auto& import_ctx : am->import_title_contexts) {
-                        if (import_ctx.first == tid &&
-                            (import_ctx.second.state ==
-                                 ImportTitleContextState::WAITING_FOR_IMPORT ||
-                             import_ctx.second.state ==
-                                 ImportTitleContextState::WAITING_FOR_COMMIT ||
-                             import_ctx.second.state == ImportTitleContextState::RESUMABLE)) {
+                        if (import_ctx.first == tid
+                            && (import_ctx.second.state
+                                    == ImportTitleContextState::WAITING_FOR_IMPORT
+                                || import_ctx.second.state
+                                       == ImportTitleContextState::WAITING_FOR_COMMIT
+                                || import_ctx.second.state == ImportTitleContextState::RESUMABLE)) {
                             LOG_DEBUG(Service_AM, "title pending commit title_id={:016X}", tid);
-                            async_data->res =
-                                Result(ErrorDescription::NotFound, ErrorModule::AM,
-                                       ErrorSummary::InvalidState, ErrorLevel::Permanent);
+                            async_data->res = Result(ErrorDescription::NotFound,
+                                                     ErrorModule::AM,
+                                                     ErrorSummary::InvalidState,
+                                                     ErrorLevel::Permanent);
                         }
                     }
                 }
 
                 if (async_data->res.IsSuccess()) {
                     async_data->res = GetTitleInfoFromList(async_data->title_id_list,
-                                                           async_data->media_type, async_data->out);
+                                                           async_data->media_type,
+                                                           async_data->out);
                 }
                 return 0;
             },
             [async_data](Kernel::HLERequestContext& ctx) {
                 if (async_data->res.IsSuccess()) {
-                    async_data->title_info_out->Write(async_data->out.data(), 0,
+                    async_data->title_info_out->Write(async_data->out.data(),
+                                                      0,
                                                       async_data->out.size() * sizeof(TitleInfo));
                 }
                 IPC::RequestBuilder rb(ctx, 1, 4);
@@ -2438,14 +2720,16 @@ void Module::Interface::GetPatchTitleInfos(Kernel::HLERequestContext& ctx) {
     }
 }
 
-void Module::Interface::ListDataTitleTicketInfos(Kernel::HLERequestContext& ctx) {
+void Module::Interface::ListDataTitleTicketInfos(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     u32 ticket_count = rp.Pop<u32>();
     u64 title_id = rp.Pop<u64>();
     u32 start_index = rp.Pop<u32>();
 
     if (artic_client.get()) {
-        struct AsyncData {
+        struct AsyncData
+        {
             u64 title_id;
             u32 ticket_count;
             u32 start_index;
@@ -2493,7 +2777,8 @@ void Module::Interface::ListDataTitleTicketInfos(Kernel::HLERequestContext& ctx)
             },
             [async_data](Kernel::HLERequestContext& ctx) {
                 if (async_data->res.IsSuccess()) {
-                    async_data->ticket_info_out->Write(async_data->out.data(), 0,
+                    async_data->ticket_info_out->Write(async_data->out.data(),
+                                                       0,
                                                        async_data->out.size());
                 }
                 IPC::RequestBuilder rb(ctx, 2, 0);
@@ -2506,7 +2791,8 @@ void Module::Interface::ListDataTitleTicketInfos(Kernel::HLERequestContext& ctx)
 
         u32 tid_high = static_cast<u32>(title_id >> 32);
         if (tid_high != 0x0004008C && tid_high != 0x0004000D) {
-            LOG_ERROR(Service_AM, "Tried to get infos for non-data title title_id={:016X}",
+            LOG_ERROR(Service_AM,
+                      "Tried to get infos for non-data title title_id={:016X}",
                       title_id);
             IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
             rb.Push(Result(60, ErrorModule::AM, ErrorSummary::InvalidArgument, ErrorLevel::Usage));
@@ -2517,8 +2803,9 @@ void Module::Interface::ListDataTitleTicketInfos(Kernel::HLERequestContext& ctx)
         std::scoped_lock lock(am->am_lists_mutex);
         auto range = am->am_ticket_list.equal_range(title_id);
         auto it = range.first;
-        std::advance(it, std::min(static_cast<size_t>(start_index),
-                                  static_cast<size_t>(std::distance(range.first, range.second))));
+        std::advance(it,
+                     std::min(static_cast<size_t>(start_index),
+                              static_cast<size_t>(std::distance(range.first, range.second))));
 
         u32 written = 0;
         for (; it != range.second && written < ticket_count; it++) {
@@ -2542,7 +2829,8 @@ void Module::Interface::ListDataTitleTicketInfos(Kernel::HLERequestContext& ctx)
     }
 }
 
-void Module::Interface::GetDLCContentInfoCount(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetDLCContentInfoCount(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     auto media_type = static_cast<Service::FS::MediaType>(rp.Pop<u8>());
     u64 title_id = rp.Pop<u64>();
@@ -2550,7 +2838,8 @@ void Module::Interface::GetDLCContentInfoCount(Kernel::HLERequestContext& ctx) {
     LOG_DEBUG(Service_AM, "title_id={:016X}", title_id);
 
     if (artic_client.get()) {
-        struct AsyncData {
+        struct AsyncData
+        {
             u8 media_type;
             u64 title_id;
 
@@ -2598,12 +2887,13 @@ void Module::Interface::GetDLCContentInfoCount(Kernel::HLERequestContext& ctx) {
             },
             true);
     } else {
-
         // Validate that only DLC TIDs are passed in
         u32 tid_high = static_cast<u32>(title_id >> 32);
         if (tid_high != TID_HIGH_DLC) {
             IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-            rb.Push(Result(ErrCodes::InvalidTID, ErrorModule::AM, ErrorSummary::InvalidArgument,
+            rb.Push(Result(ErrCodes::InvalidTID,
+                           ErrorModule::AM,
+                           ErrorSummary::InvalidArgument,
                            ErrorLevel::Usage));
             rb.Push<u32>(0);
             return;
@@ -2619,13 +2909,16 @@ void Module::Interface::GetDLCContentInfoCount(Kernel::HLERequestContext& ctx) {
             rb.Push<u32>(static_cast<u32>(tmd.GetContentCount()));
         } else {
             rb.Push<u32>(1); // Number of content infos plus one
-            LOG_WARNING(Service_AM, "missing TMD media_type={}, title_id=0x{:016x}", media_type,
+            LOG_WARNING(Service_AM,
+                        "missing TMD media_type={}, title_id=0x{:016x}",
+                        media_type,
                         title_id);
         }
     }
 }
 
-void Module::Interface::DeleteTicket(Kernel::HLERequestContext& ctx) {
+void Module::Interface::DeleteTicket(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     u64 title_id = rp.Pop<u64>();
 
@@ -2633,9 +2926,12 @@ void Module::Interface::DeleteTicket(Kernel::HLERequestContext& ctx) {
 
     IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
     std::scoped_lock lock(am->am_lists_mutex);
+#ifdef todotodo
     auto range = am->am_ticket_list.equal_range(title_id);
     if (range.first == range.second) {
-        rb.Push(Result(ErrorDescription::AlreadyDone, ErrorModule::AM, ErrorSummary::Success,
+        rb.Push(Result(ErrorDescription::AlreadyDone,
+                       ErrorModule::AM,
+                       ErrorSummary::Success,
                        ErrorLevel::Success));
         return;
     }
@@ -2646,24 +2942,36 @@ void Module::Interface::DeleteTicket(Kernel::HLERequestContext& ctx) {
     }
 
     am->am_ticket_list.erase(range.first, range.second);
+#endif
 
     rb.Push(ResultSuccess);
+    LOG_WARNING(Service_AM, "(STUBBED) called title_id=0x{:016x}", title_id);
 }
 
-void Module::Interface::GetNumTickets(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetNumTickets(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     LOG_DEBUG(Service_AM, "");
 
     std::scoped_lock lock(am->am_lists_mutex);
+#ifdef todotodo
     u32 ticket_count = static_cast<u32>(am->am_ticket_list.size());
+#else
+    u32 ticket_count = 0;
+    for (const auto& title_list : am->am_title_list) {
+        ticket_count += static_cast<u32>(title_list.size());
+    }
+#endif
 
     IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
     rb.Push(ResultSuccess);
     rb.Push(ticket_count);
+    LOG_WARNING(Service_AM, "(STUBBED) called ticket_count=0x{:08x}", ticket_count);
 }
 
-void Module::Interface::GetTicketList(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetTicketList(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     u32 ticket_list_count = rp.Pop<u32>();
     u32 ticket_index = rp.Pop<u32>();
@@ -2673,6 +2981,7 @@ void Module::Interface::GetTicketList(Kernel::HLERequestContext& ctx) {
 
     u32 tickets_written = 0;
     std::scoped_lock lock(am->am_lists_mutex);
+#ifdef todotodo
     auto it = am->am_ticket_list.begin();
     std::advance(it, std::min(static_cast<size_t>(ticket_index), am->am_ticket_list.size()));
 
@@ -2680,32 +2989,55 @@ void Module::Interface::GetTicketList(Kernel::HLERequestContext& ctx) {
          it++, tickets_written++) {
         ticket_tids_out.Write(&it->first, tickets_written * sizeof(u64), sizeof(u64));
     }
+#else
+    for (const auto& title_list : am->am_title_list) {
+        const auto tickets_to_write = std::min(static_cast<u32>(title_list.size()),
+                                               ticket_list_count - tickets_written);
+        ticket_tids_out.Write(title_list.data(),
+                              tickets_written * sizeof(u64),
+                              tickets_to_write * sizeof(u64));
+        tickets_written += tickets_to_write;
+    }
+#endif
 
     IPC::RequestBuilder rb = rp.MakeBuilder(2, 2);
     rb.Push(ResultSuccess);
     rb.Push(tickets_written);
     rb.PushMappedBuffer(ticket_tids_out);
+    LOG_WARNING(Service_AM,
+                "(STUBBED) ticket_list_count=0x{:08x}, ticket_index=0x{:08x}",
+                ticket_list_count,
+                ticket_index);
 }
 
-void Module::Interface::GetDeviceID(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetDeviceID(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     LOG_DEBUG(Service_AM, "");
 
-    const auto& otp = HW::UniqueData::GetOTP();
-    if (!otp.Valid()) {
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrorDescription::NotFound, ErrorModule::AM, ErrorSummary::NotFound,
-                       ErrorLevel::Permanent));
-        return;
-    }
+    u32 deviceID = am->ct_cert.IsValid() ? am->ct_cert.GetDeviceID() : 0;
 
-    u32 deviceID = otp.GetDeviceID();
-    if (am->force_new_device_id) {
-        deviceID |= 0x80000000;
-    }
-    if (am->force_old_device_id) {
-        deviceID &= ~0x80000000;
+    if (deviceID == 0) {
+        LOG_ERROR(Service_AM, "Invalid or missing CTCert");
+
+        const auto& otp = HW::UniqueData::GetOTP();
+        if (!otp.Valid()) {
+            IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
+            rb.Push(Result(ErrorDescription::NotFound,
+                           ErrorModule::AM,
+                           ErrorSummary::NotFound,
+                           ErrorLevel::Permanent));
+            return;
+        }
+
+        deviceID = otp.GetDeviceID();
+        if (am->force_new_device_id) {
+            deviceID |= 0x80000000;
+        }
+        if (am->force_old_device_id) {
+            deviceID &= ~0x80000000;
+        }
     }
 
     IPC::RequestBuilder rb = rp.MakeBuilder(3, 0);
@@ -2717,40 +3049,44 @@ void Module::Interface::GetDeviceID(Kernel::HLERequestContext& ctx) {
 void Module::Interface::GetNumImportTitleContextsImpl(IPC::RequestParser& rp,
                                                       FS::MediaType media_type,
                                                       bool include_installing,
-                                                      bool include_finalizing) {
-
+                                                      bool include_finalizing)
+{
     IPC::RequestBuilder rb = rp.MakeBuilder(3, 0);
     rb.Push(ResultSuccess);
 
+#ifdef todotodo
     u32 count = 0;
     for (auto it = am->import_title_contexts.begin(); it != am->import_title_contexts.end(); it++) {
-        if ((include_installing &&
-             (it->second.state == ImportTitleContextState::WAITING_FOR_IMPORT ||
-              it->second.state == ImportTitleContextState::RESUMABLE)) ||
-            (include_finalizing &&
-             it->second.state == ImportTitleContextState::WAITING_FOR_COMMIT)) {
+        if ((include_installing
+             && (it->second.state == ImportTitleContextState::WAITING_FOR_IMPORT
+                 || it->second.state == ImportTitleContextState::RESUMABLE))
+            || (include_finalizing
+                && it->second.state == ImportTitleContextState::WAITING_FOR_COMMIT)) {
             count++;
         }
     }
 
     rb.Push<u32>(count);
+#else
+    rb.Push<u32>(static_cast<u32>(am->import_title_contexts.size()));
+#endif
 }
 
 void Module::Interface::GetImportTitleContextListImpl(IPC::RequestParser& rp,
-                                                      FS::MediaType media_type, u32 list_count,
+                                                      FS::MediaType media_type,
+                                                      u32 list_count,
                                                       bool include_installing,
-                                                      bool include_finalizing) {
-
+                                                      bool include_finalizing)
+{
     auto out_buf = rp.PopMappedBuffer();
     u32 written = 0;
 
     for (auto& key_value : am->import_content_contexts) {
-        if ((include_installing &&
-             (key_value.second.state == ImportTitleContextState::WAITING_FOR_IMPORT ||
-              key_value.second.state == ImportTitleContextState::RESUMABLE)) ||
-            (include_finalizing &&
-             key_value.second.state == ImportTitleContextState::WAITING_FOR_COMMIT)) {
-
+        if ((include_installing
+             && (key_value.second.state == ImportTitleContextState::WAITING_FOR_IMPORT
+                 || key_value.second.state == ImportTitleContextState::RESUMABLE))
+            || (include_finalizing
+                && key_value.second.state == ImportTitleContextState::WAITING_FOR_COMMIT)) {
             out_buf.Write(&key_value.first, written * sizeof(u64), sizeof(u64));
             written++;
             if (written >= list_count)
@@ -2763,7 +3099,8 @@ void Module::Interface::GetImportTitleContextListImpl(IPC::RequestParser& rp,
     rb.Push(written);
 }
 
-void Module::Interface::GetNumImportTitleContexts(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetNumImportTitleContexts(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     const FS::MediaType media_type = static_cast<Service::FS::MediaType>(rp.Pop<u8>());
@@ -2773,24 +3110,26 @@ void Module::Interface::GetNumImportTitleContexts(Kernel::HLERequestContext& ctx
     LOG_WARNING(Service_AM, "(STUBBED) media_type={}", media_type);
 }
 
-void Module::Interface::GetImportTitleContextList(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetImportTitleContextList(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     const u32 list_count = rp.Pop<u32>();
-    [[maybe_unused]] const FS::MediaType media_type =
-        static_cast<Service::FS::MediaType>(rp.Pop<u8>());
+    [[maybe_unused]] const FS::MediaType media_type = static_cast<Service::FS::MediaType>(
+        rp.Pop<u8>());
 
     GetImportTitleContextListImpl(rp, media_type, list_count, true, true);
 
     LOG_WARNING(Service_AM, "(STUBBED) media_type={}", media_type);
 }
 
-void Module::Interface::GetImportTitleContexts(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetImportTitleContexts(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     const u32 list_count = rp.Pop<u32>();
-    [[maybe_unused]] const FS::MediaType media_type =
-        static_cast<Service::FS::MediaType>(rp.Pop<u8>());
+    [[maybe_unused]] const FS::MediaType media_type = static_cast<Service::FS::MediaType>(
+        rp.Pop<u8>());
 
     auto in_buf = rp.PopMappedBuffer();
     auto out_buf = rp.PopMappedBuffer();
@@ -2807,11 +3146,14 @@ void Module::Interface::GetImportTitleContexts(Kernel::HLERequestContext& ctx) {
 
         auto it = am->import_title_contexts.find(title_id);
         if (it == am->import_title_contexts.end()) {
-            rb.Push(Result(ErrorDescription::NotFound, ErrorModule::AM, ErrorSummary::InvalidState,
+            rb.Push(Result(ErrorDescription::NotFound,
+                           ErrorModule::AM,
+                           ErrorSummary::InvalidState,
                            ErrorLevel::Permanent));
             return;
         } else {
-            out_buf.Write(&it->second, written * sizeof(ImportTitleContext),
+            out_buf.Write(&it->second,
+                          written * sizeof(ImportTitleContext),
                           sizeof(ImportTitleContext));
             written++;
         }
@@ -2820,7 +3162,8 @@ void Module::Interface::GetImportTitleContexts(Kernel::HLERequestContext& ctx) {
     rb.Push(ResultSuccess);
 }
 
-void Module::Interface::DeleteImportTitleContext(Kernel::HLERequestContext& ctx) {
+void Module::Interface::DeleteImportTitleContext(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const FS::MediaType media_type = static_cast<Service::FS::MediaType>(rp.Pop<u8>());
     const u64 title_id = rp.Pop<u64>();
@@ -2830,7 +3173,9 @@ void Module::Interface::DeleteImportTitleContext(Kernel::HLERequestContext& ctx)
     IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
     auto range = am->import_title_contexts.equal_range(title_id);
     if (range.first == range.second) {
-        rb.Push(Result(ErrorDescription::NotFound, ErrorModule::AM, ErrorSummary::InvalidState,
+        rb.Push(Result(ErrorDescription::NotFound,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
                        ErrorLevel::Permanent));
         return;
     }
@@ -2839,17 +3184,21 @@ void Module::Interface::DeleteImportTitleContext(Kernel::HLERequestContext& ctx)
     rb.Push(ResultSuccess);
 }
 
-void Module::Interface::GetNumImportContentContextsImpl(IPC::RequestParser& rp, u64 title_id,
-                                                        FS::MediaType media_type) {
-
+void Module::Interface::GetNumImportContentContextsImpl(IPC::RequestParser& rp,
+                                                        u64 title_id,
+                                                        FS::MediaType media_type)
+{
     IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
     rb.Push(ResultSuccess);
     auto range = am->import_content_contexts.equal_range(title_id);
     rb.Push(static_cast<u32>(std::distance(range.first, range.second)));
 }
 
-void Module::Interface::GetImportContentContextListImpl(IPC::RequestParser& rp, u32 list_count,
-                                                        u64 title_id, FS::MediaType media_type) {
+void Module::Interface::GetImportContentContextListImpl(IPC::RequestParser& rp,
+                                                        u32 list_count,
+                                                        u64 title_id,
+                                                        FS::MediaType media_type)
+{
     auto out_buf = rp.PopMappedBuffer();
 
     auto range = am->import_content_contexts.equal_range(title_id);
@@ -2865,8 +3214,11 @@ void Module::Interface::GetImportContentContextListImpl(IPC::RequestParser& rp,
     rb.Push(written);
 }
 
-void Module::Interface::GetImportContentContextsImpl(IPC::RequestParser& rp, u32 list_count,
-                                                     u64 title_id, FS::MediaType media_type) {
+void Module::Interface::GetImportContentContextsImpl(IPC::RequestParser& rp,
+                                                     u32 list_count,
+                                                     u64 title_id,
+                                                     FS::MediaType media_type)
+{
     auto in_buf = rp.PopMappedBuffer();
     auto out_buf = rp.PopMappedBuffer();
 
@@ -2885,7 +3237,9 @@ void Module::Interface::GetImportContentContextsImpl(IPC::RequestParser& rp, u32
                 break;
 
         if (it == range.second) {
-            rb.Push(Result(ErrorDescription::NotFound, ErrorModule::AM, ErrorSummary::InvalidState,
+            rb.Push(Result(ErrorDescription::NotFound,
+                           ErrorModule::AM,
+                           ErrorSummary::InvalidState,
                            ErrorLevel::Permanent));
             return;
         }
@@ -2896,7 +3250,8 @@ void Module::Interface::GetImportContentContextsImpl(IPC::RequestParser& rp, u32
     rb.Push(ResultSuccess);
 }
 
-void Module::Interface::GetNumImportContentContexts(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetNumImportContentContexts(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const FS::MediaType media_type = static_cast<Service::FS::MediaType>(rp.Pop<u8>());
     const u64 title_id = rp.Pop<u64>();
@@ -2906,7 +3261,8 @@ void Module::Interface::GetNumImportContentContexts(Kernel::HLERequestContext& c
     LOG_WARNING(Service_AM, "(STUBBED) media_type={} title_id={:016X}", media_type, title_id);
 }
 
-void Module::Interface::GetImportContentContextList(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetImportContentContextList(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const u32 list_count = rp.Pop<u32>();
     const FS::MediaType media_type = static_cast<Service::FS::MediaType>(rp.Pop<u8>());
@@ -2917,7 +3273,8 @@ void Module::Interface::GetImportContentContextList(Kernel::HLERequestContext& c
     LOG_WARNING(Service_AM, "(STUBBED) media_type={} title_id={:016X}", media_type, title_id);
 }
 
-void Module::Interface::GetImportContentContexts(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetImportContentContexts(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const u32 list_count = rp.Pop<u32>();
     const FS::MediaType media_type = static_cast<Service::FS::MediaType>(rp.Pop<u8>());
@@ -2928,16 +3285,18 @@ void Module::Interface::GetImportContentContexts(Kernel::HLERequestContext& ctx)
     GetImportContentContextsImpl(rp, list_count, title_id, media_type);
 }
 
-void Module::Interface::NeedsCleanup(Kernel::HLERequestContext& ctx) {
+void Module::Interface::NeedsCleanup(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const auto media_type = rp.Pop<u8>();
 
     LOG_DEBUG(Service_AM, "(STUBBED) media_type=0x{:02x}", media_type);
 
+#ifdef todotodo
     bool needs_cleanup = false;
     for (auto& import_ctx : am->import_title_contexts) {
-        if (import_ctx.second.state == ImportTitleContextState::RESUMABLE ||
-            import_ctx.second.state == ImportTitleContextState::WAITING_FOR_IMPORT) {
+        if (import_ctx.second.state == ImportTitleContextState::RESUMABLE
+            || import_ctx.second.state == ImportTitleContextState::WAITING_FOR_IMPORT) {
             needs_cleanup = true;
             break;
         }
@@ -2945,28 +3304,35 @@ void Module::Interface::NeedsCleanup(Kernel::HLERequestContext& ctx) {
 
     if (!needs_cleanup) {
         for (auto& import_ctx : am->import_content_contexts) {
-            if (import_ctx.second.state == ImportTitleContextState::RESUMABLE ||
-                import_ctx.second.state == ImportTitleContextState::WAITING_FOR_IMPORT) {
+            if (import_ctx.second.state == ImportTitleContextState::RESUMABLE
+                || import_ctx.second.state == ImportTitleContextState::WAITING_FOR_IMPORT) {
                 needs_cleanup = true;
             }
         }
     }
+#endif
 
     IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
     rb.Push(ResultSuccess);
+#ifdef todotodo
     rb.Push<bool>(needs_cleanup);
+#else
+    rb.Push<bool>(false);
+#endif
 }
 
-void Module::Interface::DoCleanup(Kernel::HLERequestContext& ctx) {
+void Module::Interface::DoCleanup(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const auto media_type = rp.Pop<u8>();
 
     LOG_DEBUG(Service_AM, "(STUBBED) called, media_type={:#02x}", media_type);
 
+#ifdef todotodo
     for (auto it = am->import_content_contexts.begin(); it != am->import_content_contexts.end();) {
-        if (it->second.state == ImportTitleContextState::RESUMABLE ||
-            it->second.state == ImportTitleContextState::WAITING_FOR_IMPORT ||
-            it->second.state == ImportTitleContextState::NEEDS_CLEANUP) {
+        if (it->second.state == ImportTitleContextState::RESUMABLE
+            || it->second.state == ImportTitleContextState::WAITING_FOR_IMPORT
+            || it->second.state == ImportTitleContextState::NEEDS_CLEANUP) {
             it = am->import_content_contexts.erase(it);
         } else {
             it++;
@@ -2974,13 +3340,13 @@ void Module::Interface::DoCleanup(Kernel::HLERequestContext& ctx) {
     }
 
     for (auto it = am->import_title_contexts.begin(); it != am->import_title_contexts.end();) {
-        if (it->second.state == ImportTitleContextState::RESUMABLE ||
-            it->second.state == ImportTitleContextState::WAITING_FOR_IMPORT ||
-            it->second.state == ImportTitleContextState::NEEDS_CLEANUP) {
+        if (it->second.state == ImportTitleContextState::RESUMABLE
+            || it->second.state == ImportTitleContextState::WAITING_FOR_IMPORT
+            || it->second.state == ImportTitleContextState::NEEDS_CLEANUP) {
             if (am->importing_title) {
-                if (am->importing_title->title_id == it->second.title_id &&
-                    am->importing_title->media_type ==
-                        static_cast<Service::FS::MediaType>(media_type)) {
+                if (am->importing_title->title_id == it->second.title_id
+                    && am->importing_title->media_type
+                           == static_cast<Service::FS::MediaType>(media_type)) {
                     am->importing_title.reset();
                 }
             }
@@ -2989,12 +3355,14 @@ void Module::Interface::DoCleanup(Kernel::HLERequestContext& ctx) {
             it++;
         }
     }
+#endif
 
     IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
     rb.Push(ResultSuccess);
 }
 
-void Module::Interface::QueryAvailableTitleDatabase(Kernel::HLERequestContext& ctx) {
+void Module::Interface::QueryAvailableTitleDatabase(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     u8 media_type = rp.Pop<u8>();
 
@@ -3005,10 +3373,13 @@ void Module::Interface::QueryAvailableTitleDatabase(Kernel::HLERequestContext& c
     LOG_WARNING(Service_AM, "(STUBBED) media_type={}", media_type);
 }
 
-void Module::Interface::GetPersonalizedTicketInfoList(Kernel::HLERequestContext& ctx) {
+#ifdef todotodo
+void Module::Interface::GetPersonalizedTicketInfoList(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
-    struct AsyncData {
+    struct AsyncData
+    {
         u32 ticket_count;
 
         std::vector<TicketInfo> out;
@@ -3027,15 +3398,16 @@ void Module::Interface::GetPersonalizedTicketInfoList(Kernel::HLERequestContext&
             u32 written = 0;
             std::scoped_lock lock(am->am_lists_mutex);
             for (auto it = am->am_ticket_list.begin();
-                 it != am->am_ticket_list.end() && written < async_data->ticket_count; it++) {
+                 it != am->am_ticket_list.end() && written < async_data->ticket_count;
+                 it++) {
                 u64 title_id = it->first;
                 u32 tid_high = static_cast<u32>(title_id << 32);
                 if ((tid_high & 0x00048010) == 0x00040010 || (tid_high & 0x00048001) == 0x00048001)
                     continue;
 
                 FileSys::Ticket ticket;
-                if (ticket.Load(title_id, it->second) != Loader::ResultStatus::Success ||
-                    !ticket.IsPersonal())
+                if (ticket.Load(title_id, it->second) != Loader::ResultStatus::Success
+                    || !ticket.IsPersonal())
                     continue;
 
                 TicketInfo info = {};
@@ -3052,7 +3424,8 @@ void Module::Interface::GetPersonalizedTicketInfoList(Kernel::HLERequestContext&
         [async_data](Kernel::HLERequestContext& ctx) {
             u32 written = 0;
             for (auto& info : async_data->out) {
-                async_data->out_buffer->Write(&info, written * sizeof(TicketInfo),
+                async_data->out_buffer->Write(&info,
+                                              written * sizeof(TicketInfo),
                                               sizeof(TicketInfo));
                 written++;
             }
@@ -3064,33 +3437,86 @@ void Module::Interface::GetPersonalizedTicketInfoList(Kernel::HLERequestContext&
         true);
 }
 
-void Module::Interface::GetNumImportTitleContextsFiltered(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetNumImportTitleContextsFiltered(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     const FS::MediaType media_type = static_cast<Service::FS::MediaType>(rp.Pop<u8>());
     const u8 filter = rp.Pop<u8>();
 
-    GetNumImportTitleContextsImpl(rp, media_type, (filter & (1 << 0)) != 0,
+    GetNumImportTitleContextsImpl(rp,
+                                  media_type,
+                                  (filter & (1 << 0)) != 0,
                                   (filter & (1 << 1)) != 0);
 
     LOG_WARNING(Service_AM, "(STUBBED) called, media_type={}, filter={}", media_type, filter);
 }
 
-void Module::Interface::GetImportTitleContextListFiltered(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetImportTitleContextListFiltered(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     const u32 list_count = rp.Pop<u32>();
-    [[maybe_unused]] const FS::MediaType media_type =
-        static_cast<Service::FS::MediaType>(rp.Pop<u8>());
+    [[maybe_unused]] const FS::MediaType media_type = static_cast<Service::FS::MediaType>(
+        rp.Pop<u8>());
     const u8 filter = rp.Pop<u8>();
 
-    GetImportTitleContextListImpl(rp, media_type, list_count, (filter & (1 << 0)) != 0,
+    GetImportTitleContextListImpl(rp,
+                                  media_type,
+                                  list_count,
+                                  (filter & (1 << 0)) != 0,
                                   (filter & (1 << 1)) != 0);
 
     LOG_WARNING(Service_AM, "(STUBBED) called, media_type={}, filter={}", media_type, filter);
 }
+#else
+void Module::Interface::GetPersonalizedTicketInfoList(Kernel::HLERequestContext& ctx)
+{
+    IPC::RequestParser rp(ctx);
+    [[maybe_unused]] u32 ticket_count = rp.Pop<u32>();
+    [[maybe_unused]] auto& buffer = rp.PopMappedBuffer();
+
+    std::scoped_lock lock(am->am_lists_mutex);
+
+    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
+    rb.Push(ResultSuccess); // No error
+    rb.Push(0);
+
+    LOG_WARNING(Service_AM, "(STUBBED) called, ticket_count={}", ticket_count);
+}
+
+void Module::Interface::GetNumImportTitleContextsFiltered(Kernel::HLERequestContext& ctx)
+{
+    IPC::RequestParser rp(ctx);
+    u8 media_type = rp.Pop<u8>();
+    u8 filter = rp.Pop<u8>();
+
+    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
+    rb.Push(ResultSuccess); // No error
+    rb.Push(0);
+
+    LOG_WARNING(Service_AM, "(STUBBED) called, media_type={}, filter={}", media_type, filter);
+}
+
+void Module::Interface::GetImportTitleContextListFiltered(Kernel::HLERequestContext& ctx)
+{
+    IPC::RequestParser rp(ctx);
+    [[maybe_unused]] const u32 count = rp.Pop<u32>();
+    const u8 media_type = rp.Pop<u8>();
+    const u8 filter = rp.Pop<u8>();
+    auto& buffer = rp.PopMappedBuffer();
+
+    IPC::RequestBuilder rb = rp.MakeBuilder(2, 2);
+    rb.Push(ResultSuccess); // No error
+    rb.Push(0);
+    rb.PushMappedBuffer(buffer);
+
+    LOG_WARNING(Service_AM, "(STUBBED) called, media_type={}, filter={}", media_type, filter);
+}
+#endif
 
-void Module::Interface::CheckContentRights(Kernel::HLERequestContext& ctx) {
+void Module::Interface::CheckContentRights(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     u64 tid = rp.Pop<u64>();
     u16 content_index = rp.Pop<u16>();
@@ -3099,8 +3525,8 @@ void Module::Interface::CheckContentRights(Kernel::HLERequestContext& ctx) {
     FileSys::Ticket ticket;
     std::scoped_lock lock(am->am_lists_mutex);
     auto entries = am->am_ticket_list.find(tid);
-    if (entries != am->am_ticket_list.end() &&
-        ticket.Load(tid, (*entries).second) == Loader::ResultStatus::Success) {
+    if (entries != am->am_ticket_list.end()
+        && ticket.Load(tid, (*entries).second) == Loader::ResultStatus::Success) {
         has_ticket = true;
     }
 
@@ -3113,7 +3539,8 @@ void Module::Interface::CheckContentRights(Kernel::HLERequestContext& ctx) {
     LOG_DEBUG(Service_AM, "tid={:016x}, content_index={}", tid, content_index);
 }
 
-void Module::Interface::CheckContentRightsIgnorePlatform(Kernel::HLERequestContext& ctx) {
+void Module::Interface::CheckContentRightsIgnorePlatform(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     u64 tid = rp.Pop<u64>();
     u16 content_index = rp.Pop<u16>();
@@ -3122,8 +3549,8 @@ void Module::Interface::CheckContentRightsIgnorePlatform(Kernel::HLERequestConte
     FileSys::Ticket ticket;
     std::scoped_lock lock(am->am_lists_mutex);
     auto entries = am->am_ticket_list.find(tid);
-    if (entries != am->am_ticket_list.end() &&
-        ticket.Load(tid, (*entries).second) == Loader::ResultStatus::Success) {
+    if (entries != am->am_ticket_list.end()
+        && ticket.Load(tid, (*entries).second) == Loader::ResultStatus::Success) {
         has_ticket = true;
     }
 
@@ -3136,22 +3563,34 @@ void Module::Interface::CheckContentRightsIgnorePlatform(Kernel::HLERequestConte
     LOG_DEBUG(Service_AM, "tid={:016x}, content_index={}", tid, content_index);
 }
 
-void Module::Interface::BeginImportProgram(Kernel::HLERequestContext& ctx) {
+void Module::Interface::BeginImportProgram(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     auto media_type = static_cast<Service::FS::MediaType>(rp.Pop<u8>());
 
     if (am->cia_installing) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidImportState, ErrorModule::AM, ErrorSummary::InvalidState,
+#ifdef todotodo
+        rb.Push(Result(ErrCodes::InvalidImportState,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
                        ErrorLevel::Permanent));
+#else
+        rb.Push(Result(ErrCodes::CIACurrentlyInstalling,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
+                       ErrorLevel::Permanent));
+#endif
         return;
     }
 
     // Create our CIAFile handle for the app to write to, and while the app writes
     // Citra will store contents out to sdmc/nand
     const FileSys::Path cia_path = {};
-    auto file = std::make_shared<Service::FS::File>(
-        am->system.Kernel(), std::make_unique<CIAFile>(am->system, media_type), cia_path);
+    auto file = std::make_shared<Service::FS::File>(am->system.Kernel(),
+                                                    std::make_unique<CIAFile>(am->system,
+                                                                              media_type),
+                                                    cia_path);
 
     am->cia_installing = true;
 
@@ -3162,13 +3601,23 @@ void Module::Interface::BeginImportProgram(Kernel::HLERequestContext& ctx) {
     LOG_WARNING(Service_AM, "(STUBBED) media_type={}", media_type);
 }
 
-void Module::Interface::BeginImportProgramTemporarily(Kernel::HLERequestContext& ctx) {
+void Module::Interface::BeginImportProgramTemporarily(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     if (am->cia_installing) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidImportState, ErrorModule::AM, ErrorSummary::InvalidState,
+#ifdef todotodo
+        rb.Push(Result(ErrCodes::InvalidImportState,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
+                       ErrorLevel::Permanent));
+#else
+        rb.Push(Result(ErrCodes::CIACurrentlyInstalling,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
                        ErrorLevel::Permanent));
+#endif
         return;
     }
 
@@ -3177,8 +3626,10 @@ void Module::Interface::BeginImportProgramTemporarily(Kernel::HLERequestContext&
     // Create our CIAFile handle for the app to write to, and while the app writes Citra will store
     // contents out to sdmc/nand
     const FileSys::Path cia_path = {};
-    auto file = std::make_shared<Service::FS::File>(
-        am->system.Kernel(), std::make_unique<CIAFile>(am->system, FS::MediaType::NAND), cia_path);
+    auto file = std::make_shared<Service::FS::File>(am->system.Kernel(),
+                                                    std::make_unique<CIAFile>(am->system,
+                                                                              FS::MediaType::NAND),
+                                                    cia_path);
 
     am->cia_installing = true;
 
@@ -3189,7 +3640,8 @@ void Module::Interface::BeginImportProgramTemporarily(Kernel::HLERequestContext&
     LOG_WARNING(Service_AM, "(STUBBED)");
 }
 
-void Module::Interface::EndImportProgram(Kernel::HLERequestContext& ctx) {
+void Module::Interface::EndImportProgram(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     [[maybe_unused]] const auto cia = rp.PopObject<Kernel::ClientSession>();
 
@@ -3202,7 +3654,8 @@ void Module::Interface::EndImportProgram(Kernel::HLERequestContext& ctx) {
     rb.Push(ResultSuccess);
 }
 
-void Module::Interface::EndImportProgramWithoutCommit(Kernel::HLERequestContext& ctx) {
+void Module::Interface::EndImportProgramWithoutCommit(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     [[maybe_unused]] const auto cia = rp.PopObject<Kernel::ClientSession>();
 
@@ -3217,34 +3670,56 @@ void Module::Interface::EndImportProgramWithoutCommit(Kernel::HLERequestContext&
     LOG_WARNING(Service_AM, "(STUBBED)");
 }
 
-void Module::Interface::CommitImportPrograms(Kernel::HLERequestContext& ctx) {
+void Module::Interface::CommitImportPrograms(Kernel::HLERequestContext& ctx)
+{
+#ifdef todotodo
     CommitImportTitlesImpl(ctx, false, false);
+#else
+    IPC::RequestParser rp(ctx);
+    [[maybe_unused]] const auto media_type = static_cast<FS::MediaType>(rp.Pop<u8>());
+    [[maybe_unused]] const u32 title_count = rp.Pop<u32>();
+    [[maybe_unused]] const u8 database = rp.Pop<u8>();
+    const auto buffer = rp.PopMappedBuffer();
+
+    // Note: This function is basically a no-op for us since we don't use title.db or ticket.db
+    // files to keep track of installed titles.
+    am->ScanForAllTitles();
+
+    IPC::RequestBuilder rb = rp.MakeBuilder(1, 2);
+    rb.Push(ResultSuccess);
+    rb.PushMappedBuffer(buffer);
+
+    LOG_WARNING(Service_AM, "(STUBBED)");
+#endif
 }
 
 /// Wraps all File operations to allow adding an offset to them.
-class AMFileWrapper : public FileSys::FileBackend {
+class AMFileWrapper : public FileSys::FileBackend
+{
 public:
     AMFileWrapper(std::shared_ptr<Service::FS::File> file, std::size_t offset, std::size_t size)
-        : file(std::move(file)), file_offset(offset), file_size(size) {}
+        : file(std::move(file))
+        , file_offset(offset)
+        , file_size(size)
+    {}
 
-    ResultVal<std::size_t> Read(u64 offset, std::size_t length, u8* buffer) const override {
+    ResultVal<std::size_t> Read(u64 offset, std::size_t length, u8* buffer) const override
+    {
         return file->backend->Read(offset + file_offset, length, buffer);
     }
 
-    ResultVal<std::size_t> Write(u64 offset, std::size_t length, bool flush, bool update_timestamp,
-                                 const u8* buffer) override {
+    ResultVal<std::size_t> Write(u64 offset,
+                                 std::size_t length,
+                                 bool flush,
+                                 bool update_timestamp,
+                                 const u8* buffer) override
+    {
         return file->backend->Write(offset + file_offset, length, flush, update_timestamp, buffer);
     }
 
-    u64 GetSize() const override {
-        return file_size;
-    }
-    bool SetSize(u64 size) const override {
-        return false;
-    }
-    bool Close() override {
-        return false;
-    }
+    u64 GetSize() const override { return file_size; }
+    bool SetSize(u64 size) const override { return false; }
+    bool Close() override { return false; }
     void Flush() const override {}
 
 private:
@@ -3254,7 +3729,8 @@ private:
 };
 
 ResultVal<std::unique_ptr<AMFileWrapper>> GetCiaFileFromSession(
-    std::shared_ptr<Kernel::ClientSession> file_session) {
+    std::shared_ptr<Kernel::ClientSession> file_session)
+{
     // Step up the chain from ClientSession->ServerSession and then
     // cast to File. For AM on 3DS, invalid handles actually hang the system.
 
@@ -3263,8 +3739,7 @@ ResultVal<std::unique_ptr<AMFileWrapper>> GetCiaFileFromSession(
         return Kernel::ResultInvalidHandle;
     }
 
-    std::shared_ptr<Kernel::ServerSession> server =
-        Kernel::SharedFrom(file_session->parent->server);
+    std::shared_ptr<Kernel::ServerSession> server = Kernel::SharedFrom(file_session->parent->server);
     if (server == nullptr) {
         LOG_WARNING(Service_AM, "File handle ServerSession disconnected!");
         return Kernel::ResultSessionClosed;
@@ -3292,8 +3767,9 @@ ResultVal<std::unique_ptr<AMFileWrapper>> GetCiaFileFromSession(
     return Kernel::ResultNotImplemented;
 }
 
-template <typename T>
-ResultVal<T*> GetFileBackendFromSession(std::shared_ptr<Kernel::ClientSession> file_session) {
+template<typename T>
+ResultVal<T*> GetFileBackendFromSession(std::shared_ptr<Kernel::ClientSession> file_session)
+{
     // Step up the chain from ClientSession->ServerSession and then
     // cast to file backend. For AM on 3DS, invalid handles actually hang the system.
 
@@ -3302,8 +3778,7 @@ ResultVal<T*> GetFileBackendFromSession(std::shared_ptr<Kernel::ClientSession> f
         return Kernel::ResultInvalidHandle;
     }
 
-    std::shared_ptr<Kernel::ServerSession> server =
-        Kernel::SharedFrom(file_session->parent->server);
+    std::shared_ptr<Kernel::ServerSession> server = Kernel::SharedFrom(file_session->parent->server);
     if (server == nullptr) {
         LOG_WARNING(Service_AM, "File handle ServerSession disconnected!");
         return Kernel::ResultSessionClosed;
@@ -3336,7 +3811,8 @@ ResultVal<T*> GetFileBackendFromSession(std::shared_ptr<Kernel::ClientSession> f
     return Kernel::ResultNotImplemented;
 }
 
-void Module::Interface::GetProgramInfoFromCia(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetProgramInfoFromCia(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     [[maybe_unused]] const auto media_type = static_cast<FS::MediaType>(rp.Pop<u8>());
     auto cia = rp.PopObject<Kernel::ClientSession>();
@@ -3353,7 +3829,9 @@ void Module::Interface::GetProgramInfoFromCia(Kernel::HLERequestContext& ctx) {
     FileSys::CIAContainer container;
     if (container.Load(*file_res.Unwrap()) != Loader::ResultStatus::Success) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        rb.Push(Result(ErrCodes::InvalidCIAHeader,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidArgument,
                        ErrorLevel::Permanent));
         return;
     }
@@ -3375,7 +3853,8 @@ void Module::Interface::GetProgramInfoFromCia(Kernel::HLERequestContext& ctx) {
     rb.PushRaw<TitleInfo>(title_info);
 }
 
-void Module::Interface::GetSystemMenuDataFromCia(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetSystemMenuDataFromCia(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     auto cia = rp.PopObject<Kernel::ClientSession>();
     auto& output_buffer = rp.PopMappedBuffer();
@@ -3396,7 +3875,9 @@ void Module::Interface::GetSystemMenuDataFromCia(Kernel::HLERequestContext& ctx)
     FileSys::CIAContainer container;
     if (container.Load(*file) != Loader::ResultStatus::Success) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 2);
-        rb.Push(Result(ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        rb.Push(Result(ErrCodes::InvalidCIAHeader,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidArgument,
                        ErrorLevel::Permanent));
         rb.PushMappedBuffer(output_buffer);
         return;
@@ -3405,10 +3886,13 @@ void Module::Interface::GetSystemMenuDataFromCia(Kernel::HLERequestContext& ctx)
 
     //  Read from the Meta offset + 0x400 for the 0x36C0-large SMDH
     auto read_result = file->Read(container.GetMetadataOffset() + FileSys::CIA_METADATA_SIZE,
-                                  temp.size(), temp.data());
+                                  temp.size(),
+                                  temp.data());
     if (read_result.Failed() || *read_result != temp.size()) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 2);
-        rb.Push(Result(ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        rb.Push(Result(ErrCodes::InvalidCIAHeader,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidArgument,
                        ErrorLevel::Permanent));
         rb.PushMappedBuffer(output_buffer);
         return;
@@ -3421,7 +3905,8 @@ void Module::Interface::GetSystemMenuDataFromCia(Kernel::HLERequestContext& ctx)
     rb.PushMappedBuffer(output_buffer);
 }
 
-void Module::Interface::GetDependencyListFromCia(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetDependencyListFromCia(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     auto cia = rp.PopObject<Kernel::ClientSession>();
 
@@ -3437,7 +3922,9 @@ void Module::Interface::GetDependencyListFromCia(Kernel::HLERequestContext& ctx)
     FileSys::CIAContainer container;
     if (container.Load(*file_res.Unwrap()) != Loader::ResultStatus::Success) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        rb.Push(Result(ErrCodes::InvalidCIAHeader,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidArgument,
                        ErrorLevel::Permanent));
         return;
     }
@@ -3450,7 +3937,8 @@ void Module::Interface::GetDependencyListFromCia(Kernel::HLERequestContext& ctx)
     rb.PushStaticBuffer(std::move(buffer), 0);
 }
 
-void Module::Interface::GetTransferSizeFromCia(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetTransferSizeFromCia(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     auto cia = rp.PopObject<Kernel::ClientSession>();
 
@@ -3466,7 +3954,9 @@ void Module::Interface::GetTransferSizeFromCia(Kernel::HLERequestContext& ctx) {
     FileSys::CIAContainer container;
     if (container.Load(*file_res.Unwrap()) != Loader::ResultStatus::Success) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        rb.Push(Result(ErrCodes::InvalidCIAHeader,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidArgument,
                        ErrorLevel::Permanent));
         return;
     }
@@ -3476,7 +3966,8 @@ void Module::Interface::GetTransferSizeFromCia(Kernel::HLERequestContext& ctx) {
     rb.Push(container.GetMetadataOffset());
 }
 
-void Module::Interface::GetCoreVersionFromCia(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetCoreVersionFromCia(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     auto cia = rp.PopObject<Kernel::ClientSession>();
 
@@ -3492,7 +3983,9 @@ void Module::Interface::GetCoreVersionFromCia(Kernel::HLERequestContext& ctx) {
     FileSys::CIAContainer container;
     if (container.Load(*file_res.Unwrap()) != Loader::ResultStatus::Success) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        rb.Push(Result(ErrCodes::InvalidCIAHeader,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidArgument,
                        ErrorLevel::Permanent));
         return;
     }
@@ -3502,7 +3995,8 @@ void Module::Interface::GetCoreVersionFromCia(Kernel::HLERequestContext& ctx) {
     rb.Push(container.GetCoreVersion());
 }
 
-void Module::Interface::GetRequiredSizeFromCia(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetRequiredSizeFromCia(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     [[maybe_unused]] const auto media_type = static_cast<FS::MediaType>(rp.Pop<u8>());
     auto cia = rp.PopObject<Kernel::ClientSession>();
@@ -3519,7 +4013,9 @@ void Module::Interface::GetRequiredSizeFromCia(Kernel::HLERequestContext& ctx) {
     FileSys::CIAContainer container;
     if (container.Load(*file_res.Unwrap()) != Loader::ResultStatus::Success) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        rb.Push(Result(ErrCodes::InvalidCIAHeader,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidArgument,
                        ErrorLevel::Permanent));
         return;
     }
@@ -3532,19 +4028,25 @@ void Module::Interface::GetRequiredSizeFromCia(Kernel::HLERequestContext& ctx) {
     rb.Push(container.GetTitleMetadata().GetContentSizeByIndex(FileSys::TMDContentIndex::Main));
 }
 
-void Module::Interface::CommitImportProgramsAndUpdateFirmwareAuto(Kernel::HLERequestContext& ctx) {
+void Module::Interface::CommitImportProgramsAndUpdateFirmwareAuto(Kernel::HLERequestContext& ctx)
+{
     CommitImportTitlesImpl(ctx, true, false);
 }
 
 void Module::Interface::CommitImportTitlesImpl(Kernel::HLERequestContext& ctx,
-                                               bool is_update_firm_auto, bool is_titles) {
+                                               bool is_update_firm_auto,
+                                               bool is_titles)
+{
     IPC::RequestParser rp(ctx);
     const auto media_type = static_cast<FS::MediaType>(rp.Pop<u8>());
     [[maybe_unused]] u32 count = rp.Pop<u32>();
     bool cleanup = rp.Pop<bool>();
 
-    LOG_WARNING(Service_AM, "(STUBBED) update_firm_auto={} is_titles={} cleanup={}",
-                is_update_firm_auto, is_titles, cleanup);
+    LOG_WARNING(Service_AM,
+                "(STUBBED) update_firm_auto={} is_titles={} cleanup={}",
+                is_update_firm_auto,
+                is_titles,
+                cleanup);
 
     auto& title_id_buf = rp.PopMappedBuffer();
 
@@ -3552,16 +4054,16 @@ void Module::Interface::CommitImportTitlesImpl(Kernel::HLERequestContext& ctx,
     title_id_buf.Read(title_ids.data(), 0, title_id_buf.GetSize());
 
     for (auto& key_value : am->import_content_contexts) {
-        if (std::find(title_ids.begin(), title_ids.end(), key_value.first) != title_ids.end() &&
-            key_value.second.state == ImportTitleContextState::WAITING_FOR_COMMIT) {
+        if (std::find(title_ids.begin(), title_ids.end(), key_value.first) != title_ids.end()
+            && key_value.second.state == ImportTitleContextState::WAITING_FOR_COMMIT) {
             key_value.second.state = ImportTitleContextState::NEEDS_CLEANUP;
         }
     }
 
     for (auto tid : title_ids) {
         auto it = am->import_title_contexts.find(tid);
-        if (it != am->import_title_contexts.end() &&
-            it->second.state == ImportTitleContextState::WAITING_FOR_COMMIT) {
+        if (it != am->import_title_contexts.end()
+            && it->second.state == ImportTitleContextState::WAITING_FOR_COMMIT) {
             it->second.state = ImportTitleContextState::NEEDS_CLEANUP;
         }
     }
@@ -3569,9 +4071,9 @@ void Module::Interface::CommitImportTitlesImpl(Kernel::HLERequestContext& ctx,
     if (cleanup) {
         for (auto it = am->import_content_contexts.begin();
              it != am->import_content_contexts.end();) {
-            if (it->second.state == ImportTitleContextState::RESUMABLE ||
-                it->second.state == ImportTitleContextState::WAITING_FOR_IMPORT ||
-                it->second.state == ImportTitleContextState::NEEDS_CLEANUP) {
+            if (it->second.state == ImportTitleContextState::RESUMABLE
+                || it->second.state == ImportTitleContextState::WAITING_FOR_IMPORT
+                || it->second.state == ImportTitleContextState::NEEDS_CLEANUP) {
                 it = am->import_content_contexts.erase(it);
             } else {
                 it++;
@@ -3579,9 +4081,9 @@ void Module::Interface::CommitImportTitlesImpl(Kernel::HLERequestContext& ctx,
         }
 
         for (auto it = am->import_title_contexts.begin(); it != am->import_title_contexts.end();) {
-            if (it->second.state == ImportTitleContextState::RESUMABLE ||
-                it->second.state == ImportTitleContextState::WAITING_FOR_IMPORT ||
-                it->second.state == ImportTitleContextState::NEEDS_CLEANUP) {
+            if (it->second.state == ImportTitleContextState::RESUMABLE
+                || it->second.state == ImportTitleContextState::WAITING_FOR_IMPORT
+                || it->second.state == ImportTitleContextState::NEEDS_CLEANUP) {
                 it = am->import_title_contexts.erase(it);
             } else {
                 it++;
@@ -3595,22 +4097,28 @@ void Module::Interface::CommitImportTitlesImpl(Kernel::HLERequestContext& ctx,
     rb.Push(ResultSuccess);
 }
 
-Result UninstallProgram(const FS::MediaType media_type, const u64 title_id) {
+Result UninstallProgram(const FS::MediaType media_type, const u64 title_id)
+{
     // Use the content folder so we don't delete the user's save data.
     const auto path = GetTitlePath(media_type, title_id) + "content/";
     if (!FileUtil::Exists(path)) {
-        return {ErrorDescription::NotFound, ErrorModule::AM, ErrorSummary::InvalidState,
+        return {ErrorDescription::NotFound,
+                ErrorModule::AM,
+                ErrorSummary::InvalidState,
                 ErrorLevel::Permanent};
     }
     if (!FileUtil::DeleteDirRecursively(path)) {
         // TODO: Determine the right error code for this.
-        return {ErrorDescription::NotFound, ErrorModule::AM, ErrorSummary::InvalidState,
+        return {ErrorDescription::NotFound,
+                ErrorModule::AM,
+                ErrorSummary::InvalidState,
                 ErrorLevel::Permanent};
     }
     return ResultSuccess;
 }
 
-void Module::Interface::DeleteProgram(Kernel::HLERequestContext& ctx) {
+void Module::Interface::DeleteProgram(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const auto media_type = rp.PopEnum<FS::MediaType>();
     const auto title_id = rp.Pop<u64>();
@@ -3624,7 +4132,8 @@ void Module::Interface::DeleteProgram(Kernel::HLERequestContext& ctx) {
     rb.Push(result);
 }
 
-void Module::Interface::GetSystemUpdaterMutex(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetSystemUpdaterMutex(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     LOG_DEBUG(Service_AM, "");
@@ -3634,7 +4143,8 @@ void Module::Interface::GetSystemUpdaterMutex(Kernel::HLERequestContext& ctx) {
     rb.PushCopyObjects(am->system_updater_mutex);
 }
 
-void Module::Interface::GetMetaSizeFromCia(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetMetaSizeFromCia(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     auto cia = rp.PopObject<Kernel::ClientSession>();
 
@@ -3649,9 +4159,10 @@ void Module::Interface::GetMetaSizeFromCia(Kernel::HLERequestContext& ctx) {
 
     FileSys::CIAContainer container;
     if (container.Load(*file_res.Unwrap()) != Loader::ResultStatus::Success) {
-
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        rb.Push(Result(ErrCodes::InvalidCIAHeader,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidArgument,
                        ErrorLevel::Permanent));
         return;
     }
@@ -3661,7 +4172,8 @@ void Module::Interface::GetMetaSizeFromCia(Kernel::HLERequestContext& ctx) {
     rb.Push(container.GetMetadataSize());
 }
 
-void Module::Interface::GetMetaDataFromCia(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetMetaDataFromCia(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     u32 output_size = rp.Pop<u32>();
@@ -3684,7 +4196,9 @@ void Module::Interface::GetMetaDataFromCia(Kernel::HLERequestContext& ctx) {
     FileSys::CIAContainer container;
     if (container.Load(*file) != Loader::ResultStatus::Success) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 2);
-        rb.Push(Result(ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        rb.Push(Result(ErrCodes::InvalidCIAHeader,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidArgument,
                        ErrorLevel::Permanent));
         rb.PushMappedBuffer(output_buffer);
         return;
@@ -3695,7 +4209,9 @@ void Module::Interface::GetMetaDataFromCia(Kernel::HLERequestContext& ctx) {
     auto read_result = file->Read(container.GetMetadataOffset(), output_size, temp.data());
     if (read_result.Failed() || *read_result != output_size) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidCIAHeader, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        rb.Push(Result(ErrCodes::InvalidCIAHeader,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidArgument,
                        ErrorLevel::Permanent));
         return;
     }
@@ -3706,27 +4222,34 @@ void Module::Interface::GetMetaDataFromCia(Kernel::HLERequestContext& ctx) {
     rb.PushMappedBuffer(output_buffer);
 }
 
-void Module::Interface::BeginImportTicket(Kernel::HLERequestContext& ctx) {
+void Module::Interface::BeginImportTicket(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     LOG_DEBUG(Service_AM, "");
 
     // Create our TicketFile handle for the app to write to
-    auto file = std::make_shared<Service::FS::File>(
-        am->system.Kernel(), std::make_unique<TicketFile>(), FileSys::Path{});
+    auto file = std::make_shared<Service::FS::File>(am->system.Kernel(),
+                                                    std::make_unique<TicketFile>(),
+                                                    FileSys::Path{});
 
     IPC::RequestBuilder rb = rp.MakeBuilder(1, 2);
     rb.Push(ResultSuccess); // No error
     rb.PushCopyObjects(file->Connect());
+
+    LOG_WARNING(Service_AM, "(STUBBED) called");
 }
 
-void Module::Interface::EndImportTicket(Kernel::HLERequestContext& ctx) {
+#ifdef todotodo
+void Module::Interface::EndImportTicket(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const auto ticket = rp.PopObject<Kernel::ClientSession>();
 
     auto ticket_file = GetFileBackendFromSession<TicketFile>(ticket);
     if (ticket_file.Succeeded()) {
-        struct AsyncData {
+        struct AsyncData
+        {
             Service::AM::TicketFile* ticket_file;
 
             Result res{0};
@@ -3742,7 +4265,8 @@ void Module::Interface::EndImportTicket(Kernel::HLERequestContext& ctx) {
                 am->am_ticket_list.insert(std::make_pair(async_data->ticket_file->GetTitleID(),
                                                          async_data->ticket_file->GetTicketID()));
 
-                LOG_DEBUG(Service_AM, "EndImportTicket: title_id={:016X} ticket_id={:016X}",
+                LOG_DEBUG(Service_AM,
+                          "EndImportTicket: title_id={:016X} ticket_id={:016X}",
                           async_data->ticket_file->GetTitleID(),
                           async_data->ticket_file->GetTicketID());
                 return 0;
@@ -3757,8 +4281,21 @@ void Module::Interface::EndImportTicket(Kernel::HLERequestContext& ctx) {
         rb.Push(ticket_file.Code());
     }
 }
+#else
+void Module::Interface::EndImportTicket(Kernel::HLERequestContext& ctx)
+{
+    IPC::RequestParser rp(ctx);
+    [[maybe_unused]] const auto ticket = rp.PopObject<Kernel::ClientSession>();
 
-void Module::Interface::BeginImportTitle(Kernel::HLERequestContext& ctx) {
+    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
+    rb.Push(ResultSuccess);
+
+    LOG_WARNING(Service_AM, "(STUBBED) called");
+}
+#endif
+
+void Module::Interface::BeginImportTitle(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const auto media_type = static_cast<FS::MediaType>(rp.Pop<u8>());
     const u64 title_id = rp.Pop<u64>();
@@ -3768,8 +4305,9 @@ void Module::Interface::BeginImportTitle(Kernel::HLERequestContext& ctx) {
 
     IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
 
-    am->importing_title =
-        std::make_shared<CurrentImportingTitle>(Core::System::GetInstance(), title_id, media_type);
+    am->importing_title = std::make_shared<CurrentImportingTitle>(Core::System::GetInstance(),
+                                                                  title_id,
+                                                                  media_type);
 
     std::scoped_lock lock(am->am_lists_mutex);
     auto entries = am->am_ticket_list.find(title_id);
@@ -3797,7 +4335,8 @@ void Module::Interface::BeginImportTitle(Kernel::HLERequestContext& ctx) {
     rb.Push(ResultSuccess);
 }
 
-void Module::Interface::StopImportTitle(Kernel::HLERequestContext& ctx) {
+void Module::Interface::StopImportTitle(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     if (!am->importing_title) {
@@ -3818,14 +4357,15 @@ void Module::Interface::StopImportTitle(Kernel::HLERequestContext& ctx) {
     LOG_WARNING(Service_AM, "(STUBBED)");
 }
 
-void Module::Interface::ResumeImportTitle(Kernel::HLERequestContext& ctx) {
+void Module::Interface::ResumeImportTitle(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     const auto media_type = static_cast<FS::MediaType>(rp.Pop<u8>());
     const u64 title_id = rp.Pop<u64>();
 
-    if (!am->importing_title || am->importing_title->title_id != title_id ||
-        am->importing_title->media_type != media_type) {
+    if (!am->importing_title || am->importing_title->title_id != title_id
+        || am->importing_title->media_type != media_type) {
         // Not importing a title
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
         rb.Push(ResultUnknown);
@@ -3833,8 +4373,8 @@ void Module::Interface::ResumeImportTitle(Kernel::HLERequestContext& ctx) {
     }
 
     auto it = am->import_title_contexts.find(am->importing_title->title_id);
-    if (it == am->import_title_contexts.end() ||
-        it->second.state != ImportTitleContextState::RESUMABLE) {
+    if (it == am->import_title_contexts.end()
+        || it->second.state != ImportTitleContextState::RESUMABLE) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
         rb.Push(ResultUnknown);
         return;
@@ -3848,7 +4388,8 @@ void Module::Interface::ResumeImportTitle(Kernel::HLERequestContext& ctx) {
     LOG_WARNING(Service_AM, "(STUBBED) title_id={:016X}", title_id);
 }
 
-void Module::Interface::CancelImportTitle(Kernel::HLERequestContext& ctx) {
+void Module::Interface::CancelImportTitle(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     if (!am->importing_title) {
@@ -3869,7 +4410,8 @@ void Module::Interface::CancelImportTitle(Kernel::HLERequestContext& ctx) {
     rb.Push(ResultSuccess);
 }
 
-void Module::Interface::EndImportTitle(Kernel::HLERequestContext& ctx) {
+void Module::Interface::EndImportTitle(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     LOG_DEBUG(Service_AM, "");
@@ -3887,17 +4429,20 @@ void Module::Interface::EndImportTitle(Kernel::HLERequestContext& ctx) {
     }
 
     am->importing_title->cia_file.SetDone();
+    am->ScanForTitles(am->importing_title->media_type);
     am->importing_title.reset();
 
     IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
     rb.Push(ResultSuccess);
 }
 
-void Module::Interface::CommitImportTitles(Kernel::HLERequestContext& ctx) {
+void Module::Interface::CommitImportTitles(Kernel::HLERequestContext& ctx)
+{
     CommitImportTitlesImpl(ctx, false, true);
 }
 
-void Module::Interface::BeginImportTmd(Kernel::HLERequestContext& ctx) {
+void Module::Interface::BeginImportTmd(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     LOG_DEBUG(Service_AM, "");
@@ -3910,15 +4455,17 @@ void Module::Interface::BeginImportTmd(Kernel::HLERequestContext& ctx) {
     }
 
     // Create our TMD handle for the app to write to
-    auto file = std::make_shared<Service::FS::File>(
-        am->system.Kernel(), std::make_unique<TMDFile>(am->importing_title), FileSys::Path{});
+    auto file = std::make_shared<Service::FS::File>(am->system.Kernel(),
+                                                    std::make_unique<TMDFile>(am->importing_title),
+                                                    FileSys::Path{});
 
     IPC::RequestBuilder rb = rp.MakeBuilder(1, 2);
     rb.Push(ResultSuccess); // No error
     rb.PushCopyObjects(file->Connect());
 }
 
-void Module::Interface::EndImportTmd(Kernel::HLERequestContext& ctx) {
+void Module::Interface::EndImportTmd(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const bool create_context = rp.Pop<bool>();
     const auto tmd = rp.PopObject<Kernel::ClientSession>();
@@ -3927,14 +4474,17 @@ void Module::Interface::EndImportTmd(Kernel::HLERequestContext& ctx) {
 
     if (!am->importing_title) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidImportState, ErrorModule::AM, ErrorSummary::InvalidState,
+        rb.Push(Result(ErrCodes::InvalidImportState,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
                        ErrorLevel::Permanent));
         return;
     }
 
     auto tmd_file = GetFileBackendFromSession<TMDFile>(tmd);
     if (tmd_file.Succeeded()) {
-        struct AsyncData {
+        struct AsyncData
+        {
             Service::AM::TMDFile* tmd_file;
             [[maybe_unused]] bool create_context;
 
@@ -3989,7 +4539,8 @@ void Module::Interface::EndImportTmd(Kernel::HLERequestContext& ctx) {
     }
 }
 
-void Module::Interface::CreateImportContentContexts(Kernel::HLERequestContext& ctx) {
+void Module::Interface::CreateImportContentContexts(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const u32 content_count = rp.Pop<u32>();
     auto content_buf = rp.PopMappedBuffer();
@@ -3998,12 +4549,15 @@ void Module::Interface::CreateImportContentContexts(Kernel::HLERequestContext& c
 
     if (!am->importing_title) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidImportState, ErrorModule::AM, ErrorSummary::InvalidState,
+        rb.Push(Result(ErrCodes::InvalidImportState,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
                        ErrorLevel::Permanent));
         return;
     }
 
-    struct AsyncData {
+    struct AsyncData
+    {
         std::vector<u16> content_indices;
 
         Result res{0};
@@ -4019,11 +4573,13 @@ void Module::Interface::CreateImportContentContexts(Kernel::HLERequestContext& c
                                                             am->importing_title->title_id);
                 FileSys::TitleMetadata tmd;
                 if (tmd.Load(tmd_path) != Loader::ResultStatus::Success) {
-                    LOG_ERROR(Service_AM, "Couldn't load TMD for title_id={:016X}, mediatype={}",
-                              am->importing_title->title_id, am->importing_title->media_type);
+                    LOG_ERROR(Service_AM,
+                              "Couldn't load TMD for title_id={:016X}, mediatype={}",
+                              am->importing_title->title_id,
+                              am->importing_title->media_type);
 
-                    async_data->res =
-                        Result(0xFFFFFFFF); // TODO(PabloMK7): Find the right error code
+                    async_data->res = Result(
+                        0xFFFFFFFF); // TODO(PabloMK7): Find the right error code
                     return 0;
                 }
                 am->importing_title->cia_file.ProvideTMDForAdditionalContent(tmd);
@@ -4035,9 +4591,10 @@ void Module::Interface::CreateImportContentContexts(Kernel::HLERequestContext& c
                 if (index > tmd.GetContentCount()) {
                     LOG_ERROR(Service_AM,
                               "Tried to create context for invalid index title_id={:016x} index={}",
-                              am->importing_title->title_id, index);
-                    async_data->res =
-                        Result(0xFFFFFFFF); // TODO(PabloMK7): Find the right error code
+                              am->importing_title->title_id,
+                              index);
+                    async_data->res = Result(
+                        0xFFFFFFFF); // TODO(PabloMK7): Find the right error code
                     return 0;
                 }
                 ImportContentContext content_context;
@@ -4058,7 +4615,8 @@ void Module::Interface::CreateImportContentContexts(Kernel::HLERequestContext& c
         true);
 }
 
-void Module::Interface::BeginImportContent(Kernel::HLERequestContext& ctx) {
+void Module::Interface::BeginImportContent(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     const u16 content_index = rp.Pop<u16>();
@@ -4086,17 +4644,19 @@ void Module::Interface::BeginImportContent(Kernel::HLERequestContext& ctx) {
     }
 
     // Create our TMD handle for the app to write to
-    auto file = std::make_shared<Service::FS::File>(
-        am->system.Kernel(),
-        std::make_unique<ContentFile>(am->importing_title, content_index, it->second),
-        FileSys::Path{});
+    auto file = std::make_shared<Service::FS::File>(am->system.Kernel(),
+                                                    std::make_unique<ContentFile>(am->importing_title,
+                                                                                  content_index,
+                                                                                  it->second),
+                                                    FileSys::Path{});
 
     IPC::RequestBuilder rb = rp.MakeBuilder(1, 2);
     rb.Push(ResultSuccess); // No error
     rb.PushCopyObjects(file->Connect());
 }
 
-void Module::Interface::ResumeImportContent(Kernel::HLERequestContext& ctx) {
+void Module::Interface::ResumeImportContent(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     const u16 content_index = rp.Pop<u16>();
@@ -4125,12 +4685,14 @@ void Module::Interface::ResumeImportContent(Kernel::HLERequestContext& ctx) {
 
     it->second.state = ImportTitleContextState::WAITING_FOR_IMPORT;
 
-    auto content_file =
-        std::make_unique<ContentFile>(am->importing_title, content_index, it->second);
+    auto content_file = std::make_unique<ContentFile>(am->importing_title,
+                                                      content_index,
+                                                      it->second);
     content_file->SetWritten(it->second.current_size);
 
     // Create our TMD handle for the app to write to
-    auto file = std::make_shared<Service::FS::File>(am->system.Kernel(), std::move(content_file),
+    auto file = std::make_shared<Service::FS::File>(am->system.Kernel(),
+                                                    std::move(content_file),
                                                     FileSys::Path{});
 
     IPC::RequestBuilder rb = rp.MakeBuilder(3, 2);
@@ -4139,7 +4701,8 @@ void Module::Interface::ResumeImportContent(Kernel::HLERequestContext& ctx) {
     rb.PushCopyObjects(file->Connect());
 }
 
-void Module::Interface::StopImportContent(Kernel::HLERequestContext& ctx) {
+void Module::Interface::StopImportContent(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const auto content = rp.PopObject<Kernel::ClientSession>();
     IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
@@ -4163,7 +4726,8 @@ void Module::Interface::StopImportContent(Kernel::HLERequestContext& ctx) {
     rb.Push(ResultSuccess);
 }
 
-void Module::Interface::CancelImportContent(Kernel::HLERequestContext& ctx) {
+void Module::Interface::CancelImportContent(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const auto content = rp.PopObject<Kernel::ClientSession>();
     IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
@@ -4188,7 +4752,8 @@ void Module::Interface::CancelImportContent(Kernel::HLERequestContext& ctx) {
     rb.Push(ResultSuccess);
 }
 
-void Module::Interface::EndImportContent(Kernel::HLERequestContext& ctx) {
+void Module::Interface::EndImportContent(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const auto content = rp.PopObject<Kernel::ClientSession>();
     IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
@@ -4212,46 +4777,58 @@ void Module::Interface::EndImportContent(Kernel::HLERequestContext& ctx) {
     rb.Push(ResultSuccess);
 }
 
-void Module::Interface::GetNumCurrentImportContentContexts(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetNumCurrentImportContentContexts(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     if (!am->importing_title) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidImportState, ErrorModule::AM, ErrorSummary::InvalidState,
+        rb.Push(Result(ErrCodes::InvalidImportState,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
                        ErrorLevel::Permanent));
         return;
     }
 
-    GetNumImportContentContextsImpl(rp, am->importing_title->title_id,
+    GetNumImportContentContextsImpl(rp,
+                                    am->importing_title->title_id,
                                     am->importing_title->media_type);
 
     LOG_WARNING(Service_AM, "(STUBBED) title_id={:016X}", am->importing_title->title_id);
 }
 
-void Module::Interface::GetCurrentImportContentContextList(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetCurrentImportContentContextList(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     if (!am->importing_title) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidImportState, ErrorModule::AM, ErrorSummary::InvalidState,
+        rb.Push(Result(ErrCodes::InvalidImportState,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
                        ErrorLevel::Permanent));
         return;
     }
 
     const u32 list_count = rp.Pop<u32>();
 
-    GetImportContentContextListImpl(rp, list_count, am->importing_title->title_id,
+    GetImportContentContextListImpl(rp,
+                                    list_count,
+                                    am->importing_title->title_id,
                                     am->importing_title->media_type);
 
     LOG_WARNING(Service_AM, "(STUBBED) title_id={:016X}", am->importing_title->title_id);
 }
 
-void Module::Interface::GetCurrentImportContentContexts(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetCurrentImportContentContexts(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     if (!am->importing_title) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidImportState, ErrorModule::AM, ErrorSummary::InvalidState,
+        rb.Push(Result(ErrCodes::InvalidImportState,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
                        ErrorLevel::Permanent));
         return;
     }
@@ -4260,11 +4837,14 @@ void Module::Interface::GetCurrentImportContentContexts(Kernel::HLERequestContex
 
     LOG_WARNING(Service_AM, "(STUBBED) title_id={:016X}", am->importing_title->title_id);
 
-    GetImportContentContextsImpl(rp, list_count, am->importing_title->title_id,
+    GetImportContentContextsImpl(rp,
+                                 list_count,
+                                 am->importing_title->title_id,
                                  am->importing_title->media_type);
 }
 
-void Module::Interface::Sign(Kernel::HLERequestContext& ctx) {
+void Module::Interface::Sign(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     size_t signature_size = rp.Pop<u32>();
     size_t certificate_size = rp.Pop<u32>();
@@ -4283,15 +4863,18 @@ void Module::Interface::Sign(Kernel::HLERequestContext& ctx) {
     FileSys::Certificate& ct_cert = HW::UniqueData::GetCTCert();
     if (!ct_cert.IsValid()) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrorDescription::NotFound, ErrorModule::AM, ErrorSummary::NotFound,
+        rb.Push(Result(ErrorDescription::NotFound,
+                       ErrorModule::AM,
+                       ErrorSummary::NotFound,
                        ErrorLevel::Permanent));
         return;
     }
 
     FileSys::Certificate ap_cert;
-    std::string new_issuer_str =
-        fmt::format("{}-{}", reinterpret_cast<const char*>(ct_cert.GetIssuer().data()),
-                    reinterpret_cast<const char*>(ct_cert.GetName().data()));
+    std::string new_issuer_str
+        = fmt::format("{}-{}",
+                      reinterpret_cast<const char*>(ct_cert.GetIssuer().data()),
+                      reinterpret_cast<const char*>(ct_cert.GetName().data()));
     std::string new_name_str = fmt::format("AP{:016x}", title_id);
 
     std::array<u8, 0x40> new_issuer = {0};
@@ -4312,18 +4895,22 @@ void Module::Interface::Sign(Kernel::HLERequestContext& ctx) {
     rb.Push(0);
 }
 
-template <class Archive>
-void Module::serialize(Archive& ar, const unsigned int) {
+template<class Archive>
+void Module::serialize(Archive& ar, const unsigned int)
+{
     std::scoped_lock lock(am_lists_mutex);
     DEBUG_SERIALIZATION_POINT;
     ar & cia_installing;
     ar & force_old_device_id;
     ar & force_new_device_id;
+    ar & am_title_list;
     ar & system_updater_mutex;
 }
 SERIALIZE_IMPL(Module)
 
-void Module::Interface::GetDeviceCert(Kernel::HLERequestContext& ctx) {
+#ifdef todotodo
+void Module::Interface::GetDeviceCert(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     [[maybe_unused]] u32 size = rp.Pop<u32>();
     auto buffer = rp.PopMappedBuffer();
@@ -4333,7 +4920,9 @@ void Module::Interface::GetDeviceCert(Kernel::HLERequestContext& ctx) {
     const auto& ct_cert = HW::UniqueData::GetCTCert();
     if (!ct_cert.IsValid()) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrorDescription::NotFound, ErrorModule::AM, ErrorSummary::NotFound,
+        rb.Push(Result(ErrorDescription::NotFound,
+                       ErrorModule::AM,
+                       ErrorSummary::NotFound,
                        ErrorLevel::Permanent));
         return;
     }
@@ -4346,12 +4935,63 @@ void Module::Interface::GetDeviceCert(Kernel::HLERequestContext& ctx) {
     rb.Push(0);
     rb.PushMappedBuffer(buffer);
 }
+#else
+void Module::Interface::GetDeviceCert(Kernel::HLERequestContext& ctx)
+{
+    IPC::RequestParser rp(ctx);
+    [[maybe_unused]] u32 size = rp.Pop<u32>();
+    auto buffer = rp.PopMappedBuffer();
+
+    if (!am->ct_cert.IsValid()) {
+        LOG_ERROR(Service_AM, "Invalid or missing CTCert");
+    }
 
-void Module::Interface::CommitImportTitlesAndUpdateFirmwareAuto(Kernel::HLERequestContext& ctx) {
+    buffer.Write(&am->ct_cert, 0, std::min(sizeof(CTCert), buffer.GetSize()));
+    IPC::RequestBuilder rb = rp.MakeBuilder(2, 2);
+    rb.Push(ResultSuccess);
+    rb.Push(0);
+    rb.PushMappedBuffer(buffer);
+}
+#endif
+
+std::string Module::GetCTCertPath()
+{
+    return FileUtil::GetUserPath(FileUtil::UserPath::SysDataDir) + "CTCert.bin";
+}
+
+CTCertLoadStatus Module::LoadCTCertFile(CTCert& output)
+{
+    if (output.IsValid()) {
+        return CTCertLoadStatus::Loaded;
+    }
+    std::string file_path = GetCTCertPath();
+    if (!FileUtil::Exists(file_path)) {
+        return CTCertLoadStatus::NotFound;
+    }
+    FileUtil::IOFile file(file_path, "rb");
+    if (!file.IsOpen()) {
+        return CTCertLoadStatus::IOError;
+    }
+    if (file.GetSize() != sizeof(CTCert)) {
+        return CTCertLoadStatus::Invalid;
+    }
+    if (file.ReadBytes(&output, sizeof(CTCert)) != sizeof(CTCert)) {
+        return CTCertLoadStatus::IOError;
+    }
+    if (!output.IsValid()) {
+        output = CTCert();
+        return CTCertLoadStatus::Invalid;
+    }
+    return CTCertLoadStatus::Loaded;
+}
+
+void Module::Interface::CommitImportTitlesAndUpdateFirmwareAuto(Kernel::HLERequestContext& ctx)
+{
     CommitImportTitlesImpl(ctx, true, true);
 }
 
-void Module::Interface::DeleteTicketId(Kernel::HLERequestContext& ctx) {
+void Module::Interface::DeleteTicketId(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     u64 title_id = rp.Pop<u64>();
     u64 ticket_id = rp.Pop<u64>();
@@ -4368,7 +5008,9 @@ void Module::Interface::DeleteTicketId(Kernel::HLERequestContext& ctx) {
         }
     }
     if (range.first == range.second) {
-        rb.Push(Result(ErrorDescription::AlreadyDone, ErrorModule::AM, ErrorSummary::Success,
+        rb.Push(Result(ErrorDescription::AlreadyDone,
+                       ErrorModule::AM,
+                       ErrorSummary::Success,
                        ErrorLevel::Success));
         return;
     }
@@ -4376,12 +5018,17 @@ void Module::Interface::DeleteTicketId(Kernel::HLERequestContext& ctx) {
     auto path = GetTicketPath(title_id, ticket_id);
     FileUtil::Delete(path);
 
+#ifdef todotodo
     am->am_ticket_list.erase(it);
+#else
+    am->ScanForTickets();
+#endif
 
     rb.Push(ResultSuccess);
 }
 
-void Module::Interface::GetNumTicketIds(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetNumTicketIds(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     u64 title_id = rp.Pop<u64>();
 
@@ -4396,7 +5043,8 @@ void Module::Interface::GetNumTicketIds(Kernel::HLERequestContext& ctx) {
     rb.Push(count);
 }
 
-void Module::Interface::GetTicketIdList(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetTicketIdList(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const u32 list_count = rp.Pop<u32>();
     const u64 title_id = rp.Pop<u64>();
@@ -4409,7 +5057,8 @@ void Module::Interface::GetTicketIdList(Kernel::HLERequestContext& ctx) {
     u32 index = 0;
     std::scoped_lock lock(am->am_lists_mutex);
     for (auto [it, rangeEnd] = am->am_ticket_list.equal_range(title_id);
-         it != rangeEnd && index < list_count; index++, it++) {
+         it != rangeEnd && index < list_count;
+         index++, it++) {
         u64 ticket_id = it->second;
         out_buf.Write(&ticket_id, index * sizeof(u64), sizeof(u64));
     }
@@ -4419,7 +5068,8 @@ void Module::Interface::GetTicketIdList(Kernel::HLERequestContext& ctx) {
     rb.Push(index);
 }
 
-void Module::Interface::GetNumTicketsOfProgram(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetNumTicketsOfProgram(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     u64 title_id = rp.Pop<u64>();
 
@@ -4434,7 +5084,8 @@ void Module::Interface::GetNumTicketsOfProgram(Kernel::HLERequestContext& ctx) {
     rb.Push(count);
 }
 
-void Module::Interface::ListTicketInfos(Kernel::HLERequestContext& ctx) {
+void Module::Interface::ListTicketInfos(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     u32 ticket_count = rp.Pop<u32>();
     u64 title_id = rp.Pop<u64>();
@@ -4446,8 +5097,9 @@ void Module::Interface::ListTicketInfos(Kernel::HLERequestContext& ctx) {
     std::scoped_lock lock(am->am_lists_mutex);
     auto range = am->am_ticket_list.equal_range(title_id);
     auto it = range.first;
-    std::advance(it, std::min(static_cast<size_t>(skip),
-                              static_cast<size_t>(std::distance(range.first, range.second))));
+    std::advance(it,
+                 std::min(static_cast<size_t>(skip),
+                          static_cast<size_t>(std::distance(range.first, range.second))));
 
     u32 written = 0;
     for (; it != range.second && written < ticket_count; it++) {
@@ -4470,7 +5122,8 @@ void Module::Interface::ListTicketInfos(Kernel::HLERequestContext& ctx) {
     rb.Push(written);
 }
 
-void Module::Interface::GetNumCurrentContentInfos(Kernel::HLERequestContext& ctx) {
+void Module::Interface::GetNumCurrentContentInfos(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     LOG_DEBUG(Service_AM, "");
@@ -4487,7 +5140,8 @@ void Module::Interface::GetNumCurrentContentInfos(Kernel::HLERequestContext& ctx
     rb.Push(static_cast<u32>(am->importing_title->cia_file.GetTMD().GetContentCount()));
 }
 
-void Module::Interface::FindCurrentContentInfos(Kernel::HLERequestContext& ctx) {
+void Module::Interface::FindCurrentContentInfos(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     LOG_DEBUG(Service_AM, "");
@@ -4499,7 +5153,8 @@ void Module::Interface::FindCurrentContentInfos(Kernel::HLERequestContext& ctx)
         return;
     }
 
-    struct AsyncData {
+    struct AsyncData
+    {
         u32 content_count;
         std::vector<u16_le> content_requested;
 
@@ -4512,7 +5167,8 @@ void Module::Interface::FindCurrentContentInfos(Kernel::HLERequestContext& ctx)
 
     auto& content_requested_in = rp.PopMappedBuffer();
     async_data->content_requested.resize(async_data->content_count);
-    content_requested_in.Read(async_data->content_requested.data(), 0,
+    content_requested_in.Read(async_data->content_requested.data(),
+                              0,
                               async_data->content_count * sizeof(u16));
     async_data->content_info_out = &rp.PopMappedBuffer();
 
@@ -4540,16 +5196,17 @@ void Module::Interface::FindCurrentContentInfos(Kernel::HLERequestContext& ctx)
                 content_info.ownership = ticket.HasRights(index) ? OWNERSHIP_OWNED : 0;
 
                 if (FileUtil::Exists(GetTitleContentPath(am->importing_title->media_type,
-                                                         am->importing_title->title_id, index))) {
+                                                         am->importing_title->title_id,
+                                                         index))) {
                     bool pending = false;
                     for (auto& import_ctx : am->import_content_contexts) {
-                        if (import_ctx.first == am->importing_title->title_id &&
-                            import_ctx.second.index == index &&
-                            (import_ctx.second.state ==
-                                 ImportTitleContextState::WAITING_FOR_IMPORT ||
-                             import_ctx.second.state ==
-                                 ImportTitleContextState::WAITING_FOR_COMMIT ||
-                             import_ctx.second.state == ImportTitleContextState::RESUMABLE)) {
+                        if (import_ctx.first == am->importing_title->title_id
+                            && import_ctx.second.index == index
+                            && (import_ctx.second.state
+                                    == ImportTitleContextState::WAITING_FOR_IMPORT
+                                || import_ctx.second.state
+                                       == ImportTitleContextState::WAITING_FOR_COMMIT
+                                || import_ctx.second.state == ImportTitleContextState::RESUMABLE)) {
                             LOG_DEBUG(Service_AM, "content pending commit index={:016X}", index);
                             pending = true;
                             break;
@@ -4567,15 +5224,17 @@ void Module::Interface::FindCurrentContentInfos(Kernel::HLERequestContext& ctx)
             IPC::RequestBuilder rb(ctx, 1, 0);
             rb.Push(async_data->res);
             if (async_data->res.IsSuccess()) {
-                async_data->content_info_out->Write(async_data->out_vec.data(), 0,
-                                                    async_data->out_vec.size() *
-                                                        sizeof(ContentInfo));
+                async_data->content_info_out->Write(async_data->out_vec.data(),
+                                                    0,
+                                                    async_data->out_vec.size()
+                                                        * sizeof(ContentInfo));
             }
         },
         true);
 }
 
-void Module::Interface::ListCurrentContentInfos(Kernel::HLERequestContext& ctx) {
+void Module::Interface::ListCurrentContentInfos(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     LOG_DEBUG(Service_AM, "");
@@ -4587,7 +5246,8 @@ void Module::Interface::ListCurrentContentInfos(Kernel::HLERequestContext& ctx)
         return;
     }
 
-    struct AsyncData {
+    struct AsyncData
+    {
         u32 content_count;
         u32 start_index;
 
@@ -4613,20 +5273,21 @@ void Module::Interface::ListCurrentContentInfos(Kernel::HLERequestContext& ctx)
                 content_info.type = tmd.GetContentTypeByIndex(i);
                 content_info.content_id = tmd.GetContentIDByIndex(i);
                 content_info.size = tmd.GetContentSizeByIndex(i);
-                content_info.ownership =
-                    ticket.HasRights(static_cast<u16>(i)) ? OWNERSHIP_OWNED : 0;
+                content_info.ownership = ticket.HasRights(static_cast<u16>(i)) ? OWNERSHIP_OWNED
+                                                                               : 0;
 
                 if (FileUtil::Exists(GetTitleContentPath(am->importing_title->media_type,
-                                                         am->importing_title->title_id, i))) {
+                                                         am->importing_title->title_id,
+                                                         i))) {
                     bool pending = false;
                     for (auto& import_ctx : am->import_content_contexts) {
-                        if (import_ctx.first == am->importing_title->title_id &&
-                            import_ctx.second.index == i &&
-                            (import_ctx.second.state ==
-                                 ImportTitleContextState::WAITING_FOR_IMPORT ||
-                             import_ctx.second.state ==
-                                 ImportTitleContextState::WAITING_FOR_COMMIT ||
-                             import_ctx.second.state == ImportTitleContextState::RESUMABLE)) {
+                        if (import_ctx.first == am->importing_title->title_id
+                            && import_ctx.second.index == i
+                            && (import_ctx.second.state
+                                    == ImportTitleContextState::WAITING_FOR_IMPORT
+                                || import_ctx.second.state
+                                       == ImportTitleContextState::WAITING_FOR_COMMIT
+                                || import_ctx.second.state == ImportTitleContextState::RESUMABLE)) {
                             LOG_DEBUG(Service_AM, "content pending commit index={:016X}", i);
                             pending = true;
                             break;
@@ -4646,15 +5307,17 @@ void Module::Interface::ListCurrentContentInfos(Kernel::HLERequestContext& ctx)
             rb.Push(async_data->res);
             rb.Push(static_cast<u32>(async_data->out_vec.size()));
             if (async_data->res.IsSuccess()) {
-                async_data->content_info_out->Write(async_data->out_vec.data(), 0,
-                                                    async_data->out_vec.size() *
-                                                        sizeof(ContentInfo));
+                async_data->content_info_out->Write(async_data->out_vec.data(),
+                                                    0,
+                                                    async_data->out_vec.size()
+                                                        * sizeof(ContentInfo));
             }
         },
         true);
 }
 
-void Module::Interface::CalculateContextRequiredSize(Kernel::HLERequestContext& ctx) {
+void Module::Interface::CalculateContextRequiredSize(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     LOG_DEBUG(Service_AM, "");
@@ -4670,7 +5333,9 @@ void Module::Interface::CalculateContextRequiredSize(Kernel::HLERequestContext&
     std::string tmd_path = GetTitleMetadataPath(media_type, title_id);
     FileSys::TitleMetadata tmd;
     if (tmd.Load(tmd_path) != Loader::ResultStatus::Success) {
-        LOG_ERROR(Service_AM, "Couldn't load TMD for title_id={:016X}, mediatype={}", title_id,
+        LOG_ERROR(Service_AM,
+                  "Couldn't load TMD for title_id={:016X}, mediatype={}",
+                  title_id,
                   media_type);
 
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
@@ -4681,7 +5346,8 @@ void Module::Interface::CalculateContextRequiredSize(Kernel::HLERequestContext&
     // Get info for each content index requested
     for (std::size_t i = 0; i < content_count; i++) {
         if (content_requested[i] >= tmd.GetContentCount()) {
-            LOG_ERROR(Service_AM, "Attempted to get info for non-existent content index {:04x}.",
+            LOG_ERROR(Service_AM,
+                      "Attempted to get info for non-existent content index {:04x}.",
                       content_requested[i]);
 
             IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
@@ -4689,7 +5355,8 @@ void Module::Interface::CalculateContextRequiredSize(Kernel::HLERequestContext&
             return;
         }
         if (!tmd.GetContentOptional(content_requested[i])) {
-            LOG_ERROR(Service_AM, "Attempted to get info for non-optional content index {:04x}.",
+            LOG_ERROR(Service_AM,
+                      "Attempted to get info for non-optional content index {:04x}.",
                       content_requested[i]);
 
             IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
@@ -4705,7 +5372,8 @@ void Module::Interface::CalculateContextRequiredSize(Kernel::HLERequestContext&
     rb.Push<u64>(size_out);
 }
 
-void Module::Interface::UpdateImportContentContexts(Kernel::HLERequestContext& ctx) {
+void Module::Interface::UpdateImportContentContexts(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
     const u32 content_count = rp.Pop<u32>();
     auto content_buf = rp.PopMappedBuffer();
@@ -4719,7 +5387,8 @@ void Module::Interface::UpdateImportContentContexts(Kernel::HLERequestContext& c
     LOG_WARNING(Service_AM, "(STUBBED)");
 }
 
-void Module::Interface::ExportTicketWrapped(Kernel::HLERequestContext& ctx) {
+void Module::Interface::ExportTicketWrapped(Kernel::HLERequestContext& ctx)
+{
     IPC::RequestParser rp(ctx);
 
     const u32 ticket_buf_size = rp.Pop<u32>();
@@ -4736,7 +5405,9 @@ void Module::Interface::ExportTicketWrapped(Kernel::HLERequestContext& ctx) {
     u32 tid_high = static_cast<u32>(title_id >> 32);
     if ((tid_high & 0x00048001) == 0x00048001 || tid_high == 0x00040001 || (tid_high & 0x10) != 0) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrCodes::InvalidTIDInList, ErrorModule::AM, ErrorSummary::InvalidArgument,
+        rb.Push(Result(ErrCodes::InvalidTIDInList,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidArgument,
                        ErrorLevel::Usage));
         return;
     }
@@ -4749,7 +5420,9 @@ void Module::Interface::ExportTicketWrapped(Kernel::HLERequestContext& ctx) {
             break;
     if (it == range.second) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrorDescription::NotFound, ErrorModule::AM, ErrorSummary::InvalidState,
+        rb.Push(Result(ErrorDescription::NotFound,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
                        ErrorLevel::Permanent));
         return;
     }
@@ -4757,7 +5430,9 @@ void Module::Interface::ExportTicketWrapped(Kernel::HLERequestContext& ctx) {
     FileSys::Ticket ticket;
     if (ticket.Load(title_id, ticket_id) != Loader::ResultStatus::Success) {
         IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(Result(ErrorDescription::NotFound, ErrorModule::AM, ErrorSummary::InvalidState,
+        rb.Push(Result(ErrorDescription::NotFound,
+                       ErrorModule::AM,
+                       ErrorSummary::InvalidState,
                        ErrorLevel::Permanent));
         return;
     }
@@ -4776,10 +5451,10 @@ void Module::Interface::ExportTicketWrapped(Kernel::HLERequestContext& ctx) {
 
     const auto& wrap_key = HW::RSA::GetTicketWrapSlot();
     u32 padding_len = static_cast<u32>(
-        ((CryptoPP::Integer(wrap_key.GetModulus().data(), wrap_key.GetModulus().size()).BitCount() +
-          7) /
-         8) -
-        (key.size() + iv.size()) - 3);
+        ((CryptoPP::Integer(wrap_key.GetModulus().data(), wrap_key.GetModulus().size()).BitCount()
+          + 7)
+         / 8)
+        - (key.size() + iv.size()) - 3);
 
     std::vector<u8> m;
     m.reserve(3 + padding_len + (key.size() + iv.size()));
@@ -4793,9 +5468,11 @@ void Module::Interface::ExportTicketWrapped(Kernel::HLERequestContext& ctx) {
 
     auto rsa_out = wrap_key.ModularExponentiation(m, static_cast<int>(m.size()));
 
-    ticket_buf.Write(ticket_data.data(), 0,
+    ticket_buf.Write(ticket_data.data(),
+                     0,
                      std::min(static_cast<size_t>(ticket_buf_size), ticket_data.size()));
-    keyiv_buf.Write(rsa_out.data(), 0,
+    keyiv_buf.Write(rsa_out.data(),
+                    0,
                     std::min(static_cast<size_t>(keyiv_buf_size), rsa_out.size()));
 
     IPC::RequestBuilder rb = rp.MakeBuilder(3, 0);
@@ -4804,24 +5481,30 @@ void Module::Interface::ExportTicketWrapped(Kernel::HLERequestContext& ctx) {
     rb.Push(static_cast<u32>(rsa_out.size()));
 }
 
-Module::Module(Core::System& _system) : system(_system) {
+Module::Module(Core::System& _system)
+    : system(_system)
+{
     FileUtil::CreateFullPath(GetTicketDirectory());
     ScanForAllTitles();
+    LoadCTCertFile(ct_cert);
     system_updater_mutex = system.Kernel().CreateMutex(false, "AM::SystemUpdaterMutex");
 }
 
-Module::~Module() {
+Module::~Module()
+{
     stop_scan_flag = true;
 }
 
-std::shared_ptr<Module> GetModule(Core::System& system) {
+std::shared_ptr<Module> GetModule(Core::System& system)
+{
     auto am = system.ServiceManager().GetService<Service::AM::Module::Interface>("am:u");
     if (!am)
         return nullptr;
     return am->GetModule();
 }
 
-void InstallInterfaces(Core::System& system) {
+void InstallInterfaces(Core::System& system)
+{
     auto& service_manager = system.ServiceManager();
     auto am = std::make_shared<Module>(system);
     std::make_shared<AM_APP>(am)->InstallAsService(service_manager);
diff --git a/src/core/hle/service/am/am.h b/src/core/hle/service/am/am.h
index 1798e596b..1a90f584b 100644
--- a/src/core/hle/service/am/am.h
+++ b/src/core/hle/service/am/am.h
@@ -4,16 +4,6 @@
 
 #pragma once
 
-#include <array>
-#include <atomic>
-#include <functional>
-#include <future>
-#include <memory>
-#include <mutex>
-#include <string>
-#include <vector>
-#include <boost/serialization/array.hpp>
-#include <boost/serialization/shared_ptr.hpp>
 #include "common/common_types.h"
 #include "common/construct.h"
 #include "common/swap.h"
@@ -25,6 +15,16 @@
 #include "core/hle/result.h"
 #include "core/hle/service/service.h"
 #include "network/artic_base/artic_base_client.h"
+#include <array>
+#include <atomic>
+#include <boost/serialization/array.hpp>
+#include <boost/serialization/shared_ptr.hpp>
+#include <functional>
+#include <future>
+#include <memory>
+#include <mutex>
+#include <string>
+#include <vector>
 
 namespace Core {
 class System;
@@ -51,6 +51,7 @@ namespace Service::AM {
 namespace ErrCodes {
 enum {
     InvalidImportState = 4,
+    CIACurrentlyInstalling = 4,
     InvalidTID = 31,
     EmptyCIA = 32,
     TryingToUninstallSystemApp = 44,
@@ -87,7 +88,15 @@ enum class ImportTitleContextState : u8 {
     NEEDS_CLEANUP = 6,
 };
 
-struct ImportTitleContext {
+enum class CTCertLoadStatus {
+    Loaded,
+    NotFound,
+    Invalid,
+    IOError,
+};
+
+struct ImportTitleContext
+{
     u64 title_id;
     u16 version;
     ImportTitleContextState state;
@@ -96,7 +105,8 @@ struct ImportTitleContext {
 };
 static_assert(sizeof(ImportTitleContext) == 0x18, "Invalid ImportTitleContext size");
 
-struct ImportContentContext {
+struct ImportContentContext
+{
     u32 content_id;
     u16 index;
     ImportTitleContextState state;
@@ -105,6 +115,25 @@ struct ImportContentContext {
 };
 static_assert(sizeof(ImportContentContext) == 0x18, "Invalid ImportContentContext size");
 
+struct CTCert
+{
+    u32_be signature_type{};
+    std::array<u8, 0x1E> signature_r{};
+    std::array<u8, 0x1E> signature_s{};
+    INSERT_PADDING_BYTES(0x40) {};
+    std::array<char, 0x40> issuer{};
+    u32_be key_type{};
+    std::array<char, 0x40> key_id{};
+    u32_be expiration_time{};
+    std::array<u8, 0x1E> public_key_x{};
+    std::array<u8, 0x1E> public_key_y{};
+    INSERT_PADDING_BYTES(0x3C) {};
+
+    bool IsValid() const;
+    u32 GetDeviceID() const;
+};
+static_assert(sizeof(CTCert) == 0x180, "Invalid CTCert size.");
+
 // Title ID valid length
 constexpr std::size_t TITLE_ID_VALID_LENGTH = 16;
 
@@ -113,14 +142,13 @@ constexpr u64 TWL_TITLE_ID_FLAG = 0x0000800000000000ULL;
 // Progress callback for InstallCIA, receives bytes written and total bytes
 using ProgressCallback = void(std::size_t, std::size_t);
 
-class NCCHCryptoFile final {
+class NCCHCryptoFile final
+{
 public:
     NCCHCryptoFile(const std::string& out_file, bool encrypted_content);
 
     void Write(const u8* buffer, std::size_t length);
-    bool IsError() {
-        return is_error;
-    }
+    bool IsError() { return is_error; }
 
 private:
     friend class CIAFile;
@@ -136,14 +164,14 @@ private:
     bool header_parsed = false;
 
     bool is_encrypted = false;
-    std::array<u8, 16>
-        primary_key{}; // for decrypting exheader, exefs header and icon/banner section
+    std::array<u8, 16> primary_key{}; // for decrypting exheader, exefs header and icon/banner section
     std::array<u8, 16> secondary_key{}; // for decrypting romfs and .code section
     std::array<u8, 16> exheader_ctr{};
     std::array<u8, 16> exefs_ctr{};
     std::array<u8, 16> romfs_ctr{};
 
-    struct CryptoRegion {
+    struct CryptoRegion
+    {
         enum Type {
             EXHEADER = 0,
             EXEFS_HDR = 1,
@@ -168,30 +196,22 @@ class CIAFile;
 void AuthorizeCIAFileDecryption(CIAFile* cia_file, Kernel::HLERequestContext& ctx);
 
 // A file handled returned for CIAs to be written into and subsequently installed.
-class CIAFile final : public FileSys::FileBackend {
+class CIAFile final : public FileSys::FileBackend
+{
 public:
-    class InstallResult {
-    public:
-        enum class Type {
-            NONE,
-            TIK,
-            TMD,
-            APP,
-        };
-        Type type{Type::NONE};
-        std::string install_full_path{};
-        Result result{0};
-    };
-
-    explicit CIAFile(Core::System& system_, Service::FS::MediaType media_type,
+    explicit CIAFile(Core::System& system_,
+                     Service::FS::MediaType media_type,
                      bool from_cdn = false);
     ~CIAFile();
 
     ResultVal<std::size_t> Read(u64 offset, std::size_t length, u8* buffer) const override;
-    InstallResult WriteTicket();
-    InstallResult WriteTitleMetadata(std::span<const u8> tmd_data, std::size_t offset);
+    Result WriteTicket();
+    Result WriteTitleMetadata(std::span<const u8> tmd_data, std::size_t offset);
     ResultVal<std::size_t> WriteContentData(u64 offset, std::size_t length, const u8* buffer);
-    ResultVal<std::size_t> Write(u64 offset, std::size_t length, bool flush, bool update_timestamp,
+    ResultVal<std::size_t> Write(u64 offset,
+                                 std::size_t length,
+                                 bool flush,
+                                 bool update_timestamp,
                                  const u8* buffer) override;
 
     Result PrepareToImportContent(const FileSys::TitleMetadata& tmd);
@@ -199,25 +219,19 @@ public:
     Result ProvideTMDForAdditionalContent(const FileSys::TitleMetadata& tmd);
     const FileSys::TitleMetadata& GetTMD();
     FileSys::Ticket& GetTicket();
-    CIAInstallState GetCiaInstallState() {
-        return install_state;
-    }
+    CIAInstallState GetCiaInstallState() { return install_state; }
 
-    ResultVal<std::size_t> WriteContentDataIndexed(u16 content_index, u64 offset,
-                                                   std::size_t length, const u8* buffer);
+    ResultVal<std::size_t> WriteContentDataIndexed(u16 content_index,
+                                                   u64 offset,
+                                                   std::size_t length,
+                                                   const u8* buffer);
 
     u64 GetSize() const override;
     bool SetSize(u64 size) const override;
     bool Close() override;
     void Flush() const override;
 
-    void SetDone() {
-        is_done = true;
-    }
-
-    const std::vector<InstallResult>& GetInstallResults() const {
-        return install_results;
-    }
+    void SetDone() { is_done = true; }
 
 private:
     friend void AuthorizeCIAFileDecryption(CIAFile* cia_file, Kernel::HLERequestContext& ctx);
@@ -244,20 +258,24 @@ private:
     std::vector<std::string> content_file_paths;
     u16 current_content_index = -1;
     std::unique_ptr<NCCHCryptoFile> current_content_file;
-    InstallResult current_content_install_result{};
-    std::vector<InstallResult> install_results;
+    std::vector<FileUtil::IOFile> content_files;
     Service::FS::MediaType media_type;
 
     class DecryptionState;
     std::unique_ptr<DecryptionState> decryption_state;
 };
 
-class CurrentImportingTitle {
+class CurrentImportingTitle
+{
 public:
-    explicit CurrentImportingTitle(Core::System& system_, u64 title_id_,
+    explicit CurrentImportingTitle(Core::System& system_,
+                                   u64 title_id_,
                                    Service::FS::MediaType media_type_)
-        : cia_file(system_, media_type_, true), title_id(title_id_), media_type(media_type_),
-          tmd_provided(false) {}
+        : cia_file(system_, media_type_, true)
+        , title_id(title_id_)
+        , media_type(media_type_)
+        , tmd_provided(false)
+    {}
 
     CIAFile cia_file;
     u64 title_id;
@@ -266,13 +284,17 @@ public:
 };
 
 // A file handled returned for Tickets to be written into and subsequently installed.
-class TicketFile final : public FileSys::FileBackend {
+class TicketFile final : public FileSys::FileBackend
+{
 public:
     explicit TicketFile();
     ~TicketFile();
 
     ResultVal<std::size_t> Read(u64 offset, std::size_t length, u8* buffer) const override;
-    ResultVal<std::size_t> Write(u64 offset, std::size_t length, bool flush, bool update_timestamp,
+    ResultVal<std::size_t> Write(u64 offset,
+                                 std::size_t length,
+                                 bool flush,
+                                 bool update_timestamp,
                                  const u8* buffer) override;
     u64 GetSize() const override;
     bool SetSize(u64 size) const override;
@@ -280,12 +302,8 @@ public:
     void Flush() const override;
 
     Result Commit();
-    u64 GetTitleID() {
-        return title_id;
-    }
-    u64 GetTicketID() {
-        return ticket_id;
-    }
+    u64 GetTitleID() { return title_id; }
+    u64 GetTicketID() { return ticket_id; }
 
 private:
     u64 written = 0;
@@ -294,14 +312,19 @@ private:
 };
 
 // A file handled returned for TMDs to be written into and subsequently installed.
-class TMDFile final : public FileSys::FileBackend {
+class TMDFile final : public FileSys::FileBackend
+{
 public:
     explicit TMDFile(const std::shared_ptr<CurrentImportingTitle>& import_context)
-        : importing_title(import_context) {}
+        : importing_title(import_context)
+    {}
     ~TMDFile();
 
     ResultVal<std::size_t> Read(u64 offset, std::size_t length, u8* buffer) const override;
-    ResultVal<std::size_t> Write(u64 offset, std::size_t length, bool flush, bool update_timestamp,
+    ResultVal<std::size_t> Write(u64 offset,
+                                 std::size_t length,
+                                 bool flush,
+                                 bool update_timestamp,
                                  const u8* buffer) override;
     u64 GetSize() const override;
     bool SetSize(u64 size) const override;
@@ -317,15 +340,23 @@ private:
 };
 
 // A file handled returned for contents to be written into and subsequently installed.
-class ContentFile final : public FileSys::FileBackend {
+class ContentFile final : public FileSys::FileBackend
+{
 public:
-    explicit ContentFile(const std::shared_ptr<CurrentImportingTitle>& import_context, u16 index_,
+    explicit ContentFile(const std::shared_ptr<CurrentImportingTitle>& import_context,
+                         u16 index_,
                          ImportContentContext& import_context_)
-        : import_context(import_context_), importing_title(import_context), index(index_) {}
+        : import_context(import_context_)
+        , importing_title(import_context)
+        , index(index_)
+    {}
     ~ContentFile();
 
     ResultVal<std::size_t> Read(u64 offset, std::size_t length, u8* buffer) const override;
-    ResultVal<std::size_t> Write(u64 offset, std::size_t length, bool flush, bool update_timestamp,
+    ResultVal<std::size_t> Write(u64 offset,
+                                 std::size_t length,
+                                 bool flush,
+                                 bool update_timestamp,
                                  const u8* buffer) override;
     u64 GetSize() const override;
     bool SetSize(u64 size) const override;
@@ -334,13 +365,9 @@ public:
 
     void Cancel(FS::MediaType media_type, u64 title_id);
 
-    ImportContentContext& GetImportContext() {
-        return import_context;
-    }
+    ImportContentContext& GetImportContext() { return import_context; }
 
-    void SetWritten(u64 written_) {
-        written = written_;
-    }
+    void SetWritten(u64 written_) { written = written_; }
 
 private:
     ImportContentContext& import_context;
@@ -359,6 +386,13 @@ private:
 InstallStatus InstallCIA(const std::string& path,
                          std::function<ProgressCallback>&& update_callback = nullptr);
 
+/**
+ * Downloads and installs title form the Nintendo Update Service.
+ * @param title_id the title_id to download
+ * @returns  whether the install was successful or error code
+ */
+InstallStatus InstallFromNus(u64 title_id, int version = -1);
+
 /**
  * Get the update title ID for a title
  * @param titleId the title ID
@@ -395,7 +429,9 @@ std::string GetTitleMetadataPath(Service::FS::MediaType media_type, u64 tid, boo
  * @param update set true if the incoming TMD should be used instead of the current TMD
  * @returns string path to the .app file
  */
-std::string GetTitleContentPath(FS::MediaType media_type, u64 tid, std::size_t index = 0,
+std::string GetTitleContentPath(FS::MediaType media_type,
+                                u64 tid,
+                                std::size_t index = 0,
                                 bool update = false);
 
 /**
@@ -421,28 +457,30 @@ std::string GetMediaTitlePath(Service::FS::MediaType media_type);
  */
 Result UninstallProgram(const FS::MediaType media_type, const u64 title_id);
 
-class Module final {
+class Module final
+{
 public:
     explicit Module(Core::System& system);
     ~Module();
 
-    class Interface : public ServiceFramework<Interface> {
+    class Interface : public ServiceFramework<Interface>
+    {
     public:
         Interface(std::shared_ptr<Module> am, const char* name, u32 max_session);
         ~Interface();
 
-        std::shared_ptr<Module> GetModule() const {
-            return am;
-        }
+        std::shared_ptr<Module> GetModule() const { return am; }
 
-        void UseArticClient(std::shared_ptr<Network::ArticBase::Client>& client) {
+        void UseArticClient(std::shared_ptr<Network::ArticBase::Client>& client)
+        {
             artic_client = client;
         }
 
     protected:
         void GetProgramInfosImpl(Kernel::HLERequestContext& ctx, bool ignore_platform);
 
-        void CommitImportTitlesImpl(Kernel::HLERequestContext& ctx, bool is_update_firm_auto,
+        void CommitImportTitlesImpl(Kernel::HLERequestContext& ctx,
+                                    bool is_update_firm_auto,
                                     bool is_titles);
 
         /**
@@ -653,11 +691,15 @@ public:
          */
         void GetDeviceID(Kernel::HLERequestContext& ctx);
 
-        void GetNumImportTitleContextsImpl(IPC::RequestParser& rp, FS::MediaType media_type,
-                                           bool include_installing, bool include_finalizing);
+        void GetNumImportTitleContextsImpl(IPC::RequestParser& rp,
+                                           FS::MediaType media_type,
+                                           bool include_installing,
+                                           bool include_finalizing);
 
-        void GetImportTitleContextListImpl(IPC::RequestParser& rp, FS::MediaType media_type,
-                                           u32 list_count, bool include_installing,
+        void GetImportTitleContextListImpl(IPC::RequestParser& rp,
+                                           FS::MediaType media_type,
+                                           u32 list_count,
+                                           bool include_installing,
                                            bool include_finalizing);
 
         void GetNumImportTitleContexts(Kernel::HLERequestContext& ctx);
@@ -668,13 +710,18 @@ public:
 
         void DeleteImportTitleContext(Kernel::HLERequestContext& ctx);
 
-        void GetNumImportContentContextsImpl(IPC::RequestParser& rp, u64 title_id,
+        void GetNumImportContentContextsImpl(IPC::RequestParser& rp,
+                                             u64 title_id,
                                              FS::MediaType media_type);
 
-        void GetImportContentContextListImpl(IPC::RequestParser& rp, u32 list_count, u64 title_id,
+        void GetImportContentContextListImpl(IPC::RequestParser& rp,
+                                             u32 list_count,
+                                             u64 title_id,
                                              FS::MediaType media_type);
 
-        void GetImportContentContextsImpl(IPC::RequestParser& rp, u32 list_count, u64 title_id,
+        void GetImportContentContextsImpl(IPC::RequestParser& rp,
+                                          u32 list_count,
+                                          u64 title_id,
                                           FS::MediaType media_type);
 
         void GetNumImportContentContexts(Kernel::HLERequestContext& ctx);
@@ -1049,13 +1096,21 @@ public:
         std::shared_ptr<Network::ArticBase::Client> artic_client = nullptr;
     };
 
-    void ForceO3DSDeviceID() {
-        force_old_device_id = true;
-    }
+    void ForceO3DSDeviceID() { force_old_device_id = true; }
+
+    void ForceN3DSDeviceID() { force_new_device_id = true; }
 
-    void ForceN3DSDeviceID() {
-        force_new_device_id = true;
-    }
+    /**
+     * Gets the CTCert.bin path in the host filesystem
+     * @returns std::string CTCert.bin path in the host filesystem
+     */
+    static std::string GetCTCertPath();
+
+    /**
+     * Loads the CTCert.bin file from the filesystem.
+     * @returns CTCertLoadStatus indicating the file load status.
+     */
+    static CTCertLoadStatus LoadCTCertFile(CTCert& output);
 
 private:
     void ScanForTickets();
@@ -1089,11 +1144,12 @@ private:
     std::multimap<u64, u64> am_ticket_list;
 
     std::shared_ptr<Kernel::Mutex> system_updater_mutex;
+    CTCert ct_cert{};
     std::shared_ptr<CurrentImportingTitle> importing_title;
     std::map<u64, ImportTitleContext> import_title_contexts;
     std::multimap<u64, ImportContentContext> import_content_contexts;
 
-    template <class Archive>
+    template<class Archive>
     void serialize(Archive& ar, const unsigned int);
     friend class boost::serialization::access;
 };
diff --git a/src/core/loader/ncch.cpp b/src/core/loader/ncch.cpp
index 9ecf64685..d18f7c6a1 100644
--- a/src/core/loader/ncch.cpp
+++ b/src/core/loader/ncch.cpp
@@ -31,6 +31,13 @@

 namespace Loader {

+std::string g_program_id;
+
+std::string getProgramId()
+{
+    return g_program_id;
+}
+
 using namespace Common::Literals;
 static constexpr u64 UPDATE_TID_HIGH = 0x0004000e00000000;

@@ -282,6 +289,7 @@ ResultStatus AppLoader_NCCH::Load(std::shared_ptr<Kernel::Process>& process) {
     std::string program_id{fmt::format("{:016X}", ncch_program_id)};

     LOG_INFO(Loader, "Program ID: {}", program_id);
+    g_program_id = program_id;

     u64 update_tid = (ncch_program_id & 0xFFFFFFFFULL) | UPDATE_TID_HIGH;
     update_ncch.OpenFile(
diff --git a/src/core/loader/ncch.h b/src/core/loader/ncch.h
index 099644b75..86459d05c 100644
--- a/src/core/loader/ncch.h
+++ b/src/core/loader/ncch.h
@@ -12,8 +12,11 @@

 namespace Loader {

+std::string getProgramId();
+
 /// Loads an NCCH file (e.g. from a CCI, or the first NCCH in a CXI)
-class AppLoader_NCCH final : public AppLoader {
+class AppLoader_NCCH final : public AppLoader
+{
 public:
     AppLoader_NCCH(Core::System& system_, FileUtil::IOFile&& file, const std::string& filepath)
         : AppLoader(system_, std::move(file)), base_ncch(filepath), overlay_ncch(&base_ncch),
