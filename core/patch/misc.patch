diff --git a/src/citra_qt/citra_qt.cpp b/src/citra_qt/citra_qt.cpp
index 94318da55c..fda67b54ee 100644
--- a/src/citra_qt/citra_qt.cpp
+++ b/src/citra_qt/citra_qt.cpp
@@ -1250,11 +1250,17 @@ bool GMainWindow::LoadROM(const QString& filename) {
             break;

         case Core::System::ResultStatus::ErrorLoader_ErrorEncrypted: {
-            QMessageBox::critical(this, tr("App Encrypted"),
-                                  tr("Your app is encrypted. <br/>"
-                                     "<a "
-                                     "href='https://azahar-emu.org/blog/game-loading-changes/'>"
-                                     "Please check our blog for more info.</a>"));
+            QMessageBox::critical(
+                this, tr("ROM Encrypted"),
+                tr("Your ROM is encrypted. <br/>Please follow the guides to redump your "
+                   "<a "
+                   "href='https://web.archive.org/web/20240304210021/https://citra-emu.org/wiki/"
+                   "dumping-game-cartridges/'>game "
+                   "cartridges</a> or "
+                   "<a "
+                   "href='https://web.archive.org/web/20240304210011/https://citra-emu.org/wiki/"
+                   "dumping-installed-titles/'>installed "
+                   "titles</a>."));
             break;
         }
         case Core::System::ResultStatus::ErrorLoader_ErrorInvalidFormat:
@@ -2271,11 +2277,10 @@ void GMainWindow::OnCIAInstallReport(Service::AM::InstallStatus status, QString
         QMessageBox::critical(this, tr("Invalid File"), tr("%1 is not a valid CIA").arg(filename));
         break;
     case Service::AM::InstallStatus::ErrorEncrypted:
-        QMessageBox::critical(this, tr("CIA Encrypted"),
-                              tr("Your CIA file is encrypted.<br/>"
-                                 "<a "
-                                 "href='https://azahar-emu.org/blog/game-loading-changes/'>"
-                                 "Please check our blog for more info.</a>"));
+        QMessageBox::critical(this, tr("Encrypted File"),
+                              tr("%1 must be decrypted "
+                                 "before being used with Azahar. A real 3DS is required.")
+                                  .arg(filename));
         break;
     case Service::AM::InstallStatus::ErrorFileNotFound:
         QMessageBox::critical(this, tr("Unable to find File"),
diff --git a/src/citra_qt/game_list.cpp b/src/citra_qt/game_list.cpp
index cac036aaa7..b41b1e2fd0 100644
--- a/src/citra_qt/game_list.cpp
+++ b/src/citra_qt/game_list.cpp
@@ -1039,7 +1039,7 @@ void GameList::LoadInterfaceLayout() {
 }

 const QStringList GameList::supported_file_extensions = {
-    QStringLiteral("3dsx"), QStringLiteral("elf"), QStringLiteral("axf"),
+    QStringLiteral("3ds"), QStringLiteral("3dsx"), QStringLiteral("elf"), QStringLiteral("axf"),
     QStringLiteral("cci"),  QStringLiteral("cxi"), QStringLiteral("app")};

 void GameList::RefreshGameDirectory() {
diff --git a/src/citra_qt/uisettings.h b/src/citra_qt/uisettings.h
index 392954cf80..6fa7fbf1b1 100644
--- a/src/citra_qt/uisettings.h
+++ b/src/citra_qt/uisettings.h
@@ -94,7 +94,7 @@ struct Values {
     Settings::Setting<GameListText> game_list_row_2{GameListText::FileName, "row2"};
     Settings::Setting<bool> game_list_hide_no_icon{false, "hideNoIcon"};
     Settings::Setting<bool> game_list_single_line_mode{false, "singleLineMode"};
-    Settings::Setting<bool> show_3ds_files_warning{true, "show_3ds_files_warning"};
+    Settings::Setting<bool> show_3ds_files_warning{false, "show_3ds_files_warning"};

     // Compatibility List
     Settings::Setting<bool> show_compat_column{true, "show_compat_column"};
diff --git a/src/common/common_paths.h b/src/common/common_paths.h
index bb73c049e1..01e18e9d9f 100644
--- a/src/common/common_paths.h
+++ b/src/common/common_paths.h
@@ -81,5 +81,6 @@
 // Sys files
 #define SHARED_FONT "shared_font.bin"
 #define KEYS_FILE "keys.txt"
+#define AES_KEYS "aes_keys.txt"
 #define BOOTROM9 "boot9.bin"
 #define SECRET_SECTOR "sector0x96.bin"
diff --git a/src/common/file_util.h b/src/common/file_util.h
index a4881b57b8..c32b66e683 100644
--- a/src/common/file_util.h
+++ b/src/common/file_util.h
@@ -386,7 +386,15 @@ class IOFile : public NonCopyable {
     [[nodiscard]] size_t ReadSpan(std::span<T> data) {
         static_assert(std::is_trivially_copyable_v<T>, "Data type must be trivially copyable.");

+#ifdef todotodo
         return ReadImpl(data.data(), data.size(), sizeof(T));
+#else
+        if (!IsOpen()) {
+            return 0;
+        }
+
+        return std::fread(data.data(), sizeof(T), data.size(), m_file);
+#endif
     }

     /**
@@ -408,7 +416,15 @@ class IOFile : public NonCopyable {
     [[nodiscard]] size_t WriteSpan(std::span<const T> data) {
         static_assert(std::is_trivially_copyable_v<T>, "Data type must be trivially copyable.");

+#ifdef todotodo
         return WriteImpl(data.data(), data.size(), sizeof(T));
+#else
+        if (!IsOpen()) {
+            return 0;
+        }
+
+        return std::fwrite(data.data(), sizeof(T), data.size(), m_file);
+#endif
     }

     [[nodiscard]] bool IsOpen() const {
diff --git a/src/common/hacks/hack_list.cpp b/src/common/hacks/hack_list.cpp
index c5702df5e2..637876f09f 100644
--- a/src/common/hacks/hack_list.cpp
+++ b/src/common/hacks/hack_list.cpp
@@ -70,6 +70,7 @@ HackManager hack_manager = {
                  },
          }},

+#ifdef todotodo
         {HackType::ONLINE_LLE_REQUIRED,
          HackEntry{
              .mode = HackAllowMode::FORCE,
@@ -107,6 +108,7 @@ HackManager hack_manager = {
                      0x000400000D40D200,
                  },
          }},
+#endif

         {HackType::REGION_FROM_SECURE,
          HackEntry{
diff --git a/src/core/file_sys/ncch_container.cpp b/src/core/file_sys/ncch_container.cpp
index a3f97a4f1e..0739ac4c07 100644
--- a/src/core/file_sys/ncch_container.cpp
+++ b/src/core/file_sys/ncch_container.cpp
@@ -137,7 +137,9 @@ Loader::ResultStatus NCCHContainer::LoadHeader() {
         return Loader::ResultStatus::Success;
     }

+#ifdef todotodo
     for (int i = 0; i < 2; i++) {
+#endif
         if (!file->IsOpen()) {
             return Loader::ResultStatus::Error;
         }
@@ -164,6 +166,7 @@ Loader::ResultStatus NCCHContainer::LoadHeader() {

         // Verify we are loading the correct file type...
         if (Loader::MakeMagic('N', 'C', 'C', 'H') != ncch_header.magic) {
+#ifdef todotodo
             // We may be loading a crypto file, try again
             if (i == 0) {
                 file.reset();
@@ -172,8 +175,13 @@ Loader::ResultStatus NCCHContainer::LoadHeader() {
             } else {
                 return Loader::ResultStatus::ErrorInvalidFormat;
             }
+#else
+            return Loader::ResultStatus::ErrorInvalidFormat;
+#endif
         }
+#ifdef todotodo
     }
+#endif

     if (file->IsCrypto()) {
         LOG_DEBUG(Service_FS, "NCCH file has console unique crypto");
@@ -192,7 +200,9 @@ Loader::ResultStatus NCCHContainer::Load() {
     if (file->IsOpen()) {
         size_t file_size;

+#ifdef todotodo
         for (int i = 0; i < 2; i++) {
+#endif
             file_size = file->GetSize();

             // Reset read pointer in case this file has been read before.
@@ -215,6 +225,7 @@ Loader::ResultStatus NCCHContainer::Load() {

             // Verify we are loading the correct file type...
             if (Loader::MakeMagic('N', 'C', 'C', 'H') != ncch_header.magic) {
+#ifdef todotodo
                 // We may be loading a crypto file, try again
                 if (i == 0) {
                     file = HW::UniqueData::OpenUniqueCryptoFile(
@@ -222,14 +233,146 @@ Loader::ResultStatus NCCHContainer::Load() {
                 } else {
                     return Loader::ResultStatus::ErrorInvalidFormat;
                 }
+#else
+            return Loader::ResultStatus::ErrorInvalidFormat;
+#endif
             }
+#ifdef todotodo
         }
+#endif

         if (file->IsCrypto()) {
             LOG_DEBUG(Service_FS, "NCCH file has console unique crypto");
         }

         has_header = true;
+        bool failed_to_decrypt = false;
+        if (!ncch_header.no_crypto) {
+            is_encrypted = true;
+
+            // Find primary and secondary keys
+            if (ncch_header.fixed_key) {
+                LOG_DEBUG(Service_FS, "Fixed-key crypto");
+                primary_key.fill(0);
+                secondary_key.fill(0);
+            } else {
+                using namespace HW::AES;
+                InitKeys();
+                std::array<u8, 16> key_y_primary, key_y_secondary;
+
+                std::copy(ncch_header.signature, ncch_header.signature + key_y_primary.size(),
+                          key_y_primary.begin());
+
+                if (!ncch_header.seed_crypto) {
+                    key_y_secondary = key_y_primary;
+                } else {
+                    auto opt{FileSys::GetSeed(ncch_header.program_id)};
+                    if (!opt.has_value()) {
+                        LOG_ERROR(Service_FS, "Seed for program {:016X} not found",
+                                  ncch_header.program_id);
+                        failed_to_decrypt = true;
+                    } else {
+                        auto seed{*opt};
+                        std::array<u8, 32> input;
+                        std::memcpy(input.data(), key_y_primary.data(), key_y_primary.size());
+                        std::memcpy(input.data() + key_y_primary.size(), seed.data(), seed.size());
+                        CryptoPP::SHA256 sha;
+                        std::array<u8, CryptoPP::SHA256::DIGESTSIZE> hash;
+                        sha.CalculateDigest(hash.data(), input.data(), input.size());
+                        std::memcpy(key_y_secondary.data(), hash.data(), key_y_secondary.size());
+                    }
+                }
+
+                SetKeyY(KeySlotID::NCCHSecure1, key_y_primary);
+                if (!IsNormalKeyAvailable(KeySlotID::NCCHSecure1)) {
+                    LOG_ERROR(Service_FS, "Secure1 KeyX missing");
+                    failed_to_decrypt = true;
+                }
+                primary_key = GetNormalKey(KeySlotID::NCCHSecure1);
+
+                switch (ncch_header.secondary_key_slot) {
+                case 0:
+                    LOG_DEBUG(Service_FS, "Secure1 crypto");
+                    SetKeyY(KeySlotID::NCCHSecure1, key_y_secondary);
+                    if (!IsNormalKeyAvailable(KeySlotID::NCCHSecure1)) {
+                        LOG_ERROR(Service_FS, "Secure1 KeyX missing");
+                        failed_to_decrypt = true;
+                    }
+                    secondary_key = GetNormalKey(KeySlotID::NCCHSecure1);
+                    break;
+                case 1:
+                    LOG_DEBUG(Service_FS, "Secure2 crypto");
+                    SetKeyY(KeySlotID::NCCHSecure2, key_y_secondary);
+                    if (!IsNormalKeyAvailable(KeySlotID::NCCHSecure2)) {
+                        LOG_ERROR(Service_FS, "Secure2 KeyX missing");
+                        failed_to_decrypt = true;
+                    }
+                    secondary_key = GetNormalKey(KeySlotID::NCCHSecure2);
+                    break;
+                case 10:
+                    LOG_DEBUG(Service_FS, "Secure3 crypto");
+                    SetKeyY(KeySlotID::NCCHSecure3, key_y_secondary);
+                    if (!IsNormalKeyAvailable(KeySlotID::NCCHSecure3)) {
+                        LOG_ERROR(Service_FS, "Secure3 KeyX missing");
+                        failed_to_decrypt = true;
+                    }
+                    secondary_key = GetNormalKey(KeySlotID::NCCHSecure3);
+                    break;
+                case 11:
+                    LOG_DEBUG(Service_FS, "Secure4 crypto");
+                    SetKeyY(KeySlotID::NCCHSecure4, key_y_secondary);
+                    if (!IsNormalKeyAvailable(KeySlotID::NCCHSecure4)) {
+                        LOG_ERROR(Service_FS, "Secure4 KeyX missing");
+                        failed_to_decrypt = true;
+                    }
+                    secondary_key = GetNormalKey(KeySlotID::NCCHSecure4);
+                    break;
+                }
+            }
+
+            // Find CTR for each section
+            // Written with reference to
+            // https://github.com/d0k3/GodMode9/blob/99af6a73be48fa7872649aaa7456136da0df7938/arm9/source/game/ncch.c#L34-L52
+            if (ncch_header.version == 0 || ncch_header.version == 2) {
+                LOG_DEBUG(Loader, "NCCH version 0/2");
+                // In this version, CTR for each section is a magic number prefixed by partition ID
+                // (reverse order)
+                std::reverse_copy(ncch_header.partition_id, ncch_header.partition_id + 8,
+                                  exheader_ctr.begin());
+                exefs_ctr = romfs_ctr = exheader_ctr;
+                exheader_ctr[8] = 1;
+                exefs_ctr[8] = 2;
+                romfs_ctr[8] = 3;
+            } else if (ncch_header.version == 1) {
+                LOG_DEBUG(Loader, "NCCH version 1");
+                // In this version, CTR for each section is the section offset prefixed by partition
+                // ID, as if the entire NCCH image is encrypted using a single CTR stream.
+                std::copy(ncch_header.partition_id, ncch_header.partition_id + 8,
+                          exheader_ctr.begin());
+                exefs_ctr = romfs_ctr = exheader_ctr;
+                auto u32ToBEArray = [](u32 value) -> std::array<u8, 4> {
+                    return std::array<u8, 4>{
+                        static_cast<u8>(value >> 24),
+                        static_cast<u8>((value >> 16) & 0xFF),
+                        static_cast<u8>((value >> 8) & 0xFF),
+                        static_cast<u8>(value & 0xFF),
+                    };
+                };
+                auto offset_exheader = u32ToBEArray(0x200); // exheader offset
+                auto offset_exefs = u32ToBEArray(ncch_header.exefs_offset * kBlockSize);
+                auto offset_romfs = u32ToBEArray(ncch_header.romfs_offset * kBlockSize);
+                std::copy(offset_exheader.begin(), offset_exheader.end(),
+                          exheader_ctr.begin() + 12);
+                std::copy(offset_exefs.begin(), offset_exefs.end(), exefs_ctr.begin() + 12);
+                std::copy(offset_romfs.begin(), offset_romfs.end(), romfs_ctr.begin() + 12);
+            } else {
+                LOG_ERROR(Service_FS, "Unknown NCCH version {}", ncch_header.version);
+                failed_to_decrypt = true;
+            }
+        } else {
+            LOG_DEBUG(Service_FS, "No crypto");
+            is_encrypted = false;
+        }

         if (ncch_header.content_size == file_size) {
             // The NCCH is a proto version, which does not use media size units
@@ -237,10 +380,12 @@ Loader::ResultStatus NCCHContainer::Load() {
             block_size = 1;
         }

+#ifdef todotodo
         if (!ncch_header.no_crypto) {
             // Encrypted NCCH are not supported
             return Loader::ResultStatus::ErrorEncrypted;
         }
+#endif

         // System archives and DLC don't have an extended header but have RomFS
         // Proto apps don't have an ext header size
@@ -254,6 +399,26 @@ Loader::ResultStatus NCCHContainer::Load() {
                 return Loader::ResultStatus::Error;
             }

+            if (is_encrypted) {
+                // This ID check is masked to low 32-bit as a toleration to ill-formed ROM created
+                // by merging games and its updates.
+                if ((exheader_header.system_info.jump_id & 0xFFFFFFFF) ==
+                    (ncch_header.program_id & 0xFFFFFFFF)) {
+                    LOG_WARNING(Service_FS, "NCCH is marked as encrypted but with decrypted "
+                                            "exheader. Force no crypto scheme.");
+                    is_encrypted = false;
+                } else {
+                    if (failed_to_decrypt) {
+                        LOG_ERROR(Service_FS, "Failed to decrypt");
+                        return Loader::ResultStatus::ErrorEncrypted;
+                    }
+                    CryptoPP::byte* data = reinterpret_cast<CryptoPP::byte*>(&exheader_header);
+                    CryptoPP::CTR_Mode<CryptoPP::AES>::Decryption(
+                        primary_key.data(), primary_key.size(), exheader_ctr.data())
+                        .ProcessData(data, data, sizeof(exheader_header));
+                }
+            }
+
             const auto mods_path =
                 fmt::format("{}mods/{:016X}/", FileUtil::GetUserPath(FileUtil::UserPath::LoadDir),
                             GetModId(ncch_header.program_id));
@@ -323,6 +488,7 @@ Loader::ResultStatus NCCHContainer::Load() {
             if (file->ReadBytes(&exefs_header, sizeof(ExeFs_Header)) != sizeof(ExeFs_Header))
                 return Loader::ResultStatus::Error;

+#ifdef todotodo
             if (file->IsCrypto()) {
                 exefs_file = HW::UniqueData::OpenUniqueCryptoFile(
                     filepath, "rb", HW::UniqueData::UniqueCryptoFileID::NCCH);
@@ -330,6 +496,16 @@ Loader::ResultStatus NCCHContainer::Load() {
                 exefs_file = std::make_unique<FileUtil::IOFile>(filepath, "rb");
             }

+#else
+            if (is_encrypted) {
+                CryptoPP::byte* data = reinterpret_cast<CryptoPP::byte*>(&exefs_header);
+                CryptoPP::CTR_Mode<CryptoPP::AES>::Decryption(primary_key.data(),
+                                                              primary_key.size(), exefs_ctr.data())
+                    .ProcessData(data, data, sizeof(exefs_header));
+            }
+
+            exefs_file = std::make_unique<FileUtil::IOFile>(filepath, "rb");
+#endif
             has_exefs = true;
         }

@@ -457,6 +633,17 @@ Loader::ResultStatus NCCHContainer::LoadSectionExeFS(const char* name, std::vect
                          : (section.offset + exefs_offset + sizeof(ExeFs_Header) + ncch_offset);
             exefs_file->Seek(section_offset, SEEK_SET);

+            std::array<u8, 16> key;
+            if (strcmp(section.name, "icon") == 0 || strcmp(section.name, "banner") == 0) {
+                key = primary_key;
+            } else {
+                key = secondary_key;
+            }
+
+            CryptoPP::CTR_Mode<CryptoPP::AES>::Decryption dec(key.data(), key.size(),
+                                                              exefs_ctr.data());
+            dec.Seek(section.offset + sizeof(ExeFs_Header));
+
             size_t section_size = is_proto ? Common::AlignUp(section.size, 0x10) : section.size;

             if (strcmp(section.name, ".code") == 0 && is_compressed) {
@@ -466,6 +653,10 @@ Loader::ResultStatus NCCHContainer::LoadSectionExeFS(const char* name, std::vect
                     temp_buffer.size())
                     return Loader::ResultStatus::Error;

+                if (is_encrypted) {
+                    dec.ProcessData(&temp_buffer[0], &temp_buffer[0], section.size);
+                }
+
                 // Decompress .code section...
                 buffer.resize(LZSS_GetDecompressedSize(temp_buffer));
                 if (!LZSS_Decompress(temp_buffer, buffer)) {
@@ -476,6 +667,9 @@ Loader::ResultStatus NCCHContainer::LoadSectionExeFS(const char* name, std::vect
                 buffer.resize(section_size);
                 if (exefs_file->ReadBytes(buffer.data(), section_size) != section_size)
                     return Loader::ResultStatus::Error;
+                if (is_encrypted) {
+                    dec.ProcessData(buffer.data(), buffer.data(), section.size);
+                }
             }

             return Loader::ResultStatus::Success;
@@ -607,18 +801,34 @@ Loader::ResultStatus NCCHContainer::ReadRomFS(std::shared_ptr<RomFSReader>& romf

     // We reopen the file, to allow its position to be independent from file's
     std::unique_ptr<FileUtil::IOFile> romfs_file_inner;
+#ifdef todotodo
     if (file->IsCrypto()) {
         romfs_file_inner = HW::UniqueData::OpenUniqueCryptoFile(
             filepath, "rb", HW::UniqueData::UniqueCryptoFileID::NCCH);
     } else {
         romfs_file_inner = std::make_unique<FileUtil::IOFile>(filepath, "rb");
     }
+#else
+    romfs_file_inner = std::make_unique<FileUtil::IOFile>(filepath, "rb");
+#endif

     if (!romfs_file_inner->IsOpen())
         return Loader::ResultStatus::Error;

+#ifdef todotodo
     std::shared_ptr<RomFSReader> direct_romfs =
         std::make_shared<DirectRomFSReader>(std::move(romfs_file_inner), romfs_offset, romfs_size);
+#else
+    std::shared_ptr<RomFSReader> direct_romfs;
+    if (is_encrypted) {
+        direct_romfs =
+            std::make_shared<DirectRomFSReader>(std::move(romfs_file_inner), romfs_offset,
+                                                romfs_size, secondary_key, romfs_ctr, 0x1000);
+    } else {
+        direct_romfs = std::make_shared<DirectRomFSReader>(std::move(romfs_file_inner),
+                                                           romfs_offset, romfs_size);
+    }
+#endif

     const auto path =
         fmt::format("{}mods/{:016X}/", FileUtil::GetUserPath(FileUtil::UserPath::LoadDir),
@@ -636,8 +846,10 @@ Loader::ResultStatus NCCHContainer::ReadRomFS(std::shared_ptr<RomFSReader>& romf
 }

 Loader::ResultStatus NCCHContainer::DumpRomFS(const std::string& target_path) {
+#ifdef todotodo
     if (file->IsCrypto())
         return Loader::ResultStatus::ErrorEncrypted;
+#endif

     std::shared_ptr<RomFSReader> direct_romfs;
     Loader::ResultStatus result = ReadRomFS(direct_romfs, false);
diff --git a/src/core/file_sys/ncch_container.h b/src/core/file_sys/ncch_container.h
index 214f91998f..36ca951384 100644
--- a/src/core/file_sys/ncch_container.h
+++ b/src/core/file_sys/ncch_container.h
@@ -348,6 +348,14 @@ class NCCHContainer {
     bool is_loaded = false;
     bool is_compressed = false;

+    bool is_encrypted = false;
+    // for decrypting exheader, exefs header and icon/banner section
+    std::array<u8, 16> primary_key{};
+    std::array<u8, 16> secondary_key{}; // for decrypting romfs and .code section
+    std::array<u8, 16> exheader_ctr{};
+    std::array<u8, 16> exefs_ctr{};
+    std::array<u8, 16> romfs_ctr{};
+
     u32 ncch_offset = 0; // Offset to NCCH header, can be 0 for NCCHs or non-zero for CIAs/NCSDs
     u32 exefs_offset = 0;
     u32 partition = 0;
diff --git a/src/core/file_sys/romfs_reader.cpp b/src/core/file_sys/romfs_reader.cpp
index 7f847efde2..0c980b9d25 100644
--- a/src/core/file_sys/romfs_reader.cpp
+++ b/src/core/file_sys/romfs_reader.cpp
@@ -29,6 +29,11 @@ std::size_t DirectRomFSReader::ReadFile(std::size_t offset, std::size_t length,
     // Skip cache if the read is too big
     if (segments.size() == 1 && segments[0].second > cache_line_size) {
         length = file->ReadAtBytes(buffer, length, file_offset + offset);
+        if (is_encrypted) {
+            CryptoPP::CTR_Mode<CryptoPP::AES>::Decryption d(key.data(), key.size(), ctr.data());
+            d.Seek(crypto_offset + offset);
+            d.ProcessData(buffer, buffer, length);
+        }
         LOG_TRACE(Service_FS, "RomFS Cache SKIP: offset={}, length={}", offset, length);
         return length;
     }
@@ -43,6 +48,11 @@ std::size_t DirectRomFSReader::ReadFile(std::size_t offset, std::size_t length,
         if (!cache_entry.first) {
             // If not found, read from disk and cache the data
             read_size = file->ReadAtBytes(cache_entry.second.data(), read_size, file_offset + page);
+            if (is_encrypted && read_size) {
+                CryptoPP::CTR_Mode<CryptoPP::AES>::Decryption d(key.data(), key.size(), ctr.data());
+                d.Seek(crypto_offset + page);
+                d.ProcessData(cache_entry.second.data(), cache_entry.second.data(), read_size);
+            }
             LOG_TRACE(Service_FS, "RomFS Cache MISS: page={}, length={}, into={}", page, seg.second,
                       (seg.first - page));
         } else {
diff --git a/src/core/file_sys/romfs_reader.h b/src/core/file_sys/romfs_reader.h
index a427c77d0d..f147b996ae 100644
--- a/src/core/file_sys/romfs_reader.h
+++ b/src/core/file_sys/romfs_reader.h
@@ -47,7 +47,13 @@ class DirectRomFSReader : public RomFSReader {
 public:
     DirectRomFSReader(std::unique_ptr<FileUtil::IOFile>&& file, std::size_t file_offset,
                       std::size_t data_size)
-        : file(std::move(file)), file_offset(file_offset), data_size(data_size) {}
+        : is_encrypted(false), file(std::move(file)), file_offset(file_offset), data_size(data_size) {}
+
+    DirectRomFSReader(std::unique_ptr<FileUtil::IOFile>&& file, std::size_t file_offset, std::size_t data_size,
+                      const std::array<u8, 16>& key, const std::array<u8, 16>& ctr,
+                      std::size_t crypto_offset)
+        : is_encrypted(true), file(std::move(file)), key(key), ctr(ctr), file_offset(file_offset),
+          crypto_offset(crypto_offset), data_size(data_size) {}

     ~DirectRomFSReader() override = default;

@@ -62,8 +68,12 @@ class DirectRomFSReader : public RomFSReader {
     bool CacheReady(std::size_t file_offset, std::size_t length) override;

 private:
+    bool is_encrypted;
     std::unique_ptr<FileUtil::IOFile> file;
+    std::array<u8, 16> key;
+    std::array<u8, 16> ctr;
     u64 file_offset;
+    u64 crypto_offset;
     u64 data_size;

     // Total cache size: 128KB
@@ -86,8 +96,12 @@ class DirectRomFSReader : public RomFSReader {
     template <class Archive>
     void serialize(Archive& ar, const unsigned int) {
         ar& boost::serialization::base_object<RomFSReader>(*this);
+        ar & is_encrypted;
         ar & file;
+        ar & key;
+        ar & ctr;
         ar & file_offset;
+        ar & crypto_offset;
         ar & data_size;
     }
     friend class boost::serialization::access;
diff --git a/src/core/hle/applets/erreula.cpp b/src/core/hle/applets/erreula.cpp
index 0454cdb571..f8b51a33c1 100644
--- a/src/core/hle/applets/erreula.cpp
+++ b/src/core/hle/applets/erreula.cpp
@@ -44,12 +44,22 @@ Result ErrEula::ReceiveParameterImpl(const Service::APT::MessageParameter& param
 }

 Result ErrEula::Start(const Service::APT::MessageParameter& parameter) {
+#ifdef todotodo
     memcpy(&param, parameter.buffer.data(), std::min(parameter.buffer.size(), sizeof(param)));

     // Do something here, like showing error codes, or prompting for EULA agreement.
     if (param.type == DisplayType::Agree) {
         param.result = 1;
     }
+#else
+    startup_param = parameter.buffer;
+#endif
+
+//--
+    // TODO(Subv): Set the expected fields in the response buffer before resending it to the
+    // application.
+    // TODO(Subv): Reverse the parameter format for the ErrEula applet
+//--

     // Let the application know that we're closing.
     Finalize();
@@ -57,8 +67,13 @@ Result ErrEula::Start(const Service::APT::MessageParameter& parameter) {
 }

 Result ErrEula::Finalize() {
+#ifdef todotodo
     std::vector<u8> buffer(sizeof(param));
     memcpy(buffer.data(), &param, buffer.size());
+#else
+    std::vector<u8> buffer(startup_param.size());
+    std::fill(buffer.begin(), buffer.end(), 0);
+#endif
     CloseApplet(nullptr, buffer);
     return ResultSuccess;
 }
diff --git a/src/core/hle/applets/erreula.h b/src/core/hle/applets/erreula.h
index 49f41bb88e..57ccaf466f 100644
--- a/src/core/hle/applets/erreula.h
+++ b/src/core/hle/applets/erreula.h
@@ -54,7 +54,8 @@ class ErrEula final : public Applet {
     std::shared_ptr<Kernel::SharedMemory> framebuffer_memory;

     /// Parameter received by the applet on start.
-    ErrEulaParam param{};
+//    ErrEulaParam param{};
+    std::vector<u8> startup_param;
 };

 } // namespace HLE::Applets
diff --git a/src/core/hle/kernel/ipc.cpp b/src/core/hle/kernel/ipc.cpp
index 17b5b20f02..a3bc290958 100644
--- a/src/core/hle/kernel/ipc.cpp
+++ b/src/core/hle/kernel/ipc.cpp
@@ -205,12 +205,21 @@ Result TranslateCommandBuffer(Kernel::KernelSystem& kernel, Memory::MemorySystem
                              buffer->GetPtr() + Memory::CITRA_PAGE_SIZE + page_offset, size);

             // Map the guard pages and mapped pages at once.
+#ifdef todotodo
             auto target_address_result = dst_process->vm_manager.MapBackingMemoryToBase(
                 Memory::IPC_MAPPING_VADDR, Memory::IPC_MAPPING_SIZE, buffer,
                 static_cast<u32>(buffer->GetSize()), Kernel::MemoryState::Shared);

             ASSERT_MSG(target_address_result.Succeeded(), "Failed to map target address");
             target_address = target_address_result.Unwrap();
+#else
+            target_address =
+                dst_process->vm_manager
+                    .MapBackingMemoryToBase(Memory::IPC_MAPPING_VADDR, Memory::IPC_MAPPING_SIZE,
+                                            buffer, static_cast<u32>(buffer->GetSize()),
+                                            Kernel::MemoryState::Shared)
+                    .Unwrap();
+#endif

             // Change the permissions and state of the guard pages.
             const VAddr low_guard_address = target_address;
diff --git a/src/core/hle/kernel/shared_page.h b/src/core/hle/kernel/shared_page.h
index 17ae8d2eb3..517cf30d6c 100644
--- a/src/core/hle/kernel/shared_page.h
+++ b/src/core/hle/kernel/shared_page.h
@@ -47,6 +47,9 @@ union BatteryState {

 using MacAddress = std::array<u8, 6>;

+// Default MAC address in the Nintendo 3DS range
+constexpr MacAddress DefaultMac = {0x40, 0xF4, 0x07, 0x00, 0x00, 0x00};
+
 enum class WifiLinkLevel : u8 {
     Off = 0,
     Poor = 1,
diff --git a/src/core/hle/service/ac/ac.cpp b/src/core/hle/service/ac/ac.cpp
index f719d919dd..cbb4bd1ba6 100644
--- a/src/core/hle/service/ac/ac.cpp
+++ b/src/core/hle/service/ac/ac.cpp
@@ -106,10 +106,26 @@ void Module::Interface::GetStatus(Kernel::HLERequestContext& ctx) {

 void Module::Interface::GetWifiStatus(Kernel::HLERequestContext& ctx) {
     IPC::RequestParser rp(ctx);
-
+/* todotodo
+*/
+//--
+    bool can_reach_internet = false;
+
+    std::shared_ptr<SOC::SOC_U> socu_module = SOC::GetService(ac->system);
+    if (socu_module) {
+        can_reach_internet = socu_module->GetDefaultInterfaceInfo().has_value();
+    }
+//--
     IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
     rb.Push(ResultSuccess);
+#ifdef todotodo
     rb.Push<u32>(static_cast<u32>(WifiStatus::STATUS_CONNECTED_SLOT1));
+#else
+    rb.Push<u32>(static_cast<u32>(can_reach_internet ? (Settings::values.is_new_3ds
+                                                            ? WifiStatus::STATUS_CONNECTED_N3DS
+                                                            : WifiStatus::STATUS_CONNECTED_O3DS)
+                                                     : WifiStatus::STATUS_DISCONNECTED));
+#endif
 }

 void Module::Interface::GetInfraPriority(Kernel::HLERequestContext& ctx) {
diff --git a/src/core/hle/service/ac/ac.h b/src/core/hle/service/ac/ac.h
index 4f72ad1ccd..1d3340e1a8 100644
--- a/src/core/hle/service/ac/ac.h
+++ b/src/core/hle/service/ac/ac.h
@@ -90,7 +90,7 @@ class Module final {
          * AC::GetWifiStatus service function
          *  Outputs:
          *      1 : Result of function, 0 on success, otherwise error code
-         *      2 : WifiStatus
+         *      2 : Output connection type, 0 = none, 1 = Old3DS Internet, 2 = New3DS Internet.
          */
         void GetWifiStatus(Kernel::HLERequestContext& ctx);

@@ -169,9 +169,14 @@ class Module final {
     };
     enum class WifiStatus {
         STATUS_DISCONNECTED = 0,
+#ifdef todotodo
         STATUS_CONNECTED_SLOT1 = (1 << 0),
         STATUS_CONNECTED_SLOT2 = (1 << 1),
         STATUS_CONNECTED_SLOT3 = (1 << 2),
+#else
+        STATUS_CONNECTED_O3DS = 1,
+        STATUS_CONNECTED_N3DS = 2,
+#endif
     };

     struct ACConfig {
diff --git a/src/core/hle/service/act/act_errors.h b/src/core/hle/service/act/act_errors.h
index ee6efabf1a..2e1ff2ac8e 100644
--- a/src/core/hle/service/act/act_errors.h
+++ b/src/core/hle/service/act/act_errors.h
@@ -18,6 +18,7 @@ enum {
     NotInitialized = 101,
     AlreadyInitialized = 102,
     AcStatusDisconnected = 103,
+    ErrDesc103 = 103,
     ErrDesc104 = 104,
     Busy = 111,
     ErrDesc112 = 112,
@@ -317,6 +318,7 @@ enum {
     NotInitialized = 220501,       // 022-0501
     AlreadyInitialized = 220502,   // 022-0502
     AcStatusDisconnected = 225103, // 022-5103
+    ErrCode225103 = 225103,      // 022-5103
     ErrCode225104 = 225104,        // 022-5104
     Busy = 220511,                 // 022-0511
     ErrCode225112 = 225112,        // 022-5112
diff --git a/src/core/hw/aes/key.cpp b/src/core/hw/aes/key.cpp
index 776eab670a..3e2a9cee1b 100644
--- a/src/core/hw/aes/key.cpp
+++ b/src/core/hw/aes/key.cpp
@@ -32,7 +32,10 @@ namespace {
 // On a real 3DS the generation for the normal key is hardware based, and thus the constant can't
 // get dumped. Generated normal keys are also not accessible on a 3DS. The used formula for
 // calculating the constant is a software implementation of what the hardware generator does.
-AESKey generator_constant;
+//AESKey generator_constant;
+
+constexpr AESKey generator_constant = {{0x1F, 0xF9, 0xE9, 0xAA, 0xC5, 0xFE, 0x04, 0x08, 0x02, 0x45,
+                                        0x91, 0xDC, 0x5D, 0x52, 0x76, 0x8A}};

 AESKey HexToKey(const std::string& hex) {
     if (hex.size() < 32) {
@@ -143,6 +146,78 @@ struct KeyDesc {
     bool same_as_before;
 };

+void LoadBootromKeys() {
+    constexpr std::array<KeyDesc, 80> keys = {
+        {{'X', 0x2C, false}, {'X', 0x2D, true},  {'X', 0x2E, true},  {'X', 0x2F, true},
+         {'X', 0x30, false}, {'X', 0x31, true},  {'X', 0x32, true},  {'X', 0x33, true},
+         {'X', 0x34, false}, {'X', 0x35, true},  {'X', 0x36, true},  {'X', 0x37, true},
+         {'X', 0x38, false}, {'X', 0x39, true},  {'X', 0x3A, true},  {'X', 0x3B, true},
+         {'X', 0x3C, false}, {'X', 0x3D, false}, {'X', 0x3E, false}, {'X', 0x3F, false},
+         {'Y', 0x4, false},  {'Y', 0x5, false},  {'Y', 0x6, false},  {'Y', 0x7, false},
+         {'Y', 0x8, false},  {'Y', 0x9, false},  {'Y', 0xA, false},  {'Y', 0xB, false},
+         {'N', 0xC, false},  {'N', 0xD, true},   {'N', 0xE, true},   {'N', 0xF, true},
+         {'N', 0x10, false}, {'N', 0x11, true},  {'N', 0x12, true},  {'N', 0x13, true},
+         {'N', 0x14, false}, {'N', 0x15, false}, {'N', 0x16, false}, {'N', 0x17, false},
+         {'N', 0x18, false}, {'N', 0x19, true},  {'N', 0x1A, true},  {'N', 0x1B, true},
+         {'N', 0x1C, false}, {'N', 0x1D, true},  {'N', 0x1E, true},  {'N', 0x1F, true},
+         {'N', 0x20, false}, {'N', 0x21, true},  {'N', 0x22, true},  {'N', 0x23, true},
+         {'N', 0x24, false}, {'N', 0x25, true},  {'N', 0x26, true},  {'N', 0x27, true},
+         {'N', 0x28, true},  {'N', 0x29, false}, {'N', 0x2A, false}, {'N', 0x2B, false},
+         {'N', 0x2C, false}, {'N', 0x2D, true},  {'N', 0x2E, true},  {'N', 0x2F, true},
+         {'N', 0x30, false}, {'N', 0x31, true},  {'N', 0x32, true},  {'N', 0x33, true},
+         {'N', 0x34, false}, {'N', 0x35, true},  {'N', 0x36, true},  {'N', 0x37, true},
+         {'N', 0x38, false}, {'N', 0x39, true},  {'N', 0x3A, true},  {'N', 0x3B, true},
+         {'N', 0x3C, true},  {'N', 0x3D, false}, {'N', 0x3E, false}, {'N', 0x3F, false}}};
+
+    // Bootrom sets all these keys when executed, but later some of the normal keys get overwritten
+    // by other applications e.g. process9. These normal keys thus aren't used by any application
+    // and have no value for emulation
+
+    const std::string filepath = FileUtil::GetUserPath(FileUtil::UserPath::SysDataDir) + BOOTROM9;
+    auto file = FileUtil::IOFile(filepath, "rb");
+    if (!file) {
+        return;
+    }
+
+    const std::size_t length = file.GetSize();
+    if (length != 65536) {
+        LOG_ERROR(HW_AES, "Bootrom9 size is wrong: {}", length);
+        return;
+    }
+
+    constexpr std::size_t KEY_SECTION_START = 55760;
+    file.Seek(KEY_SECTION_START, SEEK_SET); // Jump to the key section
+
+    AESKey new_key;
+    for (const auto& key : keys) {
+        if (!key.same_as_before) {
+            file.ReadArray(new_key.data(), new_key.size());
+            if (!file) {
+                LOG_ERROR(HW_AES, "Reading from Bootrom9 failed");
+                return;
+            }
+        }
+
+        LOG_DEBUG(HW_AES, "Loaded Slot{:#02x} Key{} from Bootrom9.", key.slot_id, key.key_type);
+
+        switch (key.key_type) {
+        case 'X':
+            key_slots.at(key.slot_id).SetKeyX(new_key);
+            break;
+        case 'Y':
+            key_slots.at(key.slot_id).SetKeyY(new_key);
+            break;
+        case 'N':
+            key_slots.at(key.slot_id).SetNormalKey(new_key);
+            break;
+        default:
+            LOG_ERROR(HW_AES, "Invalid key type {}", key.key_type);
+            break;
+        }
+    }
+}
+
+#ifdef todotodo
 void LoadPresetKeys() {
     auto s = GetKeysStream();

@@ -276,6 +351,112 @@ void LoadPresetKeys() {
         }
     }
 }
+#else
+void LoadPresetKeys() {
+    const std::string filepath = FileUtil::GetUserPath(FileUtil::UserPath::SysDataDir) + AES_KEYS;
+    FileUtil::CreateFullPath(filepath); // Create path if not already created
+
+    boost::iostreams::stream<boost::iostreams::file_descriptor_source> file;
+    FileUtil::OpenFStream<std::ios_base::in>(file, filepath);
+    if (!file.is_open()) {
+        return;
+    }
+
+    while (!file.eof()) {
+        std::string line;
+        std::getline(file, line);
+
+        // Ignore empty or commented lines.
+        if (line.empty() || line.starts_with("#")) {
+            continue;
+        }
+
+        const auto parts = Common::SplitString(line, '=');
+        if (parts.size() != 2) {
+            LOG_ERROR(HW_AES, "Failed to parse {}", line);
+            continue;
+        }
+
+        const std::string& name = parts[0];
+
+        const auto nfc_secret = ParseNfcSecretName(name);
+        if (nfc_secret) {
+            auto value = HexToVector(parts[1]);
+            if (nfc_secret->first >= nfc_secrets.size()) {
+                LOG_ERROR(HW_AES, "Invalid NFC secret index {}", nfc_secret->first);
+            } else if (nfc_secret->second == "Phrase") {
+                nfc_secrets[nfc_secret->first].phrase = value;
+            } else if (nfc_secret->second == "Seed") {
+                nfc_secrets[nfc_secret->first].seed = value;
+            } else if (nfc_secret->second == "HmacKey") {
+                nfc_secrets[nfc_secret->first].hmac_key = value;
+            } else {
+                LOG_ERROR(HW_AES, "Invalid NFC secret '{}'", name);
+            }
+            continue;
+        }
+
+        AESKey key;
+        try {
+            key = HexToKey(parts[1]);
+        } catch (const std::logic_error& e) {
+            LOG_ERROR(HW_AES, "Invalid key {}: {}", parts[1], e.what());
+            continue;
+        }
+
+        const auto common_key = ParseCommonKeyName(name);
+        if (common_key) {
+            if (common_key >= common_key_y_slots.size()) {
+                LOG_ERROR(HW_AES, "Invalid common key index {}", common_key.value());
+            } else {
+                common_key_y_slots[common_key.value()] = key;
+            }
+            continue;
+        }
+
+        if (name == "dlpKeyY") {
+            dlp_nfc_key_y_slots[DlpNfcKeyY::Dlp] = key;
+            continue;
+        }
+
+        if (name == "nfcKeyY") {
+            dlp_nfc_key_y_slots[DlpNfcKeyY::Nfc] = key;
+            continue;
+        }
+
+        if (name == "nfcIv") {
+            nfc_iv = key;
+            continue;
+        }
+
+        const auto key_slot = ParseKeySlotName(name);
+        if (!key_slot) {
+            LOG_ERROR(HW_AES, "Invalid key name '{}'", name);
+            continue;
+        }
+
+        if (key_slot->first >= MaxKeySlotID) {
+            LOG_ERROR(HW_AES, "Out of range key slot ID {:#X}", key_slot->first);
+            continue;
+        }
+
+        switch (key_slot->second) {
+        case 'X':
+            key_slots.at(key_slot->first).SetKeyX(key);
+            break;
+        case 'Y':
+            key_slots.at(key_slot->first).SetKeyY(key);
+            break;
+        case 'N':
+            key_slots.at(key_slot->first).SetNormalKey(key);
+            break;
+        default:
+            LOG_ERROR(HW_AES, "Invalid key type '{}'", key_slot->second);
+            break;
+        }
+    }
+}
+#endif

 } // namespace

@@ -305,6 +486,8 @@ void InitKeys(bool force) {
         return;
     }
     initialized = true;
+    HW::RSA::InitSlots();
+    LoadBootromKeys();
     LoadPresetKeys();
     movable_key.SetKeyX(key_slots[0x35].x);
     movable_cmac.SetKeyX(key_slots[0x35].x);
diff --git a/src/core/hw/ecc.cpp b/src/core/hw/ecc.cpp
index 5033317a20..d262cccdc6 100644
--- a/src/core/hw/ecc.cpp
+++ b/src/core/hw/ecc.cpp
@@ -6,6 +6,7 @@
 #include <boost/iostreams/device/file_descriptor.hpp>
 #include <boost/iostreams/stream.hpp>
 #include "common/assert.h"
+#include <common/string_util.h>
 #include "common/common_paths.h"
 #include "common/file_util.h"
 #include "common/logging/log.h"
diff --git a/src/core/hw/rsa/rsa.cpp b/src/core/hw/rsa/rsa.cpp
index 4181144f62..542bc020ff 100644
--- a/src/core/hw/rsa/rsa.cpp
+++ b/src/core/hw/rsa/rsa.cpp
@@ -21,6 +21,19 @@

 namespace HW::RSA {

+namespace {
+std::vector<u8> HexToBytes(const std::string& hex) {
+    std::vector<u8> bytes;
+
+    for (unsigned int i = 0; i < hex.length(); i += 2) {
+        std::string byteString = hex.substr(i, 2);
+        u8 byte = static_cast<u8>(std::strtol(byteString.c_str(), nullptr, 16));
+        bytes.push_back(byte);
+    }
+    return bytes;
+};
+} // namespace
+
 constexpr std::size_t SlotSize = 4;
 std::array<RsaSlot, SlotSize> rsa_slots;

@@ -92,6 +105,23 @@ std::optional<std::pair<std::size_t, char>> ParseKeySlotName(const std::string&
     }
 }

+std::vector<u8> RsaSlot::GetSignature(std::span<const u8> message) const {
+    CryptoPP::Integer sig =
+        CryptoPP::ModularExponentiation(CryptoPP::Integer(message.data(), message.size()),
+                                        CryptoPP::Integer(exponent.data(), exponent.size()),
+                                        CryptoPP::Integer(modulus.data(), modulus.size()));
+    std::stringstream ss;
+    ss << std::hex << sig;
+    CryptoPP::HexDecoder decoder;
+    decoder.Put(reinterpret_cast<unsigned char*>(ss.str().data()), ss.str().size());
+    decoder.MessageEnd();
+    std::vector<u8> result(decoder.MaxRetrievable());
+    decoder.Get(result.data(), result.size());
+    return HexToBytes(ss.str());
+}
+
+// todotodo
+#ifdef todotodo
 void InitSlots() {
     static bool initialized = false;
     if (initialized)
@@ -193,6 +223,42 @@ void InitSlots() {
         }
     }
 }
+#endif
+
+//--
+void InitSlots() {
+    static bool initialized = false;
+    if (initialized)
+        return;
+    initialized = true;
+
+    const std::string filepath = FileUtil::GetUserPath(FileUtil::UserPath::SysDataDir) + BOOTROM9;
+    FileUtil::IOFile file(filepath, "rb");
+    if (!file) {
+        return;
+    }
+
+    const std::size_t length = file.GetSize();
+    if (length != 65536) {
+        LOG_ERROR(HW_AES, "Bootrom9 size is wrong: {}", length);
+        return;
+    }
+
+    constexpr std::size_t RSA_MODULUS_POS = 0xB3E0;
+    file.Seek(RSA_MODULUS_POS, SEEK_SET);
+    std::vector<u8> modulus(256);
+    file.ReadArray(modulus.data(), modulus.size());
+
+    constexpr std::size_t RSA_EXPONENT_POS = 0xB4E0;
+    file.Seek(RSA_EXPONENT_POS, SEEK_SET);
+    std::vector<u8> exponent(256);
+    file.ReadArray(exponent.data(), exponent.size());
+
+    rsa_slots[0] = RsaSlot(std::move(exponent), std::move(modulus));
+    // TODO(B3N30): Initalize the other slots. But since they aren't used at all, we can skip them
+    // for now
+}
+//--

 static RsaSlot empty_slot;
 const RsaSlot& GetSlot(std::size_t slot_id) {
@@ -201,6 +267,31 @@ const RsaSlot& GetSlot(std::size_t slot_id) {
     return rsa_slots[slot_id];
 }

+std::vector<u8> CreateASN1Message(std::span<const u8> data) {
+    static constexpr std::array<u8, 224> asn1_header = {
+        {0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+         0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+         0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+         0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+         0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+         0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+         0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+         0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+         0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+         0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+         0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+         0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+         0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+         0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x30, 0x31, 0x30, 0x0D, 0x06,
+         0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20}};
+
+    std::vector<u8> message(asn1_header.begin(), asn1_header.end());
+    CryptoPP::SHA256 sha;
+    message.resize(message.size() + CryptoPP::SHA256::DIGESTSIZE);
+    sha.CalculateDigest(message.data() + asn1_header.size(), data.data(), data.size());
+    return message;
+}
+
 const RsaSlot& GetTicketWrapSlot() {
     return ticket_wrap_slot;
 }
diff --git a/src/core/hw/rsa/rsa.h b/src/core/hw/rsa/rsa.h
index b6dd2c1ca0..4041af7ff6 100644
--- a/src/core/hw/rsa/rsa.h
+++ b/src/core/hw/rsa/rsa.h
@@ -23,6 +23,8 @@ class RsaSlot {

     bool Verify(std::span<const u8> message, std::span<const u8> signature) const;

+    std::vector<u8> GetSignature(std::span<const u8> message) const;
+
     explicit operator bool() const {
         // TODO(B3N30): Maybe check if exponent and modulus are vailid
         return init;
@@ -68,4 +70,5 @@ const RsaSlot& GetTicketWrapSlot();
 const RsaSlot& GetSecureInfoSlot();
 const RsaSlot& GetLocalFriendCodeSeedSlot();

+std::vector<u8> CreateASN1Message(std::span<const u8> data);
 } // namespace HW::RSA
diff --git a/src/core/loader/artic.h b/src/core/loader/artic.h
index f5b1483643..07fb6b2558 100644
--- a/src/core/loader/artic.h
+++ b/src/core/loader/artic.h
@@ -26,6 +26,23 @@ class Apploader_Artic final : public AppLoader {
     Apploader_Artic(Core::System& system_, const std::string& server_addr, u16 server_port,
                     ArticInitMode init_mode);

+    Apploader_Artic(Core::System& system_, const std::string& server_addr, u16 server_port)
+        : AppLoader(system_, FileUtil::IOFile()) {
+        client = std::make_shared<Network::ArticBase::Client>(server_addr, server_port);
+        client->SetCommunicationErrorCallback([&system_](const std::string& msg) {
+            system_.SetStatus(Core::System::ResultStatus::ErrorArticDisconnected,
+                              msg.empty() ? nullptr : msg.c_str());
+        });
+        client->SetArticReportTrafficCallback(
+            [&system_](u32 bytes) { system_.ReportArticTraffic(bytes); });
+        client->SetReportArticEventCallback([&system_](u64 event) {
+            Core::PerfStats::PerfArticEventBits ev =
+                static_cast<Core::PerfStats::PerfArticEventBits>(event & 0xFFFFFFFF);
+            bool set = (event > 32) != 0;
+            system_.ReportPerfArticEvent(ev, set);
+        });
+    }
+
     ~Apploader_Artic() override;

     /**
diff --git a/src/core/loader/loader.cpp b/src/core/loader/loader.cpp
index c09760e367..4dd766a375 100644
--- a/src/core/loader/loader.cpp
+++ b/src/core/loader/loader.cpp
@@ -48,7 +48,7 @@ FileType GuessFromExtension(const std::string& extension_) {
     if (extension == ".elf" || extension == ".axf")
         return FileType::ELF;

-    if (extension == ".cci")
+    if (extension == ".cci" || extension == ".3ds")
         return FileType::CCI;

     if (extension == ".cxi" || extension == ".app")
@@ -112,12 +112,14 @@ static std::unique_ptr<AppLoader> GetFileLoader(Core::System& system, FileUtil::
         return std::make_unique<AppLoader_NCCH>(system, std::move(file), filepath);

     case FileType::ARTIC: {
+#ifdef todotodo
         Apploader_Artic::ArticInitMode mode = Apploader_Artic::ArticInitMode::NONE;
         if (filename.starts_with("articinio://")) {
             mode = Apploader_Artic::ArticInitMode::O3DS;
         } else if (filename.starts_with("articinin://")) {
             mode = Apploader_Artic::ArticInitMode::N3DS;
         }
+#endif
         auto strToUInt = [](const std::string& str) -> int {
             char* pEnd = NULL;
             unsigned long ul = ::strtoul(str.c_str(), &pEnd, 10);
@@ -136,7 +138,11 @@ static std::unique_ptr<AppLoader> GetFileLoader(Core::System& system, FileUtil::
                 server_addr = server_addr.substr(0, pos);
             }
         }
+#ifdef todotodo
         return std::make_unique<Apploader_Artic>(system, server_addr, port, mode);
+#else
+        return std::make_unique<Apploader_Artic>(system, server_addr, port);
+#endif
     }

     default:
diff --git a/src/citra_qt/aboutdialog.ui b/src/citra_qt/aboutdialog.ui
index 039e3e2d9..8c2fdea3b 100644
--- a/src/citra_qt/aboutdialog.ui
+++ b/src/citra_qt/aboutdialog.ui
@@ -84,15 +84,16 @@
          </property>
          <property name="text">
           <string>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
-&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
+&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
 p, li { white-space: pre-wrap; }
-&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Ubuntu'; font-size:11pt; font-weight:400; font-style:normal;&quot;&gt;
-&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'MS Shell Dlg 2'; font-size:12pt;&quot;&gt;Azahar is a free and open source 3DS emulator licensed under GPLv2.0 or any later version.&lt;/span&gt;&lt;/p&gt;
-&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'MS Shell Dlg 2'; font-size:8pt;&quot;&gt;&lt;br /&gt;&lt;/p&gt;
-&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'MS Shell Dlg 2'; font-size:12pt;&quot;&gt;This software should not be used to play games you have not legally obtained.&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+hr { height: 1px; border-width: 0; }
+li.unchecked::marker { content: &quot;\2610&quot;; }
+li.checked::marker { content: &quot;\2612&quot;; }
+&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Noto Sans'; font-size:9pt; font-weight:400; font-style:normal;&quot;&gt;
+&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-family:'MS Shell Dlg 2'; font-size:12pt;&quot;&gt;Azahar is a free and open source 3DS emulator licensed under GPLv2.0 or any later version.&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
          </property>
          <property name="alignment">
-          <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignVCenter</set>
+          <set>Qt::AlignmentFlag::AlignLeading|Qt::AlignmentFlag::AlignLeft|Qt::AlignmentFlag::AlignVCenter</set>
          </property>
          <property name="wordWrap">
           <bool>true</bool>
